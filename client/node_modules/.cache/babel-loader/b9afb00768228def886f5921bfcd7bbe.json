{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport const executeOp = (node, tensorMap, context) => {\n  switch (node.op) {\n    case 'Const':\n      {\n        return tensorMap[node.name];\n      }\n\n    case 'PlaceholderWithDefault':\n      const def = getParamValue('default', node, tensorMap, context);\n      return [getTensor(node.name, tensorMap, context) || def];\n\n    case 'Placeholder':\n      return [getTensor(node.name, tensorMap, context)];\n\n    case 'Identity':\n    case 'StopGradient':\n    case 'FakeQuantWithMinMaxVars':\n      {\n        // This op is currently ignored.\n        const data = getParamValue('x', node, tensorMap, context);\n        return [cloneTensor(data)];\n      }\n\n    case 'IdentityN':\n      return getParamValue('x', node, tensorMap, context).map(t => cloneTensor(t));\n\n    case 'Snapshot':\n      const snapshot = getParamValue('x', node, tensorMap, context);\n      return [cloneTensor(snapshot)];\n\n    case 'Shape':\n      return [tfOps.tensor1d(getParamValue('x', node, tensorMap, context).shape, 'int32')];\n\n    case 'ShapeN':\n      return getParamValue('x', node, tensorMap, context).map(t => tfOps.tensor1d(t.shape));\n\n    case 'Size':\n      return [tfOps.scalar(getParamValue('x', node, tensorMap, context).size, 'int32')];\n\n    case 'Rank':\n      return [tfOps.scalar(getParamValue('x', node, tensorMap, context).rank, 'int32')];\n\n    case 'NoOp':\n      return [tfOps.scalar(1)];\n\n    case 'Print':\n      const input = getParamValue('x', node, tensorMap, context);\n      const data = getParamValue('data', node, tensorMap, context);\n      const message = getParamValue('message', node, tensorMap, context);\n      const summarize = getParamValue('summarize', node, tensorMap, context);\n      console.warn('The graph has a tf.print() operation,' + 'usually used for debugging, which slows down performance.');\n      console.log(message);\n\n      for (let i = 0; i < data.length; i++) {\n        console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0, summarize));\n      }\n\n      return [input];\n\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'graph';","map":{"version":3,"mappings":"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","names":["tfOps","cloneTensor","getParamValue","getTensor","executeOp","node","tensorMap","context","op","name","def","data","map","t","snapshot","tensor1d","shape","scalar","size","rank","input","message","summarize","console","warn","log","i","length","Array","prototype","slice","call","dataSync","TypeError","CATEGORY"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-converter/src/operations/executors/graph_executor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {cloneTensor, getParamValue, getTensor} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap,\n     context: ExecutionContext): Tensor[] => {\n      switch (node.op) {\n        case 'Const': {\n          return tensorMap[node.name];\n        }\n        case 'PlaceholderWithDefault':\n          const def =\n              getParamValue('default', node, tensorMap, context) as Tensor;\n          return [getTensor(node.name, tensorMap, context) || def];\n        case 'Placeholder':\n          return [getTensor(node.name, tensorMap, context)];\n        case 'Identity':\n        case 'StopGradient':\n        case 'FakeQuantWithMinMaxVars': {  // This op is currently ignored.\n          const data = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [cloneTensor(data)];\n        }\n        case 'IdentityN':\n          return (getParamValue('x', node, tensorMap, context) as Tensor[])\n              .map((t: Tensor) => cloneTensor(t));\n        case 'Snapshot':\n          const snapshot =\n              (getParamValue('x', node, tensorMap, context) as Tensor);\n          return [cloneTensor(snapshot)];\n        case 'Shape':\n          return [tfOps.tensor1d(\n              (getParamValue('x', node, tensorMap, context) as Tensor).shape,\n              'int32')];\n        case 'ShapeN':\n          return (getParamValue('x', node, tensorMap, context) as Tensor[])\n              .map((t: Tensor) => tfOps.tensor1d(t.shape));\n        case 'Size':\n          return [tfOps.scalar(\n              (getParamValue('x', node, tensorMap, context) as Tensor).size,\n              'int32')];\n        case 'Rank':\n          return [tfOps.scalar(\n              (getParamValue('x', node, tensorMap, context) as Tensor).rank,\n              'int32')];\n        case 'NoOp':\n          return [tfOps.scalar(1)];\n        case 'Print':\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const data =\n              getParamValue('data', node, tensorMap, context) as Tensor[];\n          const message =\n              getParamValue('message', node, tensorMap, context) as string;\n          const summarize =\n              getParamValue('summarize', node, tensorMap, context) as number;\n          console.warn(\n              'The graph has a tf.print() operation,' +\n              'usually used for debugging, which slows down performance.');\n          console.log(message);\n          for (let i = 0; i < data.length; i++) {\n            console.log(Array.prototype.slice.call(data[i].dataSync())\n                            .slice(0, summarize));\n          }\n          return [input];\n\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'graph';\n"]},"metadata":{},"sourceType":"module"}