{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Prod, upcastType, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { transpose } from './Transpose';\nexport function prodImpl(xShape, xDtype, xVals, reductionAxes) {\n  const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n  const outDtype = upcastType(xDtype, 'int32');\n  const outVals = util.makeZerosTypedArray(util.sizeFromShape(outShape), outDtype);\n  const reduceSize = util.sizeFromShape(reduceShape);\n\n  for (let i = 0; i < outVals.length; ++i) {\n    const offset = i * reduceSize;\n    let prod = 1;\n\n    for (let j = 0; j < reduceSize; ++j) {\n      prod *= xVals[offset + j];\n    }\n\n    outVals[i] = prod;\n  }\n\n  return {\n    outVals,\n    outShape,\n    outDtype\n  };\n}\nexport function prod(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    axis,\n    keepDims\n  } = attrs;\n  assertNotComplex(x, 'prod');\n  const xRank = x.shape.length;\n  const axes = util.parseAxisParam(axis, x.shape);\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n  let reductionAxes = axes;\n  let permutedX = x;\n  const intermediateTensorInfos = [];\n\n  if (permutation != null) {\n    permutedX = transpose({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n\n  const xVals = backend.data.get(permutedX.dataId).values;\n  const {\n    outVals,\n    outShape,\n    outDtype\n  } = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n  let resultShape = outShape;\n\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n\n  intermediateTensorInfos.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\nexport const prodConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod\n};","map":{"version":3,"mappings":"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","names":["backend_util","Prod","upcastType","util","assertNotComplex","transpose","prodImpl","xShape","xDtype","xVals","reductionAxes","outShape","reduceShape","computeOutAndReduceShapes","outDtype","outVals","makeZerosTypedArray","sizeFromShape","reduceSize","i","length","offset","prod","j","args","inputs","backend","attrs","x","axis","keepDims","xRank","shape","axes","parseAxisParam","permutation","getAxesPermutation","permutedX","intermediateTensorInfos","perm","push","getInnerMostAxes","data","get","dataId","values","dtype","resultShape","expandShapeToKeepDim","forEach","t","disposeIntermediateTensorInfo","makeTensorInfo","prodConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/Prod.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, Prod, ProdAttrs, ProdInputs, TensorInfo, TypedArray, upcastType, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {transpose} from './Transpose';\n\nexport function prodImpl(\n    xShape: number[], xDtype: DataType, xVals: TypedArray,\n    reductionAxes: number[]):\n    {outVals: TypedArray, outShape: number[], outDtype: DataType} {\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n  const outDtype = upcastType(xDtype, 'int32');\n  const outVals = util.makeZerosTypedArray(\n                      util.sizeFromShape(outShape), outDtype) as TypedArray;\n  const reduceSize = util.sizeFromShape(reduceShape);\n\n  for (let i = 0; i < outVals.length; ++i) {\n    const offset = i * reduceSize;\n    let prod = 1;\n    for (let j = 0; j < reduceSize; ++j) {\n      prod *= xVals[offset + j];\n    }\n    outVals[i] = prod;\n  }\n\n  return {outVals, outShape, outDtype};\n}\n\nexport function prod(\n    args: {inputs: ProdInputs, backend: MathBackendCPU, attrs: ProdAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  assertNotComplex(x, 'prod');\n\n  const xRank = x.shape.length;\n  const axes = util.parseAxisParam(axis, x.shape);\n\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n  let reductionAxes = axes;\n  let permutedX = x;\n  const intermediateTensorInfos = [];\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n\n  const xVals = backend.data.get(permutedX.dataId).values as TypedArray;\n  const {outVals, outShape, outDtype} =\n      prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n\n  let resultShape = outShape;\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\n\nexport const prodConfig: KernelConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod as {} as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module"}