{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tensor1d } from '../tensor1d';\nimport { op } from '../operation';\nimport { cast } from '../cast';\nimport { split } from '../split';\nimport { bincount } from '../bincount';\nimport { lessEqual } from '../less_equal';\nimport { greater } from '../greater';\nimport { sum } from '../sum';\nimport { add } from '../add';\nimport { mul } from '../mul';\nimport { div } from '../div';\nimport { sub } from '../sub';\nimport { round } from '../round';\nimport { where } from '../where';\nimport { fill } from '../fill';\nimport { slice } from '../slice';\nimport { range } from '../range';\nimport { tensor } from '../tensor';\nimport * as util from '../../util';\nimport { convertToTensor } from '../../tensor_util_env';\n/**\n * Performs image binarization with corresponding threshold\n * (depends on the method)value, which creates a binary image from a grayscale.\n * @param image 3d tensor of shape [imageHeight,imageWidth, depth],\n * where imageHeight and imageWidth must be positive.The image color\n * range should be [0, 255].\n * @param method Optional string from `'binary' | 'otsu'`\n * which specifies the method for thresholding. Defaults to 'binary'.\n * @param inverted Optional boolean whichspecifies\n * if colours should be inverted. Defaults to false.\n * @param threshValue Optional number which defines threshold value from 0 to 1.\n * Defaults to 0.5.\n * @return A 3d tensor of shape [imageHeight,imageWidth, depth], which\n * contains binarized image.\n */\n\nfunction threshold_(image) {\n  let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'binary';\n  let inverted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let threshValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n  const $image = convertToTensor(image, 'image', 'threshold');\n  /* 0.2989, 0.5870, 0.1140 are represent luma coefficients in CCIR601.\n  Reference for converting between RGB and grayscale: https://en.wikipedia.org/wiki/Luma_%28video%29  */\n\n  const RED_INTENCITY_COEF = 0.2989;\n  const GREEN_INTENCITY_COEF = 0.5870;\n  const BLUE_INTENCITY_COEF = 0.1140;\n  const totalPixelsInImage = $image.shape[0] * $image.shape[1];\n  let $threshold = mul(tensor1d([threshValue]), 255);\n  let r, g, b, grayscale;\n  util.assert($image.rank === 3, () => 'Error in threshold: image must be rank 3,' + `but got rank ${$image.rank}.`);\n  util.assert($image.shape[2] === 3 || $image.shape[2] === 1, () => 'Error in threshold: ' + 'image color channel must be equal to 3 or 1' + `but got ${$image.shape[2]}.`);\n  util.assert($image.dtype === 'int32' || $image.dtype === 'float32', () => 'Error in dtype: image dtype must be int32 or float32,' + `but got dtype ${$image.dtype}.`);\n  util.assert(method === 'otsu' || method === 'binary', () => `Method must be binary or otsu, but was ${method}`);\n\n  if ($image.shape[2] === 3) {\n    [r, g, b] = split($image, [1, 1, 1], -1);\n    const $r = mul(r, RED_INTENCITY_COEF);\n    const $g = mul(g, GREEN_INTENCITY_COEF);\n    const $b = mul(b, BLUE_INTENCITY_COEF);\n    grayscale = add(add($r, $g), $b);\n  } else {\n    grayscale = image;\n  }\n\n  if (method === 'otsu') {\n    const $histogram = bincount(cast(round(grayscale), 'int32'), tensor([]), 256);\n    $threshold = otsu($histogram, totalPixelsInImage);\n  }\n\n  const invCondition = inverted ? lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);\n  const result = cast(mul(invCondition, 255), 'int32');\n  return result;\n}\n\nfunction otsu(histogram, total) {\n  let bestThresh = tensor1d([-1]);\n  let bestInBetVar = tensor1d([0]);\n  let cInBetVar = tensor1d([0]);\n  let classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;\n\n  for (let index = 0; index < histogram.size - 1; index++) {\n    classFirst = slice(histogram, 0, index + 1);\n    classSecond = slice(histogram, index + 1);\n    weightForeground = div(sum(classFirst), total);\n    weightBack = div(sum(classSecond), total);\n    const meanFirstDivA = sum(mul(classFirst, range(0, classFirst.size)));\n    meanFirst = div(meanFirstDivA, sum(classFirst));\n    const meanSecFill = fill(classSecond.shape, classFirst.size);\n    const meanSecAdd = add(range(0, classSecond.size), meanSecFill);\n    const meanSecMul = mul(classSecond, meanSecAdd);\n    meanSec = div(sum(meanSecMul), sum(classSecond));\n    const cInBetVarSubA = sub(meanFirst, meanSec);\n    const cInBetVarSubB = sub(meanFirst, meanSec);\n    const cInBetVarMul = mul(weightForeground, weightBack);\n    cInBetVar = mul(mul(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);\n    const condition = greater(cInBetVar, bestInBetVar);\n    bestInBetVar = where(condition, cInBetVar, bestInBetVar);\n    bestThresh = where(condition, tensor1d([index]), bestThresh);\n  }\n\n  return bestThresh;\n}\n\nexport const threshold = op({\n  threshold_\n});","map":{"version":3,"mappings":"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","names":["tensor1d","op","cast","split","bincount","lessEqual","greater","sum","add","mul","div","sub","round","where","fill","slice","range","tensor","util","convertToTensor","threshold_","image","method","inverted","threshValue","$image","RED_INTENCITY_COEF","GREEN_INTENCITY_COEF","BLUE_INTENCITY_COEF","totalPixelsInImage","shape","$threshold","r","g","b","grayscale","assert","rank","dtype","$r","$g","$b","$histogram","otsu","invCondition","result","histogram","total","bestThresh","bestInBetVar","cInBetVar","classFirst","classSecond","meanFirst","meanSec","weightForeground","weightBack","index","size","meanFirstDivA","meanSecFill","meanSecAdd","meanSecMul","cInBetVarSubA","cInBetVarSubB","cInBetVarMul","condition","threshold"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/ops/image/threshold.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { Tensor1D, Tensor3D } from '../../tensor';\nimport { tensor1d } from '../tensor1d';\nimport { TensorLike } from '../../types';\nimport { op } from '../operation';\nimport { cast } from '../cast';\nimport { split } from '../split';\nimport { bincount } from '../bincount';\nimport { lessEqual } from '../less_equal';\nimport { greater } from '../greater';\nimport { sum } from '../sum';\nimport { add } from '../add';\nimport { mul } from '../mul';\nimport { div } from '../div';\nimport { sub } from '../sub';\nimport { round } from '../round';\nimport { where } from '../where';\nimport { fill } from '../fill';\nimport {slice} from '../slice';\nimport { range } from '../range';\nimport { tensor } from '../tensor';\nimport * as util from '../../util';\nimport { convertToTensor } from '../../tensor_util_env';\n\n/**\n * Performs image binarization with corresponding threshold\n * (depends on the method)value, which creates a binary image from a grayscale.\n * @param image 3d tensor of shape [imageHeight,imageWidth, depth],\n * where imageHeight and imageWidth must be positive.The image color\n * range should be [0, 255].\n * @param method Optional string from `'binary' | 'otsu'`\n * which specifies the method for thresholding. Defaults to 'binary'.\n * @param inverted Optional boolean whichspecifies\n * if colours should be inverted. Defaults to false.\n * @param threshValue Optional number which defines threshold value from 0 to 1.\n * Defaults to 0.5.\n * @return A 3d tensor of shape [imageHeight,imageWidth, depth], which\n * contains binarized image.\n */\n\nfunction threshold_(\n    image: Tensor3D | TensorLike,\n    method = 'binary',\n    inverted = false,\n    threshValue = 0.5\n): Tensor3D {\n    const $image = convertToTensor(image, 'image', 'threshold');\n\n    /* 0.2989, 0.5870, 0.1140 are represent luma coefficients in CCIR601.\n\tReference for converting between RGB and grayscale: https://en.wikipedia.org/wiki/Luma_%28video%29  */\n\n    const RED_INTENCITY_COEF = 0.2989;\n    const GREEN_INTENCITY_COEF = 0.5870;\n    const BLUE_INTENCITY_COEF = 0.1140;\n    const totalPixelsInImage = $image.shape[0] * $image.shape[1];\n\n    let $threshold = mul(tensor1d([threshValue]), 255);\n    let r, g, b, grayscale;\n\n    util.assert(\n        $image.rank === 3,\n        () => 'Error in threshold: image must be rank 3,' +\n            `but got rank ${$image.rank}.`);\n\n    util.assert(\n        $image.shape[2] === 3 || $image.shape[2]=== 1,\n        () => 'Error in threshold: ' +\n            'image color channel must be equal to 3 or 1' +\n            `but got ${$image.shape[2]}.`);\n\n    util.assert(\n      $image.dtype === 'int32' || $image.dtype === 'float32',\n      () => 'Error in dtype: image dtype must be int32 or float32,' +\n          `but got dtype ${$image.dtype}.`);\n\n    util.assert(\n      method === 'otsu' || method === 'binary',\n      () => `Method must be binary or otsu, but was ${method}`);\n\n    if ($image.shape[2] === 3) {\n        [r, g, b] = split($image, [1, 1, 1], -1);\n        const $r = mul(r,RED_INTENCITY_COEF);\n        const $g = mul(g,GREEN_INTENCITY_COEF);\n        const $b = mul(b,BLUE_INTENCITY_COEF);\n        grayscale = add(add($r, $g), $b);\n    } else {\n        grayscale = image;\n    }\n\n    if (method === 'otsu') {\n        const $histogram = bincount(cast(round(grayscale), 'int32') as Tensor1D,\n            tensor([]),\n            256);\n        $threshold = otsu($histogram, totalPixelsInImage);\n    }\n\n    const invCondition = inverted ?\n        lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);\n\n    const result = cast(mul(invCondition,255), 'int32');\n\n    return result as Tensor3D;\n}\n\nfunction otsu(histogram: Tensor1D, total: number):Tensor1D {\n\n    let bestThresh = tensor1d([-1]);\n    let bestInBetVar = tensor1d([0]);\n    let cInBetVar = tensor1d([0]);\n    let classFirst, classSecond, meanFirst,\n        meanSec, weightForeground, weightBack;\n\n    for (let index = 0; index < histogram.size-1; index++) {\n\n        classFirst = slice(histogram, 0, index + 1);\n\n        classSecond = slice(histogram,index + 1);\n\n        weightForeground = div(sum(classFirst),total);\n\n        weightBack = div(sum(classSecond),total);\n\n        const meanFirstDivA = sum(mul(classFirst, range(0, classFirst.size)));\n\n        meanFirst = div(meanFirstDivA, sum(classFirst) );\n\n        const meanSecFill = fill(classSecond.shape, classFirst.size);\n        const meanSecAdd = add(range(0,classSecond.size),meanSecFill);\n        const meanSecMul = mul(classSecond, (meanSecAdd));\n        meanSec = div(sum(meanSecMul), sum(classSecond));\n\n        const cInBetVarSubA = sub(meanFirst, meanSec);\n        const cInBetVarSubB = sub(meanFirst, meanSec);\n        const cInBetVarMul = mul(weightForeground, weightBack);\n        cInBetVar = mul(mul(cInBetVarMul,cInBetVarSubA), cInBetVarSubB);\n\n        const condition = greater(cInBetVar, bestInBetVar);\n\n        bestInBetVar = where(condition, cInBetVar, bestInBetVar);\n\n        bestThresh = where(condition, tensor1d([index]), bestThresh);\n\n    }\n    return bestThresh;\n}\n\nexport const threshold = op({ threshold_ });\n"]},"metadata":{},"sourceType":"module"}