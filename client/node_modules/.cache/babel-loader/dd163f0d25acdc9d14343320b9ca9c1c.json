{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, upcastType } from '@tensorflow/tfjs-core';\nimport { BinaryOpProgram } from '../binaryop_gpu';\nimport { BinaryOpPackedProgram } from '../binaryop_packed_gpu';\nimport { complex } from '../kernels/Complex';\nimport { LEAKYRELU, LEAKYRELU_PACKED } from '../kernels/LeakyRelu';\nimport { PRELU, PRELU_PACKED } from '../kernels/Prelu';\nimport * as unary_op from '../unaryop_gpu';\nimport { UnaryOpProgram } from '../unaryop_gpu';\nimport * as unary_packed_op from '../unaryop_packed_gpu';\nimport { UnaryOpPackedProgram } from '../unaryop_packed_gpu';\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\nexport const CHECK_NAN_SNIPPET_BINARY = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippet Op snippet to create `UnaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `UnaryOpPackedProgram`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\n\nexport function unaryKernelFunc(_ref) {\n  let {\n    opSnippet,\n    packedOpSnippet,\n    cpuKernelImpl,\n    dtype\n  } = _ref;\n  return _ref2 => {\n    let {\n      inputs,\n      backend\n    } = _ref2;\n    const {\n      x\n    } = inputs;\n    const webglBackend = backend;\n    const $dtype = dtype || x.dtype;\n\n    if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {\n      const xData = webglBackend.texData.get(x.dataId);\n      const outValues = cpuKernelImpl(xData.values, $dtype);\n      return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);\n    }\n\n    const shouldUsePackedProgram = env().getBool('WEBGL_PACK_UNARY_OPERATIONS') && packedOpSnippet != null;\n    let program;\n\n    if (shouldUsePackedProgram) {\n      program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);\n    } else {\n      program = new UnaryOpProgram(x.shape, opSnippet);\n    }\n\n    return webglBackend.runWebGLProgram(program, [x], $dtype);\n  };\n}\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\n\nexport function binaryKernelFunc(_ref3) {\n  let {\n    opSnippet,\n    packedOpSnippet,\n    checkOutOfBounds = false,\n    supportsComplex = false,\n    cpuKernelImpl,\n    dtype\n  } = _ref3;\n  return _ref4 => {\n    let {\n      inputs,\n      backend\n    } = _ref4;\n    const {\n      a,\n      b\n    } = inputs;\n    const webglBackend = backend;\n\n    if (supportsComplex && a.dtype === 'complex64') {\n      const aData = webglBackend.texData.get(a.dataId);\n      const bData = webglBackend.texData.get(b.dataId);\n      const [real, imag] = [[aData.complexTensorInfos.real, bData.complexTensorInfos.real], [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]].map(complexParts => {\n        const [aPart, bPart] = complexParts;\n        const aHandle = {\n          dataId: aPart.dataId,\n          dtype: aPart.dtype,\n          shape: a.shape\n        };\n        const bHandle = {\n          dataId: bPart.dataId,\n          dtype: bPart.dtype,\n          shape: b.shape\n        };\n        const program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        return webglBackend.runWebGLProgram(program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n      });\n      const complexOutput = complex({\n        inputs: {\n          real,\n          imag\n        },\n        backend: webglBackend\n      });\n      webglBackend.disposeIntermediateTensorInfo(real);\n      webglBackend.disposeIntermediateTensorInfo(imag); // TODO(annxingyuan): Implement CPU forwarding for complex inputs.\n\n      return complexOutput;\n    }\n\n    const $dtype = dtype || upcastType(a.dtype, b.dtype);\n\n    if ((a.dtype === 'string' || b.dtype === 'string' || webglBackend.shouldExecuteOnCPU([a, b])) && cpuKernelImpl != null) {\n      const aVals = webglBackend.texData.get(a.dataId).values;\n      const bVals = webglBackend.texData.get(b.dataId).values;\n      const decodedAVals = a.dtype === 'string' ? // tslint:disable-next-line: no-any\n      backend_util.fromUint8ToStringArray(aVals) : aVals;\n      const decodedBVals = a.dtype === 'string' ? // tslint:disable-next-line: no-any\n      backend_util.fromUint8ToStringArray(bVals) : bVals;\n      const [outValues, outShape] = cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);\n      const out = webglBackend.makeTensorInfo(outShape, $dtype);\n      const outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n      return out;\n    }\n\n    const shouldUsePackedProgram = env().getBool('WEBGL_PACK_BINARY_OPERATIONS') && packedOpSnippet != null;\n    let program;\n\n    if (shouldUsePackedProgram) {\n      program = new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);\n    } else {\n      program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    }\n\n    return webglBackend.runWebGLProgram(program, [a, b], $dtype);\n  };\n}\nexport function mapActivationToShaderProgram(activation) {\n  let packed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (activation === 'linear') {\n    if (packed) {\n      return unary_packed_op.LINEAR;\n    }\n\n    return unary_op.LINEAR;\n  } else if (activation === 'relu') {\n    if (packed) {\n      return unary_packed_op.RELU;\n    }\n\n    return unary_op.RELU;\n  } else if (activation === 'elu') {\n    if (packed) {\n      return unary_packed_op.ELU;\n    }\n\n    return unary_op.ELU;\n  } else if (activation === 'relu6') {\n    if (packed) {\n      return unary_packed_op.RELU6;\n    }\n\n    return unary_op.RELU6;\n  } else if (activation === 'prelu') {\n    if (packed) {\n      return PRELU_PACKED;\n    }\n\n    return PRELU;\n  } else if (activation === 'leakyrelu') {\n    if (packed) {\n      return LEAKYRELU_PACKED;\n    }\n\n    return LEAKYRELU;\n  } else if (activation === 'sigmoid') {\n    if (packed) {\n      return unary_packed_op.SIGMOID;\n    }\n\n    return unary_op.SIGMOID;\n  }\n\n  throw new Error(`Activation ${activation} has not been implemented for the WebGL backend.`);\n}","map":{"version":3,"mappings":"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","names":["backend_util","env","upcastType","BinaryOpProgram","BinaryOpPackedProgram","complex","LEAKYRELU","LEAKYRELU_PACKED","PRELU","PRELU_PACKED","unary_op","UnaryOpProgram","unary_packed_op","UnaryOpPackedProgram","CHECK_NAN_SNIPPET_UNARY","CHECK_NAN_SNIPPET_BINARY","CHECK_NAN_SNIPPET_BINARY_PACKED","unaryKernelFunc","opSnippet","packedOpSnippet","cpuKernelImpl","dtype","inputs","backend","x","webglBackend","$dtype","shouldExecuteOnCPU","xData","texData","get","dataId","outValues","values","makeTensorInfo","shape","shouldUsePackedProgram","getBool","program","runWebGLProgram","binaryKernelFunc","checkOutOfBounds","supportsComplex","a","b","aData","bData","real","imag","complexTensorInfos","map","complexParts","aPart","bPart","aHandle","bHandle","complexOutput","disposeIntermediateTensorInfo","aVals","bVals","decodedAVals","fromUint8ToStringArray","decodedBVals","outShape","out","outData","mapActivationToShaderProgram","activation","packed","LINEAR","RELU","ELU","RELU6","SIGMOID","Error"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-webgl/src/kernel_utils/kernel_funcs_utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BinaryInputs, DataType, env, KernelFunc, TypedArray, UnaryInputs, upcastType} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {BinaryOpProgram} from '../binaryop_gpu';\nimport {BinaryOpPackedProgram} from '../binaryop_packed_gpu';\nimport {complex} from '../kernels/Complex';\nimport {LEAKYRELU, LEAKYRELU_PACKED} from '../kernels/LeakyRelu';\nimport {PRELU, PRELU_PACKED} from '../kernels/Prelu';\nimport * as unary_op from '../unaryop_gpu';\nimport {UnaryOpProgram} from '../unaryop_gpu';\nimport * as unary_packed_op from '../unaryop_packed_gpu';\nimport {UnaryOpPackedProgram} from '../unaryop_packed_gpu';\n\nimport {SimpleBinaryKernelImplCPU, SimpleUnaryKernelImplCPU} from './shared';\n\nexport const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;\n\nexport const CHECK_NAN_SNIPPET_BINARY = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\n\nexport const CHECK_NAN_SNIPPET_BINARY_PACKED = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\n\ntype UnaryKernelFuncConfig = {\n  opSnippet: string,\n  packedOpSnippet?: string,\n  cpuKernelImpl?: SimpleUnaryKernelImplCPU,\n  dtype?: DataType\n};\n\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippet Op snippet to create `UnaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `UnaryOpPackedProgram`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function unaryKernelFunc(\n    {opSnippet, packedOpSnippet, cpuKernelImpl, dtype}: UnaryKernelFuncConfig):\n    KernelFunc {\n  return ({inputs, backend}) => {\n    const {x} = inputs as UnaryInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    const $dtype = dtype || x.dtype;\n    if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {\n      const xData = webglBackend.texData.get(x.dataId);\n      const outValues = cpuKernelImpl(xData.values as TypedArray, $dtype);\n      return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK_UNARY_OPERATIONS') && packedOpSnippet != null;\n    let program: UnaryOpProgram|UnaryOpPackedProgram;\n    if (shouldUsePackedProgram) {\n      program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);\n    } else {\n      program = new UnaryOpProgram(x.shape, opSnippet);\n    }\n\n    return webglBackend.runWebGLProgram(program, [x], $dtype);\n  };\n}\n\ntype BinaryKernelFuncConfig = {\n  opSnippet: string,\n  packedOpSnippet?: string,\n  checkOutOfBounds?: boolean,\n  supportsComplex?: boolean,\n  cpuKernelImpl?: SimpleBinaryKernelImplCPU,\n  dtype?: DataType\n};\n\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param packedOpSnippet Op snippet to create `BinaryOpPackedProgram`.\n * @param checkOutOfBoundsForPackedProgram Whether to set checkOutOfBounds=true\n *     when creating BinaryOpPackedProgram.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc({\n  opSnippet,\n  packedOpSnippet,\n  checkOutOfBounds = false,\n  supportsComplex = false,\n  cpuKernelImpl,\n  dtype\n}: BinaryKernelFuncConfig): KernelFunc {\n  return ({inputs, backend}) => {\n    const {a, b} = inputs as BinaryInputs;\n    const webglBackend = backend as MathBackendWebGL;\n\n    if (supportsComplex && a.dtype === 'complex64') {\n      const aData = webglBackend.texData.get(a.dataId);\n      const bData = webglBackend.texData.get(b.dataId);\n\n      const [real, imag] = [\n        [aData.complexTensorInfos.real, bData.complexTensorInfos.real],\n        [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]\n      ].map(complexParts => {\n        const [aPart, bPart] = complexParts;\n\n        const aHandle = {\n          dataId: aPart.dataId,\n          dtype: aPart.dtype,\n          shape: a.shape\n        };\n        const bHandle = {\n          dataId: bPart.dataId,\n          dtype: bPart.dtype,\n          shape: b.shape\n        };\n\n        const program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n        return webglBackend.runWebGLProgram(\n            program, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));\n      });\n\n      const complexOutput =\n          complex({inputs: {real, imag}, backend: webglBackend});\n\n      webglBackend.disposeIntermediateTensorInfo(real);\n      webglBackend.disposeIntermediateTensorInfo(imag);\n\n      // TODO(annxingyuan): Implement CPU forwarding for complex inputs.\n\n      return complexOutput;\n    }\n\n    const $dtype = dtype || upcastType(a.dtype, b.dtype);\n    if ((a.dtype === 'string' || b.dtype === 'string' ||\n         webglBackend.shouldExecuteOnCPU([a, b])) &&\n        cpuKernelImpl != null) {\n      const aVals = webglBackend.texData.get(a.dataId).values as TypedArray;\n      const bVals = webglBackend.texData.get(b.dataId).values as TypedArray;\n\n      const decodedAVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(aVals as any as Uint8Array[]) :\n          aVals;\n      const decodedBVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(bVals as any as Uint8Array[]) :\n          bVals;\n      const [outValues, outShape] =\n          cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);\n\n      const out = webglBackend.makeTensorInfo(outShape, $dtype);\n      const outData = webglBackend.texData.get(out.dataId);\n      outData.values = outValues;\n      return out;\n    }\n\n    const shouldUsePackedProgram =\n        env().getBool('WEBGL_PACK_BINARY_OPERATIONS') &&\n        packedOpSnippet != null;\n    let program: BinaryOpProgram|BinaryOpPackedProgram;\n    if (shouldUsePackedProgram) {\n      program = new BinaryOpPackedProgram(\n          packedOpSnippet, a.shape, b.shape, checkOutOfBounds);\n    } else {\n      program = new BinaryOpProgram(opSnippet, a.shape, b.shape);\n    }\n\n    return webglBackend.runWebGLProgram(program, [a, b], $dtype);\n  };\n}\n\nexport function mapActivationToShaderProgram(\n    activation: backend_util.Activation, packed = false): string {\n  if (activation === 'linear') {\n    if (packed) {\n      return unary_packed_op.LINEAR;\n    }\n    return unary_op.LINEAR;\n  } else if (activation === 'relu') {\n    if (packed) {\n      return unary_packed_op.RELU;\n    }\n    return unary_op.RELU;\n  } else if (activation === 'elu') {\n    if (packed) {\n      return unary_packed_op.ELU;\n    }\n    return unary_op.ELU;\n  } else if (activation === 'relu6') {\n    if (packed) {\n      return unary_packed_op.RELU6;\n    }\n    return unary_op.RELU6;\n  } else if (activation === 'prelu') {\n    if (packed) {\n      return PRELU_PACKED;\n    }\n    return PRELU;\n  } else if (activation === 'leakyrelu') {\n    if (packed) {\n      return LEAKYRELU_PACKED;\n    }\n    return LEAKYRELU;\n  } else if (activation === 'sigmoid') {\n    if (packed) {\n      return unary_packed_op.SIGMOID;\n    }\n    return unary_op.SIGMOID;\n  }\n  throw new Error(`Activation ${\n      activation} has not been implemented for the WebGL backend.`);\n}\n"]},"metadata":{},"sourceType":"module"}