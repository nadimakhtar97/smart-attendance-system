{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ReversePackedProgram {\n  constructor(xShape, axis) {\n    this.variableNames = ['x'];\n    this.packedInputs = true;\n    this.packedOutput = true;\n    const rank = xShape.length;\n\n    if (rank > 4) {\n      throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n\n    this.outputShape = xShape;\n    const channels = getChannels('rc', rank);\n    const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n    const type = getCoordsDataType(rank);\n\n    if (rank === 1) {\n      this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n    } else {\n      this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n    }\n\n    function getR(channels) {\n      return getChannel(channels);\n    }\n\n    function getG(channels) {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getB(channels) {\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getA(channels) {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getChannel(channels) {\n      const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n      const inCoords = inCoordsArray.join(',');\n      const innerDims = inCoordsArray.slice(-2).join(',');\n      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n    }\n\n    function getInCoord(i, channels1) {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - ${channels1[i]} - 1`;\n      } else {\n        return `${channels1[i]}`;\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["getChannels","getCoordsDataType","ReversePackedProgram","constructor","xShape","axis","rank","length","Error","outputShape","channels","nextColumn","nextRow","type","userCode","getR","slice","getG","getB","getA","getChannel","inCoordsArray","map","_","i","getInCoord","inCoords","join","innerDims","channels1","indexOf"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-webgl/src/reverse_packed_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReversePackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n    const channels = getChannels('rc', rank);\n    const nextColumn =\n        `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n    const type = getCoordsDataType(rank);\n    if (rank === 1) {\n      this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n    } else {\n      this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n    }\n\n    function getR(channels: string[]): string {\n      return getChannel(channels);\n    }\n\n    function getG(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getB(channels: string[]): string {\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getA(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getChannel(channels: string[]): string {\n      const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n      const inCoords = inCoordsArray.join(',');\n      const innerDims = inCoordsArray.slice(-2).join(',');\n      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n    }\n\n    function getInCoord(i: number, channels1: string[]): string {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - ${channels1[i]} - 1`;\n      } else {\n        return `${channels1[i]}`;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}