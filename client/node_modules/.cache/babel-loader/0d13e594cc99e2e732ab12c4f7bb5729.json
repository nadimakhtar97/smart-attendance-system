{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\n/**\n * A ring buffer, providing O(1) FIFO, LIFO, and related operations.\n */\nexport class RingBuffer {\n  /**\n   * Constructs a `RingBuffer`.\n   * @param capacity The number of items that the buffer can accomodate.\n   */\n  constructor(capacity) {\n    this.capacity = capacity; // Note we store the indices in the range 0 <= index < 2*capacity.\n    // This allows us to distinguish the full from the empty case.\n    // See https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/\n\n    this.begin = 0; // inclusive\n\n    this.end = 0; // exclusive\n\n    if (capacity == null) {\n      throw new RangeError('Can\\'t create a ring buffer of unknown capacity.');\n    }\n\n    if (capacity < 1) {\n      throw new RangeError('Can\\'t create ring buffer of capacity < 1.');\n    }\n\n    this.data = new Array(capacity);\n    this.doubledCapacity = 2 * capacity;\n  }\n  /**\n   * Map any index into the range 0 <= index < 2*capacity.\n   */\n\n\n  wrap(index) {\n    // don't trust % on negative numbers\n    while (index < 0) {\n      index += this.doubledCapacity;\n    }\n\n    return index % this.doubledCapacity;\n  }\n\n  get(index) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t get item at a negative index.');\n    }\n\n    return this.data[index % this.capacity];\n  }\n\n  set(index, value) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t set item at a negative index.');\n    }\n\n    this.data[index % this.capacity] = value;\n  }\n  /**\n   * Returns the current number of items in the buffer.\n   */\n\n\n  length() {\n    let length = this.end - this.begin;\n\n    if (length < 0) {\n      length = this.doubledCapacity + length;\n    }\n\n    return length;\n  }\n  /**\n   * Reports whether the buffer is full.\n   * @returns true if the number of items in the buffer equals its capacity, and\n   *   false otherwise.\n   */\n\n\n  isFull() {\n    return this.length() === this.capacity;\n  }\n  /**\n   * Reports whether the buffer is empty.\n   * @returns true if the number of items in the buffer equals zero, and\n   *   false otherwise.\n   */\n\n\n  isEmpty() {\n    return this.length() === 0;\n  }\n  /**\n   * Adds an item to the end of the buffer.\n   */\n\n\n  push(value) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n\n    this.set(this.end, value);\n    this.end = this.wrap(this.end + 1);\n  }\n  /**\n   * Adds many items to the end of the buffer, in order.\n   */\n\n\n  pushAll(values) {\n    for (const value of values) {\n      this.push(value);\n    }\n  }\n  /**\n   * Removes and returns the last item in the buffer.\n   */\n\n\n  pop() {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n\n    this.end = this.wrap(this.end - 1);\n    const result = this.get(this.end);\n    this.set(this.end, undefined);\n    return result;\n  }\n  /**\n   * Adds an item to the beginning of the buffer.\n   */\n\n\n  unshift(value) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n\n    this.begin = this.wrap(this.begin - 1);\n    this.set(this.begin, value);\n  }\n  /**\n   * Removes and returns the first item in the buffer.\n   */\n\n\n  shift() {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n\n    const result = this.get(this.begin);\n    this.set(this.begin, undefined);\n    this.begin = this.wrap(this.begin + 1);\n    return result;\n  }\n  /**\n   * Removes and returns a specific item in the buffer, and moves the last item\n   * to the vacated slot.  This is useful for implementing a shuffling stream.\n   * Note that this operation necessarily scrambles the original order.\n   *\n   * @param relativeIndex: the index of the item to remove, relative to the\n   *   first item in the buffer (e.g., hiding the ring nature of the underlying\n   *   storage).\n   */\n\n\n  shuffleExcise(relativeIndex) {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n\n    const index = this.wrap(this.begin + relativeIndex);\n    const result = this.get(index);\n    this.set(index, this.pop());\n    return result;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["RingBuffer","constructor","capacity","RangeError","data","Array","doubledCapacity","wrap","index","get","set","value","length","end","begin","isFull","isEmpty","push","pushAll","values","pop","result","undefined","unshift","shift","shuffleExcise","relativeIndex"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-data/src/util/ring_buffer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\n/**\n * A ring buffer, providing O(1) FIFO, LIFO, and related operations.\n */\nexport class RingBuffer<T> {\n  // Note we store the indices in the range 0 <= index < 2*capacity.\n  // This allows us to distinguish the full from the empty case.\n  // See https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/\n  protected begin = 0;  // inclusive\n  protected end = 0;    // exclusive\n  protected doubledCapacity: number;\n\n  protected data: T[];\n\n  /**\n   * Constructs a `RingBuffer`.\n   * @param capacity The number of items that the buffer can accomodate.\n   */\n  constructor(public capacity: number) {\n    if (capacity == null) {\n      throw new RangeError('Can\\'t create a ring buffer of unknown capacity.');\n    }\n    if (capacity < 1) {\n      throw new RangeError('Can\\'t create ring buffer of capacity < 1.');\n    }\n    this.data = new Array<T>(capacity);\n    this.doubledCapacity = 2 * capacity;\n  }\n\n  /**\n   * Map any index into the range 0 <= index < 2*capacity.\n   */\n  protected wrap(index: number) {\n    // don't trust % on negative numbers\n    while (index < 0) {\n      index += this.doubledCapacity;\n    }\n    return index % this.doubledCapacity;\n  }\n\n  protected get(index: number) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t get item at a negative index.');\n    }\n    return this.data[index % this.capacity];\n  }\n\n  protected set(index: number, value: T) {\n    if (index < 0) {\n      throw new RangeError('Can\\'t set item at a negative index.');\n    }\n    this.data[index % this.capacity] = value;\n  }\n\n  /**\n   * Returns the current number of items in the buffer.\n   */\n  length(): number {\n    let length = this.end - this.begin;\n    if (length < 0) {\n      length = this.doubledCapacity + length;\n    }\n    return length;\n  }\n\n  /**\n   * Reports whether the buffer is full.\n   * @returns true if the number of items in the buffer equals its capacity, and\n   *   false otherwise.\n   */\n  isFull() {\n    return this.length() === this.capacity;\n  }\n\n  /**\n   * Reports whether the buffer is empty.\n   * @returns true if the number of items in the buffer equals zero, and\n   *   false otherwise.\n   */\n  isEmpty() {\n    return this.length() === 0;\n  }\n\n  /**\n   * Adds an item to the end of the buffer.\n   */\n  push(value: T) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n    this.set(this.end, value);\n    this.end = this.wrap(this.end + 1);\n  }\n\n  /**\n   * Adds many items to the end of the buffer, in order.\n   */\n  pushAll(values: T[]) {\n    for (const value of values) {\n      this.push(value);\n    }\n  }\n\n  /**\n   * Removes and returns the last item in the buffer.\n   */\n  pop(): T {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    this.end = this.wrap(this.end - 1);\n    const result = this.get(this.end);\n    this.set(this.end, undefined);\n    return result;\n  }\n\n  /**\n   * Adds an item to the beginning of the buffer.\n   */\n  unshift(value: T) {\n    if (this.isFull()) {\n      throw new RangeError('Ring buffer is full.');\n    }\n    this.begin = this.wrap(this.begin - 1);\n    this.set(this.begin, value);\n  }\n\n  /**\n   * Removes and returns the first item in the buffer.\n   */\n  shift(): T {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    const result = this.get(this.begin);\n    this.set(this.begin, undefined);\n    this.begin = this.wrap(this.begin + 1);\n    return result;\n  }\n\n  /**\n   * Removes and returns a specific item in the buffer, and moves the last item\n   * to the vacated slot.  This is useful for implementing a shuffling stream.\n   * Note that this operation necessarily scrambles the original order.\n   *\n   * @param relativeIndex: the index of the item to remove, relative to the\n   *   first item in the buffer (e.g., hiding the ring nature of the underlying\n   *   storage).\n   */\n  shuffleExcise(relativeIndex: number): T {\n    if (this.isEmpty()) {\n      throw new RangeError('Ring buffer is empty.');\n    }\n    const index = this.wrap(this.begin + relativeIndex);\n    const result = this.get(index);\n    this.set(index, this.pop());\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}