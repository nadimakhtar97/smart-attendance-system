{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\n\nexport var ModelLoggingVerbosity;\n\n(function (ModelLoggingVerbosity) {\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n  ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\n\n\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\n\nexport class BaseCallback {\n  constructor() {\n    // TODO(michaelterry): This type is a best guess.\n    this.validationData = null;\n  }\n\n  setParams(params) {\n    this.params = params;\n  }\n\n  async onEpochBegin(epoch, logs) {}\n\n  async onEpochEnd(epoch, logs) {}\n\n  async onBatchBegin(batch, logs) {}\n\n  async onBatchEnd(batch, logs) {}\n\n  async onTrainBegin(logs) {}\n\n  async onTrainEnd(logs) {} // LayersModel needs to call Callback.setModel(), but cannot actually depend\n  // on Callback because that creates a cyclic dependency.  Providing this no-op\n  // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n  // BaseCallback but not on Callback.  The argument is typed as `Container`\n  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n  // overrides this method and enforces that the argument is really a\n  // LayersModel.\n\n\n  setModel(model) {// Do nothing. Use Callback instead of BaseCallback to track the model.\n  }\n\n}\n/**\n * Container abstracting a list of callbacks.\n */\n\nexport class CallbackList {\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  constructor(callbacks) {\n    let queueLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  append(callback) {\n    this.callbacks.push(callback);\n  }\n\n  setParams(params) {\n    for (const callback of this.callbacks) {\n      callback.setParams(params);\n    }\n  }\n\n  setModel(model) {\n    for (const callback of this.callbacks) {\n      callback.setModel(model);\n    }\n  }\n  /**\n   * Called at the start of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onEpochBegin(epoch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onEpochBegin(epoch, logs);\n    }\n  }\n  /**\n   * Called at the end of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onEpochEnd(epoch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onEpochEnd(epoch, logs);\n    }\n  }\n  /**\n   * Called  right before processing a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onBatchBegin(batch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onBatchBegin(batch, logs);\n    }\n  }\n  /**\n   * Called at the end of a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onBatchEnd(batch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onBatchEnd(batch, logs);\n    }\n  }\n  /**\n   * Called at the beginning of training.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onTrainBegin(logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onTrainBegin(logs);\n    }\n  }\n  /**\n   * Called at the end of training.\n   * @param logs Dictionary of logs.\n   */\n\n\n  async onTrainEnd(logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    for (const callback of this.callbacks) {\n      await callback.onTrainEnd(logs);\n    }\n  }\n\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\n\nexport class BaseLogger extends BaseCallback {\n  constructor() {\n    super();\n  }\n\n  async onEpochBegin(epoch) {\n    this.seen = 0;\n    this.totals = {};\n  }\n\n  async onBatchEnd(batch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    const batchSize = logs['size'] == null ? 0 : logs['size'];\n    this.seen += batchSize;\n\n    for (const key in logs) {\n      const value = logs[key];\n\n      if (typeof value === 'number') {\n        if (!this.totals.hasOwnProperty(key)) {\n          this.totals[key] = 0;\n        }\n\n        this.totals[key] = this.totals[key] + value * batchSize;\n      } else {\n        let oldTotalsToDispose;\n\n        if (key in this.totals) {\n          oldTotalsToDispose = this.totals[key];\n        } else {\n          this.totals[key] = 0;\n        }\n\n        const total = tidy(() => add(this.totals[key], mul(value, batchSize)));\n        this.totals[key] = total;\n\n        if (oldTotalsToDispose != null) {\n          oldTotalsToDispose.dispose();\n        }\n      }\n    }\n  }\n\n  async onEpochEnd(epoch, logs) {\n    if (logs != null) {\n      for (const key of this.params['metrics']) {\n        if (this.totals[key] == null) {\n          continue;\n        }\n\n        if (typeof this.totals[key] === 'number') {\n          logs[key] = this.totals[key] / this.seen;\n        } else {\n          tidy(() => {\n            const log = mul(div(1, this.seen), this.totals[key]);\n            logs[key] = log;\n            this.totals[key].dispose();\n            keep(logs[key]);\n          });\n        }\n      }\n    }\n  }\n\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\n\nexport class History extends BaseCallback {\n  async onTrainBegin(logs) {\n    this.epoch = [];\n    this.history = {};\n  }\n\n  async onEpochEnd(epoch, logs) {\n    if (logs == null) {\n      logs = {};\n    }\n\n    this.epoch.push(epoch);\n\n    for (const key in logs) {\n      if (this.history[key] == null) {\n        this.history[key] = [];\n      }\n\n      this.history[key].push(logs[key]);\n    }\n  }\n  /**\n   * Await the values of all losses and metrics.\n   */\n\n\n  async syncData() {\n    const promises = [];\n    const keys = [];\n    const indices = [];\n\n    for (const key in this.history) {\n      const valueArray = this.history[key];\n\n      for (let i = 0; i < valueArray.length; ++i) {\n        if (typeof valueArray[i] !== 'number') {\n          const valueScalar = valueArray[i];\n          promises.push(valueScalar.data());\n          keys.push(key);\n          indices.push(i);\n        }\n      }\n    }\n\n    const values = await Promise.all(promises);\n\n    for (let n = 0; n < values.length; ++n) {\n      const tensorToDispose = this.history[keys[n]][indices[n]];\n      tensorToDispose.dispose();\n      this.history[keys[n]][indices[n]] = values[n][0];\n    }\n  }\n\n}\n/**\n * Custom callback for training.\n */\n\nexport class CustomCallback extends BaseCallback {\n  constructor(args, yieldEvery) {\n    super();\n    this.currentEpoch = 0;\n    this.nowFunc = args.nowFunc;\n    this.nextFrameFunc = args.nextFrameFunc || nextFrame;\n    this.yieldEvery = yieldEvery || 'auto';\n\n    if (this.yieldEvery === 'auto') {\n      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n\n    if (this.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' + 'Either change `yieldEvery` or remove the callback');\n    }\n\n    if (util.isNumber(this.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc);\n    }\n\n    this.trainBegin = args.onTrainBegin;\n    this.trainEnd = args.onTrainEnd;\n    this.epochBegin = args.onEpochBegin;\n    this.epochEnd = args.onEpochEnd;\n    this.batchBegin = args.onBatchBegin;\n    this.batchEnd = args.onBatchEnd;\n    this.yield = args.onYield;\n  }\n\n  async maybeWait(epoch, batch, logs) {\n    const ps = [];\n\n    if (this.yield != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.yield(epoch, batch, logs));\n    }\n\n    ps.push(this.nextFrameFunc());\n    await Promise.all(ps);\n  }\n\n  async onEpochBegin(epoch, logs) {\n    this.currentEpoch = epoch;\n\n    if (this.epochBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.epochBegin(epoch, logs);\n    }\n  }\n\n  async onEpochEnd(epoch, logs) {\n    const ps = [];\n\n    if (this.epochEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.epochEnd(epoch, logs));\n    }\n\n    if (this.yieldEvery === 'epoch') {\n      ps.push(this.nextFrameFunc());\n    }\n\n    await Promise.all(ps);\n  }\n\n  async onBatchBegin(batch, logs) {\n    if (this.batchBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.batchBegin(batch, logs);\n    }\n  }\n\n  async onBatchEnd(batch, logs) {\n    const ps = [];\n\n    if (this.batchEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.batchEnd(batch, logs));\n    }\n\n    if (this.yieldEvery === 'batch') {\n      ps.push(this.nextFrameFunc());\n    } else if (util.isNumber(this.yieldEvery)) {\n      ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n    }\n\n    await Promise.all(ps);\n  }\n\n  async onTrainBegin(logs) {\n    if (this.trainBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainBegin(logs);\n    }\n  }\n\n  async onTrainEnd(logs) {\n    if (this.trainEnd != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainEnd(logs);\n    }\n  }\n\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\n\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n  if (callbacks == null) {\n    callbacks = {};\n  }\n\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks;\n  } // Convert custom callback configs to custom callback objects.\n\n\n  const callbackConfigs = generic_utils.toList(callbacks);\n  return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\n\nexport class CallbackConstructorRegistry {\n  /**\n   * Blocks public access to constructor.\n   */\n  constructor() {}\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n\n\n  static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n    util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` + `but got ${verbosityLevel}`);\n    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n\n    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n      CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n    }\n\n    CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n  }\n\n  static checkForDuplicate(callbackConstructor) {\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const constructors = CallbackConstructorRegistry.constructors[+levelName];\n      constructors.forEach(ctor => {\n        if (ctor === callbackConstructor) {\n          throw new ValueError('Duplicate callback constructor.');\n        }\n      });\n    }\n  }\n  /**\n   * Clear all registered callback constructors.\n   */\n\n\n  static clear() {\n    CallbackConstructorRegistry.constructors = {};\n  }\n  /**\n   * Create callbacks using the registered callback constructors.\n   *\n   * Given `verbosityLevel`, all constructors registered at that level or above\n   * will be called and the instantiated callbacks will be used.\n   *\n   * @param verbosityLevel: Level of verbosity.\n   */\n\n\n  static createCallbacks(verbosityLevel) {\n    const constructors = [];\n\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const level = +levelName;\n\n      if (verbosityLevel >= level) {\n        constructors.push(...CallbackConstructorRegistry.constructors[level]);\n      }\n    }\n\n    return constructors.map(ctor => new ctor());\n  }\n\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n  const history = new History();\n  const actualCallbacks = [new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)];\n\n  if (callbacks != null) {\n    actualCallbacks.push(...callbacks);\n  }\n\n  actualCallbacks.push(history);\n  const callbackList = new CallbackList(actualCallbacks); // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n\n  callbackList.setParams({\n    epochs,\n    initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize,\n    verbose,\n    doValidation,\n    metrics: callbackMetrics\n  });\n  return {\n    callbackList,\n    history\n  };\n}","map":{"version":3,"mappings":"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","names":["add","div","keep","mul","nextFrame","tidy","util","ValueError","resolveScalarsInLogs","generic_utils","ModelLoggingVerbosity","DEFAULT_YIELD_EVERY_MS","BaseCallback","constructor","setParams","params","onEpochBegin","epoch","logs","onEpochEnd","onBatchBegin","batch","onBatchEnd","onTrainBegin","onTrainEnd","setModel","model","CallbackList","callbacks","queueLength","append","callback","push","BaseLogger","seen","totals","batchSize","key","value","hasOwnProperty","oldTotalsToDispose","total","dispose","log","History","history","syncData","promises","keys","indices","valueArray","i","length","valueScalar","data","values","Promise","all","n","tensorToDispose","CustomCallback","args","yieldEvery","nowFunc","nextFrameFunc","onYield","Error","isNumber","maybeWait","debounce","bind","trainBegin","trainEnd","epochBegin","epochEnd","batchBegin","batchEnd","yield","ps","currentEpoch","standardizeCallbacks","Array","isArray","callbackConfigs","toList","map","callbackConfig","CallbackConstructorRegistry","registerCallbackConstructor","verbosityLevel","callbackConstructor","assert","Number","isInteger","checkForDuplicate","constructors","levelName","forEach","ctor","clear","createCallbacks","level","configureCallbacks","verbose","epochs","initialEpoch","numTrainSamples","stepsPerEpoch","doValidation","callbackMetrics","actualCallbacks","callbackList","samples","steps","metrics"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-layers/src/base_callbacks.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/* Original source: keras/callbacks.py */\n\nimport {add, div, keep, mul, nextFrame, Scalar, Tensor, tidy, util} from '@tensorflow/tfjs-core';\n\nimport {Container} from './engine/container';\nimport {ValueError} from './errors';\nimport {Logs, resolveScalarsInLogs, UnresolvedLogs} from './logs';\nimport * as generic_utils from './utils/generic_utils';\n\n/** Verbosity logging level when fitting a model. */\nexport enum ModelLoggingVerbosity {\n  SILENT = 0,\n  VERBOSE = 1\n}\n\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n\nexport type Params = {\n  [key: string]: number|string|boolean|number[]|string[]|boolean[];\n};\n\nexport type YieldEveryOptions = 'auto'|'batch'|'epoch'|'never'|number;\n\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport abstract class BaseCallback {\n  // TODO(michaelterry): This type is a best guess.\n  validationData: Tensor|Tensor[] = null;\n  /**\n   * Training parameters (eg. verbosity, batch size, number of epochs...).\n   */\n  params: Params;\n\n  setParams(params: Params): void {\n    this.params = params;\n  }\n\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs) {}\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {}\n\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs) {}\n\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {}\n\n  async onTrainBegin(logs?: UnresolvedLogs) {}\n\n  async onTrainEnd(logs?: UnresolvedLogs) {}\n\n  // LayersModel needs to call Callback.setModel(), but cannot actually depend\n  // on Callback because that creates a cyclic dependency.  Providing this no-op\n  // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n  // BaseCallback but not on Callback.  The argument is typed as `Container`\n  // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n  // overrides this method and enforces that the argument is really a\n  // LayersModel.\n  setModel(model: Container): void {\n    // Do nothing. Use Callback instead of BaseCallback to track the model.\n  }\n}\n\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n  callbacks: BaseCallback[];\n  queueLength: number;\n\n  // TODO(cais): When the need arises, uncomment the following lines and\n  // implement the queue for time values.\n  // private deltaTBatch: number;\n  // private deltaTsBatchBegin: Array<number>;\n  // private deltaTsBatchEnd: Array<number>;\n\n  /**\n   * Constructor of CallbackList.\n   * @param callbacks Array of `Callback` instances.\n   * @param queueLength Queue length for keeping running statistics over\n   *   callback execution time.\n   */\n  constructor(callbacks?: BaseCallback[], queueLength = 10) {\n    // TODO(cais): Make use of queueLength when implementing the queue for time\n    // values.\n    if (callbacks == null) {\n      callbacks = [];\n    }\n    this.callbacks = callbacks;\n    this.queueLength = queueLength;\n  }\n\n  append(callback: BaseCallback): void {\n    this.callbacks.push(callback);\n  }\n\n  setParams(params: Params): void {\n    for (const callback of this.callbacks) {\n      callback.setParams(params);\n    }\n  }\n\n  setModel(model: Container): void {\n    for (const callback of this.callbacks) {\n      callback.setModel(model);\n    }\n  }\n\n  /**\n   * Called at the start of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochBegin(epoch, logs);\n    }\n  }\n\n  /**\n   * Called at the end of an epoch.\n   * @param epoch Index of epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onEpochEnd(epoch, logs);\n    }\n  }\n\n  /**\n   * Called  right before processing a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchBegin(batch, logs);\n    }\n  }\n\n  /**\n   * Called at the end of a batch.\n   * @param batch Index of batch within the current epoch.\n   * @param logs Dictionary of logs.\n   */\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onBatchEnd(batch, logs);\n    }\n  }\n\n  /**\n   * Called at the beginning of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainBegin(logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainBegin(logs);\n    }\n  }\n\n  /**\n   * Called at the end of training.\n   * @param logs Dictionary of logs.\n   */\n  async onTrainEnd(logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    for (const callback of this.callbacks) {\n      await callback.onTrainEnd(logs);\n    }\n  }\n}\n\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n  private seen: number;\n  private totals: UnresolvedLogs;\n\n  constructor() {\n    super();\n  }\n\n  async onEpochBegin(epoch: number) {\n    this.seen = 0;\n    this.totals = {};\n  }\n\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    const batchSize = logs['size'] == null ? 0 : logs['size'] as number;\n    this.seen += batchSize;\n    for (const key in logs) {\n      const value = logs[key];\n      if (typeof value === 'number') {\n        if (!this.totals.hasOwnProperty(key)) {\n          this.totals[key] = 0;\n        }\n        this.totals[key] = this.totals[key] as number + value * batchSize;\n      } else {\n        let oldTotalsToDispose: Scalar;\n        if (key in this.totals) {\n          oldTotalsToDispose = this.totals[key] as Scalar;\n        } else {\n          this.totals[key] = 0;\n        }\n        const total: Scalar =\n            tidy(() => add((this.totals[key]), mul(value, batchSize)));\n        this.totals[key] = total;\n        if (oldTotalsToDispose != null) {\n          oldTotalsToDispose.dispose();\n        }\n      }\n    }\n  }\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs != null) {\n      for (const key of this.params['metrics'] as string[]) {\n        if (this.totals[key] == null) {\n          continue;\n        }\n        if (typeof this.totals[key] === 'number') {\n          logs[key] = this.totals[key] as number / this.seen;\n        } else {\n          tidy(() => {\n            const log: Scalar = mul(div(1, this.seen), this.totals[key]);\n            logs[key] = log;\n            (this.totals[key] as Tensor).dispose();\n            keep(logs[key] as Scalar);\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n  epoch: number[];\n  history: {[key: string]: Array<number|Tensor>};\n\n  async onTrainBegin(logs?: UnresolvedLogs) {\n    this.epoch = [];\n    this.history = {};\n  }\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs) {\n    if (logs == null) {\n      logs = {};\n    }\n    this.epoch.push(epoch);\n    for (const key in logs) {\n      if (this.history[key] == null) {\n        this.history[key] = [];\n      }\n      this.history[key].push(logs[key]);\n    }\n  }\n\n  /**\n   * Await the values of all losses and metrics.\n   */\n  async syncData() {\n    const promises: Array<Promise<Float32Array|Int32Array|Uint8Array>> = [];\n    const keys: string[] = [];\n    const indices: number[] = [];\n    for (const key in this.history) {\n      const valueArray = this.history[key];\n      for (let i = 0; i < valueArray.length; ++i) {\n        if (typeof valueArray[i] !== 'number') {\n          const valueScalar = valueArray[i] as Tensor;\n          promises.push(valueScalar.data());\n          keys.push(key);\n          indices.push(i);\n        }\n      }\n    }\n    const values = await Promise.all(promises);\n    for (let n = 0; n < values.length; ++n) {\n      const tensorToDispose = this.history[keys[n]][indices[n]] as Tensor;\n      tensorToDispose.dispose();\n      this.history[keys[n]][indices[n]] = values[n][0];\n    }\n  }\n}\n\nexport interface CustomCallbackArgs {\n  onTrainBegin?: (logs?: Logs) => void | Promise<void>;\n  onTrainEnd?: (logs?: Logs) => void | Promise<void>;\n  onEpochBegin?: (epoch: number, logs?: Logs) => void | Promise<void>;\n  onEpochEnd?: (epoch: number, logs?: Logs) => void | Promise<void>;\n  onBatchBegin?: (batch: number, logs?: Logs) => void | Promise<void>;\n  onBatchEnd?: (batch: number, logs?: Logs) => void | Promise<void>;\n  onYield?: (epoch: number, batch: number, logs: Logs) => void | Promise<void>;\n  // Used for test DI mocking.\n  nowFunc?: Function;\n  nextFrameFunc?: Function;\n}\n\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n  protected readonly trainBegin: (logs?: Logs) => void | Promise<void>;\n  protected readonly trainEnd: (logs?: Logs) => void | Promise<void>;\n  protected readonly epochBegin:\n      (epoch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly epochEnd:\n      (epoch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly batchBegin:\n      (batch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly batchEnd:\n      (batch: number, logs?: Logs) => void | Promise<void>;\n  protected readonly yield:\n      (epoch: number, batch: number, logs: Logs) => void | Promise<void>;\n\n  private yieldEvery: YieldEveryOptions;\n  private currentEpoch = 0;\n  public nowFunc: Function;\n  public nextFrameFunc: Function;\n\n  constructor(args: CustomCallbackArgs, yieldEvery?: YieldEveryOptions) {\n    super();\n    this.nowFunc = args.nowFunc;\n    this.nextFrameFunc = args.nextFrameFunc || nextFrame;\n    this.yieldEvery = yieldEvery || 'auto';\n    if (this.yieldEvery === 'auto') {\n      this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n    }\n    if (this.yieldEvery === 'never' && args.onYield != null) {\n      throw new Error(\n          'yieldEvery is `never` but you provided an `onYield` callback. ' +\n          'Either change `yieldEvery` or remove the callback');\n    }\n    if (util.isNumber(this.yieldEvery)) {\n      // Decorate `maybeWait` so it will be called at most once every\n      // `yieldEvery` ms.\n      this.maybeWait = generic_utils.debounce(\n          this.maybeWait.bind(this), this.yieldEvery as number, this.nowFunc);\n    }\n    this.trainBegin = args.onTrainBegin;\n    this.trainEnd = args.onTrainEnd;\n    this.epochBegin = args.onEpochBegin;\n    this.epochEnd = args.onEpochEnd;\n    this.batchBegin = args.onBatchBegin;\n    this.batchEnd = args.onBatchEnd;\n    this.yield = args.onYield;\n  }\n\n  async maybeWait(epoch: number, batch: number, logs: UnresolvedLogs) {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.yield != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.yield(epoch, batch, logs as Logs));\n    }\n    ps.push(this.nextFrameFunc());\n    await Promise.all(ps);\n  }\n\n  async onEpochBegin(epoch: number, logs?: UnresolvedLogs): Promise<void> {\n    this.currentEpoch = epoch;\n    if (this.epochBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.epochBegin(epoch, logs as Logs);\n    }\n  }\n\n  async onEpochEnd(epoch: number, logs?: UnresolvedLogs): Promise<void> {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.epochEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.epochEnd(epoch, logs as Logs));\n    }\n    if (this.yieldEvery === 'epoch') {\n      ps.push(this.nextFrameFunc());\n    }\n    await Promise.all(ps);\n  }\n\n  async onBatchBegin(batch: number, logs?: UnresolvedLogs): Promise<void> {\n    if (this.batchBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.batchBegin(batch, logs as Logs);\n    }\n  }\n\n  async onBatchEnd(batch: number, logs?: UnresolvedLogs): Promise<void> {\n    const ps: Array<void|Promise<void>> = [];\n    if (this.batchEnd != null) {\n      await resolveScalarsInLogs(logs);\n      ps.push(this.batchEnd(batch, logs as Logs));\n    }\n    if (this.yieldEvery === 'batch') {\n      ps.push(this.nextFrameFunc());\n    } else if (util.isNumber(this.yieldEvery)) {\n      ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n    }\n    await Promise.all(ps);\n  }\n\n  async onTrainBegin(logs?: UnresolvedLogs): Promise<void> {\n    if (this.trainBegin != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainBegin(logs as Logs);\n    }\n  }\n\n  async onTrainEnd(logs?: UnresolvedLogs): Promise<void> {\n    if (this.trainEnd != null) {\n      await resolveScalarsInLogs(logs);\n      await this.trainEnd(logs as Logs);\n    }\n  }\n}\n\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(\n    callbacks: BaseCallback|BaseCallback[]|CustomCallbackArgs|\n    CustomCallbackArgs[],\n    yieldEvery: YieldEveryOptions): BaseCallback[] {\n  if (callbacks == null) {\n    callbacks = {} as BaseCallback;\n  }\n  if (callbacks instanceof BaseCallback) {\n    return [callbacks];\n  }\n  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n    return callbacks as BaseCallback[];\n  }\n  // Convert custom callback configs to custom callback objects.\n  const callbackConfigs =\n      generic_utils.toList(callbacks) as CustomCallbackArgs[];\n  return callbackConfigs.map(\n      callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n\nexport declare type BaseCallbackConstructor = {\n  new (): BaseCallback\n};\n\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n  private static constructors:\n      {[verbosityLevel: number]: BaseCallbackConstructor[]} = {};\n\n  /**\n   * Blocks public access to constructor.\n   */\n  private constructor() {}\n\n  /**\n   * Register a tf.LayersModel.fit() callback constructor.\n   *\n   * The registered callback constructor will be used to instantiate\n   * callbacks for every tf.LayersModel.fit() call afterwards.\n   *\n   * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n   *   is to be reigstered.\n   * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n   * @throws Error, if the same callbackConstructor has been registered before,\n   *   either at the same or a different `verbosityLevel`.\n   */\n  static registerCallbackConstructor(\n      verbosityLevel: number, callbackConstructor: BaseCallbackConstructor) {\n    util.assert(\n        verbosityLevel >= 0 && Number.isInteger(verbosityLevel),\n        () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n      CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n    }\n    CallbackConstructorRegistry.constructors[verbosityLevel].push(\n        callbackConstructor);\n  }\n\n  private static checkForDuplicate(callbackConstructor:\n                                       BaseCallbackConstructor) {\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const constructors = CallbackConstructorRegistry.constructors[+levelName];\n      constructors.forEach(ctor => {\n        if (ctor === callbackConstructor) {\n          throw new ValueError('Duplicate callback constructor.');\n        }\n      });\n    }\n  }\n\n  /**\n   * Clear all registered callback constructors.\n   */\n  protected static clear() {\n    CallbackConstructorRegistry.constructors = {};\n  }\n\n  /**\n   * Create callbacks using the registered callback constructors.\n   *\n   * Given `verbosityLevel`, all constructors registered at that level or above\n   * will be called and the instantiated callbacks will be used.\n   *\n   * @param verbosityLevel: Level of verbosity.\n   */\n  static createCallbacks(verbosityLevel: number): BaseCallback[] {\n    const constructors: BaseCallbackConstructor[] = [];\n    for (const levelName in CallbackConstructorRegistry.constructors) {\n      const level = +levelName;\n      if (verbosityLevel >= level) {\n        constructors.push(...CallbackConstructorRegistry.constructors[level]);\n      }\n    }\n    return constructors.map(ctor => new ctor());\n  }\n}\n\nexport function configureCallbacks(\n    callbacks: BaseCallback[], verbose: ModelLoggingVerbosity, epochs: number,\n    initialEpoch: number, numTrainSamples: number, stepsPerEpoch: number,\n    batchSize: number, doValidation: boolean,\n    callbackMetrics: string[]): {callbackList: CallbackList, history: History} {\n  const history = new History();\n  const actualCallbacks: BaseCallback[] = [\n    new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n  ];\n  if (callbacks != null) {\n    actualCallbacks.push(...callbacks);\n  }\n  actualCallbacks.push(history);\n  const callbackList = new CallbackList(actualCallbacks);\n\n  // TODO(cais): Figure out when this LayersModel instance can have a\n  // dynamically\n  //   set property called 'callback_model' as in PyKeras.\n\n  callbackList.setParams({\n    epochs,\n    initialEpoch,\n    samples: numTrainSamples,\n    steps: stepsPerEpoch,\n    batchSize,\n    verbose,\n    doValidation,\n    metrics: callbackMetrics,\n  });\n  return {callbackList, history};\n}\n"]},"metadata":{},"sourceType":"module"}