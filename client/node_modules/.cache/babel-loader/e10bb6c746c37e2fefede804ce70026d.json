{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(real, imag) {\n  if (real.length !== imag.length) {\n    throw new Error(`Cannot merge real and imag arrays of different lengths. real:` + `${real.length}, imag: ${imag.length}.`);\n  }\n\n  const result = new Float32Array(real.length * 2);\n\n  for (let i = 0; i < result.length; i += 2) {\n    result[i] = real[i / 2];\n    result[i + 1] = imag[i / 2];\n  }\n\n  return result;\n}\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\n\nexport function splitRealAndImagArrays(complex) {\n  const real = new Float32Array(complex.length / 2);\n  const imag = new Float32Array(complex.length / 2);\n\n  for (let i = 0; i < complex.length; i += 2) {\n    real[i / 2] = complex[i];\n    imag[i / 2] = complex[i + 1];\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\n\nexport function complexWithEvenIndex(complex) {\n  const len = Math.ceil(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n\n  for (let i = 0; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\n\nexport function complexWithOddIndex(complex) {\n  const len = Math.floor(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n\n  for (let i = 2; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\n\nexport function getComplexWithIndex(complex, index) {\n  const real = complex[index * 2];\n  const imag = complex[index * 2 + 1];\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\n\nexport function assignToTypedArray(data, real, imag, index) {\n  data[index * 2] = real;\n  data[index * 2 + 1] = imag;\n}\n/**\n * Make the list of exponent terms used by FFT.\n */\n\nexport function exponents(n, inverse) {\n  const real = new Float32Array(n / 2);\n  const imag = new Float32Array(n / 2);\n\n  for (let i = 0; i < Math.ceil(n / 2); i++) {\n    const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n    real[i] = Math.cos(x);\n    imag[i] = Math.sin(x);\n  }\n\n  return {\n    real,\n    imag\n  };\n}\n/**\n * Make the exponent term used by FFT.\n */\n\nexport function exponent(k, n, inverse) {\n  const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n  const real = Math.cos(x);\n  const imag = Math.sin(x);\n  return {\n    real,\n    imag\n  };\n}","map":{"version":3,"mappings":"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","names":["mergeRealAndImagArrays","real","imag","length","Error","result","Float32Array","i","splitRealAndImagArrays","complex","complexWithEvenIndex","len","Math","ceil","floor","complexWithOddIndex","getComplexWithIndex","index","assignToTypedArray","data","exponents","n","inverse","x","PI","cos","sin","exponent","k"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/backends/complex_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray} from '../types';\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(\n    real: Float32Array, imag: Float32Array): Float32Array {\n  if (real.length !== imag.length) {\n    throw new Error(\n        `Cannot merge real and imag arrays of different lengths. real:` +\n        `${real.length}, imag: ${imag.length}.`);\n  }\n  const result = new Float32Array(real.length * 2);\n  for (let i = 0; i < result.length; i += 2) {\n    result[i] = real[i / 2];\n    result[i + 1] = imag[i / 2];\n  }\n  return result;\n}\n\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\nexport function splitRealAndImagArrays(complex: Float32Array):\n    {real: Float32Array, imag: Float32Array} {\n  const real = new Float32Array(complex.length / 2);\n  const imag = new Float32Array(complex.length / 2);\n  for (let i = 0; i < complex.length; i += 2) {\n    real[i / 2] = complex[i];\n    imag[i / 2] = complex[i + 1];\n  }\n  return {real, imag};\n}\n\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithEvenIndex(complex: Float32Array):\n    {real: Float32Array, imag: Float32Array} {\n  const len = Math.ceil(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n  for (let i = 0; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n  return {real, imag};\n}\n\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithOddIndex(complex: Float32Array):\n    {real: Float32Array, imag: Float32Array} {\n  const len = Math.floor(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n  for (let i = 2; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n  return {real, imag};\n}\n\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\nexport function getComplexWithIndex(\n    complex: Float32Array, index: number): {real: number, imag: number} {\n  const real = complex[index * 2];\n  const imag = complex[index * 2 + 1];\n  return {real, imag};\n}\n\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\nexport function assignToTypedArray(\n    data: TypedArray, real: number, imag: number, index: number) {\n  data[index * 2] = real;\n  data[index * 2 + 1] = imag;\n}\n\n/**\n * Make the list of exponent terms used by FFT.\n */\nexport function exponents(\n    n: number, inverse: boolean): {real: Float32Array, imag: Float32Array} {\n  const real = new Float32Array(n / 2);\n  const imag = new Float32Array(n / 2);\n  for (let i = 0; i < Math.ceil(n / 2); i++) {\n    const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n    real[i] = Math.cos(x);\n    imag[i] = Math.sin(x);\n  }\n  return {real, imag};\n}\n\n/**\n * Make the exponent term used by FFT.\n */\nexport function exponent(\n    k: number, n: number, inverse: boolean): {real: number, imag: number} {\n  const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n  const real = Math.cos(x);\n  const imag = Math.sin(x);\n  return {real, imag};\n}\n"]},"metadata":{},"sourceType":"module"}