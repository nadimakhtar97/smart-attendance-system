{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Built-in metrics.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { tidy } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { NotImplementedError, ValueError } from './errors';\nimport { categoricalCrossentropy as categoricalCrossentropyLoss, cosineProximity, meanAbsoluteError, meanAbsolutePercentageError, meanSquaredError, sparseCategoricalCrossentropy as sparseCategoricalCrossentropyLoss } from './losses';\nimport { binaryCrossentropy as lossBinaryCrossentropy } from './losses';\nimport { lossesMap } from './losses';\nimport * as util from './utils/generic_utils';\nexport function binaryAccuracy(yTrue, yPred) {\n  return tidy(() => {\n    const threshold = tfc.mul(.5, tfc.onesLike(yPred));\n    const yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);\n    return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1);\n  });\n}\nexport function categoricalAccuracy(yTrue, yPred) {\n  return tidy(() => K.cast(tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), 'float32'));\n}\n\nfunction truePositives(yTrue, yPred) {\n  return tidy(() => {\n    return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 1))), 'float32');\n  });\n}\n\nfunction falseNegatives(yTrue, yPred) {\n  return tidy(() => {\n    return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 0))), 'float32');\n  });\n}\n\nfunction falsePositives(yTrue, yPred) {\n  return tidy(() => {\n    return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 0), tfc.equal(yPred, 1))), 'float32');\n  });\n}\n\nexport function precision(yTrue, yPred) {\n  return tidy(() => {\n    const tp = truePositives(yTrue, yPred);\n    const fp = falsePositives(yTrue, yPred);\n    const denominator = tfc.add(tp, fp);\n    return tfc.cast(tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0), 'float32');\n  });\n}\nexport function recall(yTrue, yPred) {\n  return tidy(() => {\n    const tp = truePositives(yTrue, yPred);\n    const fn = falseNegatives(yTrue, yPred);\n    const denominator = tfc.add(tp, fn);\n    return tfc.cast(tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0), 'float32');\n  });\n}\nexport function binaryCrossentropy(yTrue, yPred) {\n  return lossBinaryCrossentropy(yTrue, yPred);\n}\nexport function sparseCategoricalAccuracy(yTrue, yPred) {\n  if (yTrue.rank === yPred.rank) {\n    yTrue = tfc.squeeze(yTrue, [yTrue.rank - 1]);\n  }\n\n  yPred = tfc.argMax(yPred, -1);\n\n  if (yPred.dtype !== yTrue.dtype) {\n    yPred = tfc.cast(yPred, yTrue.dtype);\n  }\n\n  return tfc.cast(tfc.equal(yTrue, yPred), 'float32');\n}\nexport function topKCategoricalAccuracy(yTrue, yPred) {\n  throw new NotImplementedError();\n}\nexport function sparseTopKCategoricalAccuracy(yTrue, yPred) {\n  throw new NotImplementedError();\n} // Aliases.\n\nexport const mse = meanSquaredError;\nexport const MSE = meanSquaredError;\nexport const mae = meanAbsoluteError;\nexport const MAE = meanAbsoluteError;\nexport const mape = meanAbsolutePercentageError;\nexport const MAPE = meanAbsolutePercentageError;\nexport const categoricalCrossentropy = categoricalCrossentropyLoss;\nexport const cosine = cosineProximity;\nexport const sparseCategoricalCrossentropy = sparseCategoricalCrossentropyLoss; // TODO(cais, nielsene): Add serialize().\n\nexport const metricsMap = {\n  binaryAccuracy,\n  categoricalAccuracy,\n  precision,\n  categoricalCrossentropy,\n  sparseCategoricalCrossentropy,\n  mse,\n  MSE,\n  mae,\n  MAE,\n  mape,\n  MAPE,\n  cosine\n};\nexport function get(identifier) {\n  if (typeof identifier === 'string' && identifier in metricsMap) {\n    return metricsMap[identifier];\n  } else if (typeof identifier !== 'string' && identifier != null) {\n    return identifier;\n  } else {\n    throw new ValueError(`Unknown metric ${identifier}`);\n  }\n}\n/**\n * Get the shortcut function name.\n *\n * If the fn name is a string,\n *   directly return the string name.\n * If the function is included in metricsMap or lossesMap,\n *   return key of the map.\n *   - If the function relative to multiple keys,\n *     return the first found key as the function name.\n *   - If the function exists in both lossesMap and metricsMap,\n *     search lossesMap first.\n * If the function is not included in metricsMap or lossesMap,\n *   return the function name.\n *\n * @param fn loss function, metric function, or short cut name.\n * @returns Loss or Metric name in string.\n */\n\nexport function getLossOrMetricName(fn) {\n  util.assert(fn !== null, `Unknown LossOrMetricFn ${fn}`);\n\n  if (typeof fn === 'string') {\n    return fn;\n  } else {\n    let fnName;\n\n    for (const key of Object.keys(lossesMap)) {\n      if (lossesMap[key] === fn) {\n        fnName = key;\n        break;\n      }\n    }\n\n    if (fnName !== undefined) {\n      return fnName;\n    }\n\n    for (const key of Object.keys(metricsMap)) {\n      if (metricsMap[key] === fn) {\n        fnName = key;\n        break;\n      }\n    }\n\n    if (fnName !== undefined) {\n      return fnName;\n    }\n\n    return fn.name;\n  }\n}","map":{"version":3,"mappings":"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","names":["tfc","tidy","K","NotImplementedError","ValueError","categoricalCrossentropy","categoricalCrossentropyLoss","cosineProximity","meanAbsoluteError","meanAbsolutePercentageError","meanSquaredError","sparseCategoricalCrossentropy","sparseCategoricalCrossentropyLoss","binaryCrossentropy","lossBinaryCrossentropy","lossesMap","util","binaryAccuracy","yTrue","yPred","threshold","mul","onesLike","yPredThresholded","cast","greater","dtype","mean","equal","categoricalAccuracy","argMax","truePositives","sum","logicalAnd","falseNegatives","falsePositives","precision","tp","fp","denominator","add","where","div","recall","fn","sparseCategoricalAccuracy","rank","squeeze","topKCategoricalAccuracy","sparseTopKCategoricalAccuracy","mse","MSE","mae","MAE","mape","MAPE","cosine","metricsMap","get","identifier","getLossOrMetricName","assert","fnName","key","Object","keys","undefined","name"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-layers/src/metrics.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Built-in metrics.\n */\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {Tensor, tidy} from '@tensorflow/tfjs-core';\n\nimport * as K from './backend/tfjs_backend';\nimport {NotImplementedError, ValueError} from './errors';\nimport {categoricalCrossentropy as categoricalCrossentropyLoss, cosineProximity, meanAbsoluteError, meanAbsolutePercentageError, meanSquaredError, sparseCategoricalCrossentropy as sparseCategoricalCrossentropyLoss} from './losses';\nimport {binaryCrossentropy as lossBinaryCrossentropy} from './losses';\nimport {lossesMap} from './losses';\nimport {LossOrMetricFn} from './types';\nimport * as util from './utils/generic_utils';\n\nexport function binaryAccuracy(yTrue: Tensor, yPred: Tensor): Tensor {\n  return tidy(() => {\n    const threshold = tfc.mul(.5, tfc.onesLike(yPred));\n    const yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);\n    return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1);\n  });\n}\n\nexport function categoricalAccuracy(yTrue: Tensor, yPred: Tensor): Tensor {\n  return tidy(\n      () => K.cast(\n          tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), 'float32'));\n}\n\nfunction truePositives(yTrue: Tensor, yPred: Tensor): Tensor {\n  return tidy(() => {\n    return tfc.cast(\n        tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 1))),\n        'float32');\n  });\n}\n\nfunction falseNegatives(yTrue: Tensor, yPred: Tensor): Tensor {\n  return tidy(() => {\n    return tfc.cast(\n        tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 0))),\n        'float32');\n  });\n}\n\nfunction falsePositives(yTrue: Tensor, yPred: Tensor): Tensor {\n  return tidy(() => {\n    return tfc.cast(\n        tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 0), tfc.equal(yPred, 1))),\n        'float32');\n  });\n}\n\nexport function precision(yTrue: Tensor, yPred: Tensor): Tensor {\n  return tidy(() => {\n    const tp = truePositives(yTrue, yPred);\n    const fp = falsePositives(yTrue, yPred);\n\n    const denominator = tfc.add(tp, fp);\n\n    return tfc.cast(\n        tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0),\n        'float32');\n  });\n}\n\nexport function recall(yTrue: Tensor, yPred: Tensor): Tensor {\n  return tidy(() => {\n    const tp = truePositives(yTrue, yPred);\n    const fn = falseNegatives(yTrue, yPred);\n\n    const denominator = tfc.add(tp, fn);\n\n    return tfc.cast(\n        tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0),\n        'float32');\n  });\n}\n\nexport function binaryCrossentropy(yTrue: Tensor, yPred: Tensor): Tensor {\n  return lossBinaryCrossentropy(yTrue, yPred);\n}\n\nexport function sparseCategoricalAccuracy(\n    yTrue: Tensor, yPred: Tensor): Tensor {\n  if (yTrue.rank === yPred.rank) {\n    yTrue = tfc.squeeze(yTrue, [yTrue.rank - 1]);\n  }\n  yPred = tfc.argMax(yPred, -1);\n  if (yPred.dtype !== yTrue.dtype) {\n    yPred = tfc.cast(yPred, yTrue.dtype);\n  }\n  return tfc.cast(tfc.equal(yTrue, yPred), 'float32');\n}\n\nexport function topKCategoricalAccuracy(yTrue: Tensor, yPred: Tensor): Tensor {\n  throw new NotImplementedError();\n}\n\nexport function sparseTopKCategoricalAccuracy(\n    yTrue: Tensor, yPred: Tensor): Tensor {\n  throw new NotImplementedError();\n}\n\n// Aliases.\nexport const mse = meanSquaredError;\nexport const MSE = meanSquaredError;\nexport const mae = meanAbsoluteError;\nexport const MAE = meanAbsoluteError;\nexport const mape = meanAbsolutePercentageError;\nexport const MAPE = meanAbsolutePercentageError;\nexport const categoricalCrossentropy = categoricalCrossentropyLoss;\nexport const cosine = cosineProximity;\nexport const sparseCategoricalCrossentropy = sparseCategoricalCrossentropyLoss;\n\n// TODO(cais, nielsene): Add serialize().\n\nexport const metricsMap: {[functionName: string]: LossOrMetricFn} = {\n  binaryAccuracy,\n  categoricalAccuracy,\n  precision,\n  categoricalCrossentropy,\n  sparseCategoricalCrossentropy,\n  mse,\n  MSE,\n  mae,\n  MAE,\n  mape,\n  MAPE,\n  cosine\n};\n\nexport function get(identifier: string|LossOrMetricFn): LossOrMetricFn {\n  if (typeof identifier === 'string' && identifier in metricsMap) {\n    return metricsMap[identifier];\n  } else if (typeof identifier !== 'string' && identifier != null) {\n    return identifier;\n  } else {\n    throw new ValueError(`Unknown metric ${identifier}`);\n  }\n}\n\n/**\n * Get the shortcut function name.\n *\n * If the fn name is a string,\n *   directly return the string name.\n * If the function is included in metricsMap or lossesMap,\n *   return key of the map.\n *   - If the function relative to multiple keys,\n *     return the first found key as the function name.\n *   - If the function exists in both lossesMap and metricsMap,\n *     search lossesMap first.\n * If the function is not included in metricsMap or lossesMap,\n *   return the function name.\n *\n * @param fn loss function, metric function, or short cut name.\n * @returns Loss or Metric name in string.\n */\nexport function getLossOrMetricName(fn: string|LossOrMetricFn): string {\n  util.assert(fn !== null, `Unknown LossOrMetricFn ${fn}`);\n  if (typeof fn === 'string') {\n    return fn;\n  } else {\n    let fnName;\n    for (const key of Object.keys(lossesMap)) {\n      if (lossesMap[key] === fn) {\n        fnName = key;\n        break;\n      }\n    }\n    if (fnName !== undefined) {\n      return fnName;\n    }\n    for (const key of Object.keys(metricsMap)) {\n      if (metricsMap[key] === fn) {\n        fnName = key;\n        break;\n      }\n    }\n    if (fnName !== undefined) {\n      return fnName;\n    }\n    return (fn as Function).name;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}