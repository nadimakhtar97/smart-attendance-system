{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n  const returnValue = func();\n\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n\n  return returnValue;\n}\n\nfunction checkWebGLError(gl) {\n  const error = gl.getError();\n\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n} // https://en.wikipedia.org/wiki/Half-precision_floating-point_format\n\n\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {\n    return true;\n  }\n\n  return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n  return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n  const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n\n  return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n  const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n\n  return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\n\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n\n  const lineNumber = +lineNumberRegexResult[1];\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(`%c ${util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\n\nexport function createProgram(gl) {\n  return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\nexport function validateProgram(gl, program) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\nexport function createStaticVertexBuffer(gl, data) {\n  const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n  const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\nexport function getNumChannels() {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n\n  return 4;\n}\nexport function createTexture(gl) {\n  return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n\n  if (width <= 0 || height <= 0) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n\n  if (width > maxTextureSize || height > maxTextureSize) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error('Requested texture size ' + requested + ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\nexport function createFramebuffer(gl) {\n  return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n  const loc = gl.getAttribLocation(program, attribute);\n\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n  return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n  return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n\n    default:\n      return `unknown error ${status}`;\n  }\n}\n\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n  const tOrNull = callAndCheck(gl, () => returnTOrNull());\n\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl, textureUnit) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\n\nexport function getBatchDim(shape) {\n  let dimsToSkip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\nexport function getShapeAs3D(shape) {\n  let shapeAs3D = [1, 1, 1];\n  const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;\n\n  if (!isScalar) {\n    shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];\n  }\n\n  return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape) {\n  let isPacked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2; // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n\n    logShape = logShape.map((d, i) => i >= logShape.length - 2 ? util.nearestLargerEven(logShape[i]) : logShape[i]); // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  } // If logical shape is 2, we don't squeeze, since we want to match physical.\n\n\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  let size = util.sizeFromShape(logShape);\n\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    return [1, size];\n  } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {\n    return logShape;\n  } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {\n    return [logShape[0] * logShape[1], logShape[2]];\n  } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2]];\n  } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {\n    return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  } else {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n      const batchDim = getBatchDim(logShape);\n      let rows = 2,\n          cols = 2;\n\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n\n      size = batchDim * (rows / 2) * (cols / 2);\n      return util.sizeToSquarishShape(size).map(d => d * 2);\n    }\n\n    return util.sizeToSquarishShape(size);\n  }\n}\n\nfunction isEven(n) {\n  return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\n\n\nexport function isReshapeFree(shape1, shape2) {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {\n    // One of the shapes is a scalar.\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {\n    // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n} // We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\n\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n\n  return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  } // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n\n\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  let queryTimerVersion;\n  const gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') && webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n\n  return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n\n  return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\n\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n  const texConfig = getTextureConfig(gl);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer( // tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion); // tslint:disable-next-line:no-any\n\n  const isEnabled = gl.fenceSync != null;\n  return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` + 'in the WebGL backend.');\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["env","util","getWebGLContext","getTextureConfig","callAndCheck","gl","func","returnValue","getBool","checkWebGLError","error","getError","NO_ERROR","Error","getWebGLErrorMessage","MIN_FLOAT16","MAX_FLOAT16","canBeRepresented","num","Math","abs","status","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","getExtensionOrThrow","extensionName","throwIfNull","getExtension","createVertexShader","vertexShaderSource","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","createFragmentShader","fragmentShaderSource","fragmentShader","FRAGMENT_SHADER","logShaderSourceAndInfoLog","lineNumberRegex","shaderInfoLog","lineNumberRegexResult","exec","lineNumber","shaderLines","split","pad","length","toString","linesWithLineNumbers","map","line","rightPad","maxLineLength","i","max","beforeErrorLines","slice","errorLine","afterErrorLines","join","createProgram","linkProgram","program","getProgramParameter","LINK_STATUS","getProgramInfoLog","validateProgram","VALIDATE_STATUS","createStaticVertexBuffer","data","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","createStaticIndexBuffer","ELEMENT_ARRAY_BUFFER","getNumChannels","getNumber","createTexture","validateTextureSize","width","height","maxTextureSize","requested","createFramebuffer","bindVertexBufferToProgramAttribute","attribute","arrayEntriesPerItem","itemStrideInBytes","itemOffsetInBytes","loc","getAttribLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","bindTextureUnit","texture","textureUnit","validateTextureUnit","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","unbindTextureUnit","getProgramUniformLocationOrThrow","uniformName","getUniformLocation","getProgramUniformLocation","bindTextureToProgramUniformSampler","uniformSamplerLocation","uniform1i","bindCanvasToFramebuffer","bindFramebuffer","FRAMEBUFFER","viewport","canvas","scissor","bindColorTextureToFramebuffer","framebuffer","framebufferTexture2D","COLOR_ATTACHMENT0","unbindColorTextureFromFramebuffer","validateFramebuffer","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","getFramebufferErrorMessage","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_UNSUPPORTED","returnTOrNull","failureMessage","tOrNull","maxTextureUnit","MAX_COMBINED_TEXTURE_IMAGE_UNITS","glTextureUnit","textureUnitRange","getBatchDim","shape","dimsToSkip","sizeFromShape","getRowsCols","getShapeAs3D","shapeAs3D","isScalar","getTextureShapeFromLogicalShape","logShape","isPacked","maxTexSize","d","nearestLargerEven","squeezeResult","squeezeShape","newShape","size","batchDim","rows","cols","sizeToSquarishShape","isEven","n","isReshapeFree","shape1","shape2","arraysEqual","shape1Cols","shape2Cols","MAX_TEXTURE_SIZE","MAX_TEXTURES_IN_SHADER","getWebGLMaxTextureSize","webGLVersion","getParameter","resetMaxTextureSize","resetMaxTexturesInShader","getMaxTexturesInShader","MAX_TEXTURE_IMAGE_UNITS","min","getWebGLDisjointQueryTimerVersion","queryTimerVersion","hasExtension","ext","isWebGLVersionEnabled","e","isCapableOfRenderingToFloatTexture","isFrameBufferComplete","createFloatTextureAndBindToFramebuffer","isDownloadFloatTextureEnabled","COLOR_BUFFER_HALF_FLOAT","textureHalfFloatExtension","createHalfFloatTextureAndBindToFramebuffer","texConfig","texImage2D","internalFormatFloat","textureFormatFloat","textureTypeFloat","frameBuffer","deleteTexture","deleteFramebuffer","internalFormatHalfFloat","textureTypeHalfFloat","isWebGLFenceEnabled","isEnabled","fenceSync","assertNotComplex","tensor","opName","Array","isArray","forEach","t","assert","dtype"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-webgl/src/webgl_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext} from './canvas_util';\nimport {getTextureConfig} from './tex_util';\n\nexport function callAndCheck<T>(gl: WebGLRenderingContext, func: () => T): T {\n  const returnValue = func();\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n  return returnValue;\n}\n\nfunction checkWebGLError(gl: WebGLRenderingContext) {\n  const error = gl.getError();\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n}\n\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\n\nexport function canBeRepresented(num: number): boolean {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n      (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n    return true;\n  }\n  return false;\n}\n\nexport function getWebGLErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\n\nexport function getExtensionOrThrow(\n    gl: WebGLRenderingContext, extensionName: string): {} {\n  return throwIfNull<{}>(\n      gl, () => gl.getExtension(extensionName),\n      'Extension \"' + extensionName + '\" not supported on this browser.');\n}\n\nexport function createVertexShader(\n    gl: WebGLRenderingContext, vertexShaderSource: string): WebGLShader {\n  const vertexShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.VERTEX_SHADER),\n      'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n  return vertexShader;\n}\n\nexport function createFragmentShader(\n    gl: WebGLRenderingContext, fragmentShaderSource: string): WebGLShader {\n  const fragmentShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.FRAGMENT_SHADER),\n      'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(\n        fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n  return fragmentShader;\n}\n\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(\n    shaderSource: string, shaderInfoLog: string) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n\n  const lineNumber = +lineNumberRegexResult[1];\n\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map(\n      (line, lineNumber) =>\n          util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(\n      `%c ${util.rightPad(errorLine[0], maxLineLength)}`,\n      'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\n\nexport function createProgram(gl: WebGLRenderingContext): WebGLProgram {\n  return throwIfNull<WebGLProgram>(\n      gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\n\nexport function linkProgram(gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\n\nexport function validateProgram(\n    gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\n\nexport function createStaticVertexBuffer(\n    gl: WebGLRenderingContext, data: Float32Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function createStaticIndexBuffer(\n    gl: WebGLRenderingContext, data: Uint16Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function getNumChannels(): number {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n  return 4;\n}\n\nexport function createTexture(gl: WebGLRenderingContext): WebGLTexture {\n  return throwIfNull<WebGLTexture>(\n      gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\n\nexport function validateTextureSize(width: number, height: number) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if ((width <= 0) || (height <= 0)) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n  if ((width > maxTextureSize) || (height > maxTextureSize)) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error(\n        'Requested texture size ' + requested +\n        ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\n\nexport function createFramebuffer(gl: WebGLRenderingContext): WebGLFramebuffer {\n  return throwIfNull<WebGLFramebuffer>(\n      gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\n\nexport function bindVertexBufferToProgramAttribute(\n    gl: WebGLRenderingContext, program: WebGLProgram, attribute: string,\n    buffer: WebGLBuffer, arrayEntriesPerItem: number, itemStrideInBytes: number,\n    itemOffsetInBytes: number): boolean {\n  const loc = gl.getAttribLocation(program, attribute);\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl,\n      () => gl.vertexAttribPointer(\n          loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes,\n          itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\n\nexport function bindTextureUnit(\n    gl: WebGLRenderingContext, texture: WebGLTexture, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\n\nexport function unbindTextureUnit(\n    gl: WebGLRenderingContext, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function getProgramUniformLocationOrThrow(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return throwIfNull<WebGLUniformLocation>(\n      gl, () => gl.getUniformLocation(program, uniformName),\n      'uniform \"' + uniformName + '\" not present in program.');\n}\n\nexport function getProgramUniformLocation(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return gl.getUniformLocation(program, uniformName);\n}\n\nexport function bindTextureToProgramUniformSampler(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    uniformSamplerLocation: WebGLUniformLocation, textureUnit: number) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\n\nexport function bindCanvasToFramebuffer(gl: WebGLRenderingContext) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\n\nexport function bindColorTextureToFramebuffer(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\n\nexport function unbindColorTextureFromFramebuffer(\n    gl: WebGLRenderingContext, framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\n\nexport function validateFramebuffer(gl: WebGLRenderingContext) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error(\n        'Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\n\nexport function getFramebufferErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n    default:\n      return `unknown error ${status}`;\n  }\n}\n\nfunction throwIfNull<T>(\n    gl: WebGLRenderingContext, returnTOrNull: () => T | null,\n    failureMessage: string): T {\n  const tOrNull: T|null = callAndCheck(gl, () => returnTOrNull());\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl: WebGLRenderingContext, textureUnit: number) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\n\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [\n    shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n  ];\n}\n\nexport function getShapeAs3D(shape: number[]): [number, number, number] {\n  let shapeAs3D: [number, number, number] = [1, 1, 1];\n  const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n  if (!isScalar) {\n    shapeAs3D =\n        [getBatchDim(shape), ...getRowsCols(shape)] as [number, number, number];\n  }\n  return shapeAs3D;\n}\n\nexport function getTextureShapeFromLogicalShape(\n    logShape: number[], isPacked = false): [number, number] {\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n\n    // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n    logShape = logShape.map(\n        (d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n\n    // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  }\n\n  // If logical shape is 2, we don't squeeze, since we want to match physical.\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  let size = util.sizeFromShape(logShape);\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    return [1, size];\n  } else if (\n      logShape.length === 2 && logShape[0] <= maxTexSize &&\n      logShape[1] <= maxTexSize) {\n    return logShape as [number, number];\n  } else if (\n      logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n      logShape[2] <= maxTexSize) {\n    return [logShape[0] * logShape[1], logShape[2]];\n  } else if (\n      logShape.length === 3 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2]];\n  } else if (\n      logShape.length === 4 &&\n      logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n      logShape[3] <= maxTexSize) {\n    return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (\n      logShape.length === 4 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  } else {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n\n      const batchDim = getBatchDim(logShape);\n      let rows = 2, cols = 2;\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n      size = batchDim * (rows / 2) * (cols / 2);\n      return util.sizeToSquarishShape(size).map(d => d * 2) as [number, number];\n    }\n    return util.sizeToSquarishShape(size);\n  }\n}\n\nfunction isEven(n: number): boolean {\n  return n % 2 === 0;\n}\n\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1: number[], shape2: number[]): boolean {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {  // One of the shapes is a scalar.\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n      shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {  // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) &&\n        (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE: number;\nlet MAX_TEXTURES_IN_SHADER: number;\n\nexport function getWebGLMaxTextureSize(webGLVersion: number): number {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n  return MAX_TEXTURE_SIZE;\n}\n\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\n\nexport function getMaxTexturesInShader(webGLVersion: number): number {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  }\n  // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\n\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion: number):\n    number {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  let queryTimerVersion: number;\n  const gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n      webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n  return queryTimerVersion;\n}\n\nexport function hasExtension(gl: WebGLRenderingContext, extensionName: string) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\n\nexport function isWebGLVersionEnabled(webGLVersion: 1|2) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n  return false;\n}\n\nexport function isCapableOfRenderingToFloatTexture(webGLVersion: number):\n    boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion: number): boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension =\n          gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(\n          gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl: WebGLRenderingContext):\n    boolean {\n  const texConfig = getTextureConfig(gl);\n\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension: any): boolean {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion: number) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n\n  // tslint:disable-next-line:no-any\n  const isEnabled = (gl as any).fenceSync != null;\n  return isEnabled;\n}\n\nexport function assertNotComplex(\n    tensor: TensorInfo|TensorInfo[], opName: string): void {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(\n          t.dtype !== 'complex64',\n          () => `${opName} does not support complex64 tensors ` +\n              'in the WebGL backend.');\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}