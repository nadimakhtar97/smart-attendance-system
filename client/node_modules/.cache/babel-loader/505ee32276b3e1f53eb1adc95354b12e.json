{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { useShapeUniforms } from './gpgpu_math';\nexport class MatMulPackedProgram {\n  constructor(aShape, bShape, outputShape) {\n    let transposeA = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let transposeB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let addBias = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    let activation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    let hasPreluActivation = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n    let hasLeakyreluActivation = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n    this.variableNames = ['matrixA', 'matrixB'];\n    this.packedInputs = true;\n    this.packedOutput = true;\n    this.outputShape = outputShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n    const sharedDim = transposeA ? aShape[1] : aShape[2];\n    const sharedDimensionPacked = Math.ceil(sharedDim / 2);\n    const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n    const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n    const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n    const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n    let activationSnippet = '',\n        applyActivationSnippet = '';\n\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    if (hasLeakyreluActivation) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    let batchASnippet = 'rc.x';\n    let batchBSnippet = 'rc.x';\n\n    if (aShape[0] < bShape[0]) {\n      batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;\n    } else if (bShape[0] < aShape[0]) {\n      batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${sharedDimensionPacked}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${sharedDimensionPacked}; i++) {\n          int batchA = ${batchASnippet};\n          int batchB = ${batchBSnippet};\n          vec4 a = getMatrixA(batchA, ${aSample});\n          vec4 b = getMatrixB(batchB, ${bSample});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${aSwizzle[0]} * ${bSwizzle[0]});\n          result += (${aSwizzle[1]} * ${bSwizzle[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${addBiasSnippet}\n\n        ${applyActivationSnippet}\n\n        setOutput(result);\n      }\n    `;\n  }\n\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAsBA,gBAAtB,QAA6C,cAA7C;AAEA,OAAM,MAAOC,mBAAP,CAA0B;AAQ9BC,cACIC,MADJ,EACsCC,MADtC,EAEIC,WAFJ,EAI8D;AAAA,QAFnBC,UAEmB,uEAFN,KAEM;AAAA,QAD1DC,UAC0D,uEAD7C,KAC6C;AAAA,QADtCC,OACsC,uEAD5B,KAC4B;AAAA,QADrBC,UACqB,uEADA,IACA;AAAA,QAA1DC,kBAA0D,uEAArC,KAAqC;AAAA,QAA9BC,sBAA8B,uEAAL,KAAK;AAX9D,yBAAgB,CAAC,SAAD,EAAY,SAAZ,CAAhB;AACA,wBAAe,IAAf;AACA,wBAAe,IAAf;AAUE,SAAKN,WAAL,GAAmBA,WAAnB;AACA,SAAKO,mBAAL,GAA2BZ,gBAAgB,CAAC,KAAKK,WAAL,CAAiBQ,MAAlB,CAA3C;AAEA,UAAMC,SAAS,GAAGR,UAAU,GAAGH,MAAM,CAAC,CAAD,CAAT,GAAeA,MAAM,CAAC,CAAD,CAAjD;AACA,UAAMY,qBAAqB,GAAGC,IAAI,CAACC,IAAL,CAAUH,SAAS,GAAG,CAAtB,CAA9B;AAEA,UAAMI,OAAO,GAAGZ,UAAU,GAAG,aAAH,GAAmB,aAA7C;AACA,UAAMa,OAAO,GAAGZ,UAAU,GAAG,aAAH,GAAmB,aAA7C;AACA,UAAMa,QAAQ,GAAGd,UAAU,GAAG,CAAC,QAAD,EAAW,QAAX,CAAH,GAA0B,CAAC,QAAD,EAAW,QAAX,CAArD;AACA,UAAMe,QAAQ,GAAGd,UAAU,GAAG,CAAC,QAAD,EAAW,QAAX,CAAH,GAA0B,CAAC,QAAD,EAAW,QAAX,CAArD;AAEA,QAAIe,iBAAiB,GAAG,EAAxB;AAAA,QAA4BC,sBAAsB,GAAG,EAArD;;AACA,QAAId,UAAJ,EAAgB;AACd,UAAIC,kBAAJ,EAAwB;AACtBY,yBAAiB,GAAG;;YAEhBb,UAAU;UAFd;AAID,OALD,MAKO,IAAIE,sBAAJ,EAA4B;AACjCW,yBAAiB,GAAG;;YAEhBb,UAAU;UAFd;AAID,OALM,MAKA;AACLa,yBAAiB,GAAG;YAChBb,UAAU;UADd;AAGD;;AAEDc,4BAAsB,GAAG,8BAAzB;AACD;;AAED,UAAMC,cAAc,GAAGhB,OAAO,GAAG,iCAAH,GAAuC,EAArE;;AACA,QAAIA,OAAJ,EAAa;AACX,WAAKiB,aAAL,CAAmBC,IAAnB,CAAwB,MAAxB;AACD;;AAED,QAAIhB,kBAAJ,EAAwB;AACtB,WAAKe,aAAL,CAAmBC,IAAnB,CAAwB,wBAAxB;AACD;;AAED,QAAIf,sBAAJ,EAA4B;AAC1B,WAAKc,aAAL,CAAmBC,IAAnB,CAAwB,gBAAxB;AACD;;AAED,QAAIC,aAAa,GAAG,MAApB;AACA,QAAIC,aAAa,GAAG,MAApB;;AACA,QAAIzB,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAAtB,EAA2B;AACzBuB,mBAAa,GAAG,wBAAwBxB,MAAM,CAAC,CAAD,CAAN,GAAY,CAAC,KAArD;AACD,KAFD,MAEO,IAAIC,MAAM,CAAC,CAAD,CAAN,GAAYD,MAAM,CAAC,CAAD,CAAtB,EAA2B;AAChCyB,mBAAa,GAAG,wBAAwBxB,MAAM,CAAC,CAAD,CAAN,GAAY,CAAC,KAArD;AACD;;AAED,SAAKyB,QAAL,GAAgB;QACZP,iBAAiB;;sCAEaP,qBAAqB;;;;8BAI7BA,qBAAqB;yBAC1BY,aAAa;yBACbC,aAAa;wCACEV,OAAO;wCACPC,OAAO;;;;uBAIxBC,QAAQ,CAAC,CAAD,CAAG,MAAMC,QAAQ,CAAC,CAAD,CAAG;uBAC5BD,QAAQ,CAAC,CAAD,CAAG,MAAMC,QAAQ,CAAC,CAAD,CAAG;;;;;;;;;UASzCG,cAAc;;UAEdD,sBAAsB;;;;KA3B5B;AAgCD;;AAlG6B","names":["useShapeUniforms","MatMulPackedProgram","constructor","aShape","bShape","outputShape","transposeA","transposeB","addBias","activation","hasPreluActivation","hasLeakyreluActivation","enableShapeUniforms","length","sharedDim","sharedDimensionPacked","Math","ceil","aSample","bSample","aSwizzle","bSwizzle","activationSnippet","applyActivationSnippet","addBiasSnippet","variableNames","push","batchASnippet","batchBSnippet","userCode"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-webgl/src/mulmat_packed_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram, useShapeUniforms} from './gpgpu_math';\n\nexport class MatMulPackedProgram implements GPGPUProgram {\n  variableNames = ['matrixA', 'matrixB'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n  enableShapeUniforms: boolean;\n\n  constructor(\n      aShape: [number, number, number], bShape: [number, number, number],\n      outputShape: [number, number, number], transposeA = false,\n      transposeB = false, addBias = false, activation: string = null,\n      hasPreluActivation = false, hasLeakyreluActivation = false) {\n    this.outputShape = outputShape;\n    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n\n    const sharedDim = transposeA ? aShape[1] : aShape[2];\n    const sharedDimensionPacked = Math.ceil(sharedDim / 2);\n\n    const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n    const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n    const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n    const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    if (hasLeakyreluActivation) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    let batchASnippet = 'rc.x';\n    let batchBSnippet = 'rc.x';\n    if (aShape[0] < bShape[0]) {\n      batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;\n    } else if (bShape[0] < aShape[0]) {\n      batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${sharedDimensionPacked}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${sharedDimensionPacked}; i++) {\n          int batchA = ${batchASnippet};\n          int batchB = ${batchBSnippet};\n          vec4 a = getMatrixA(batchA, ${aSample});\n          vec4 b = getMatrixB(batchB, ${bSample});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${aSwizzle[0]} * ${bSwizzle[0]});\n          result += (${aSwizzle[1]} * ${bSwizzle[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${addBiasSnippet}\n\n        ${applyActivationSnippet}\n\n        setOutput(result);\n      }\n    `;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}