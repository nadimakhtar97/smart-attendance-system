{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { ValueError } from '../errors';\nimport { Layer, Node, SymbolicTensor } from './topology';\nexport class InputLayer extends Layer {\n  constructor(args) {\n    super({\n      dtype: args.dtype,\n      name: args.name != null ? args.name : getUid('input').toString()\n    }); // Normalize config.batchSize and config.sparse\n\n    if (args.batchSize == null) {\n      args.batchSize = null;\n    }\n\n    if (args.sparse == null) {\n      args.sparse = false;\n    }\n\n    this.trainable = false;\n    this.built = true;\n    this.sparse = args.sparse;\n\n    if (args.inputShape != null && args.batchInputShape != null) {\n      throw new ValueError('Only provide the inputShape OR ' + 'batchInputShape argument to inputLayer, not both at the same time.');\n    }\n\n    let batchInputShape = args.batchInputShape;\n\n    if (batchInputShape == null) {\n      if (args.inputShape == null) {\n        throw new ValueError('An InputLayer should be passed either a ' + '`batchInputShape` or an `inputShape`.');\n      } else {\n        batchInputShape = [args.batchSize].concat(args.inputShape);\n      }\n    } else {\n      // TODO(michaelterry): Backport to PyKeras\n      if (args.batchSize != null) {\n        throw new ValueError('Cannot specify batchSize if batchInputShape is ' + 'specified when creating an InputLayer.');\n      }\n    }\n\n    const dtype = args.dtype || 'float32';\n    this.batchInputShape = batchInputShape;\n    this.dtype = dtype; // TODO(michaelterry): Backport this to PyKeras?\n\n    this.inputSpec = [{\n      shape: batchInputShape\n    }];\n    const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);\n    inputTensor.nodeIndex = 0;\n    inputTensor.tensorIndex = 0; // Create an input node to add to this.outboundNode.\n    // (This call has side effects.)\n    // tslint:disable-next-line:no-unused-expression\n\n    new Node({\n      outboundLayer: this,\n      inboundLayers: [],\n      nodeIndices: [],\n      tensorIndices: [],\n      inputTensors: [inputTensor],\n      outputTensors: [inputTensor],\n      inputMasks: [null],\n      outputMasks: [null],\n      inputShapes: [batchInputShape],\n      outputShapes: [batchInputShape]\n    });\n  }\n\n  apply(inputs, kwargs) {\n    throw new ValueError('Cannot pass any input to an ' + `InputLayer's apply() method. InputLayer name: ${this.name}`);\n  }\n\n  dispose() {\n    // dispose() for InputLayer is overridden as no-op.\n    return {\n      refCountAfterDispose: this._refCount,\n      numDisposedVariables: 0\n    };\n  }\n\n  getConfig() {\n    return {\n      batchInputShape: this.batchInputShape,\n      dtype: this.dtype,\n      sparse: this.sparse,\n      name: this.name\n    };\n  }\n\n}\n/** @nocollapse */\n\nInputLayer.className = 'InputLayer';\nserialization.registerClass(InputLayer);\nexport function Input(config) {\n  if (config.batchShape == null && config.shape == null) {\n    throw new Error('Please provide to Input either a `shape`' + ' or a `batchShape` argument. Note that ' + '`shape` does not include the batch ' + 'dimension.');\n  }\n\n  if (config.batchShape != null && config.shape != null) {\n    // TODO(michaelterry): Backport to PyKeras.\n    throw new ValueError('Please provide either a `shape` or `batchShape` ' + 'argument to Input, but not both.');\n  }\n\n  let batchShape = config.batchShape;\n\n  if (config.shape != null && batchShape == null) {\n    batchShape = [null].concat(config.shape);\n  }\n\n  let dtype = config.dtype;\n\n  if (dtype == null) {\n    dtype = 'float32';\n  }\n\n  const inputLayer = new InputLayer({\n    batchInputShape: batchShape,\n    name: config.name,\n    dtype,\n    sparse: config.sparse\n  });\n  const outputs = inputLayer.inboundNodes[0].outputTensors;\n  return outputs[0];\n}","map":{"version":3,"mappings":"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","names":["serialization","getUid","ValueError","Layer","Node","SymbolicTensor","InputLayer","constructor","args","dtype","name","toString","batchSize","sparse","trainable","built","inputShape","batchInputShape","concat","inputSpec","shape","inputTensor","nodeIndex","tensorIndex","outboundLayer","inboundLayers","nodeIndices","tensorIndices","inputTensors","outputTensors","inputMasks","outputMasks","inputShapes","outputShapes","apply","inputs","kwargs","dispose","refCountAfterDispose","_refCount","numDisposedVariables","getConfig","registerClass","Input","config","batchShape","Error","inputLayer","outputs","inboundNodes"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-layers/src/engine/input_layer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\nimport {DataType, serialization, Tensor} from '@tensorflow/tfjs-core';\n\nimport {getUid} from '../backend/state';\nimport {ValueError} from '../errors';\nimport {Shape} from '../keras_format/common';\nimport {Kwargs} from '../types';\n\nimport {DisposeResult, Layer, Node, SymbolicTensor} from './topology';\n\n/**\n * Constructor arguments for InputLayer.\n *\n * Note: You should provide only inputShape or batchInputShape (not both).\n * If only inputShape is provided, then the batchInputShape is determined by\n * the batchSize argument and the inputShape: [batchSize].concat(inputShape).\n */\nexport declare interface InputLayerArgs {\n  /** Input shape, not including the batch axis. */\n  inputShape?: Shape;\n  /** Optional input batch size (integer or null). */\n  batchSize?: number;\n  /** Batch input shape, including the batch axis. */\n  batchInputShape?: Shape;\n  /** Datatype of the input.  */\n  dtype?: DataType;\n  /**\n   * Whether the placeholder created is meant to be sparse.\n   */\n  sparse?: boolean;  // TODO(michaelterry): Not clear whether we'll need this.\n\n  /** Name of the layer. */\n  name?: string;\n}\n\nexport class InputLayer extends Layer {\n  /** @nocollapse */\n  static readonly className = 'InputLayer';\n  sparse: boolean;\n  constructor(args: InputLayerArgs) {\n    super({\n      dtype: args.dtype,\n      name: args.name != null ? args.name : getUid('input').toString()\n    });\n    // Normalize config.batchSize and config.sparse\n    if (args.batchSize == null) {\n      args.batchSize = null;\n    }\n    if (args.sparse == null) {\n      args.sparse = false;\n    }\n\n    this.trainable = false;\n    this.built = true;\n    this.sparse = args.sparse;\n\n    if (args.inputShape != null && args.batchInputShape != null) {\n      throw new ValueError(\n          'Only provide the inputShape OR ' +\n          'batchInputShape argument to inputLayer, not both at the same time.');\n    }\n    let batchInputShape = args.batchInputShape;\n    if (batchInputShape == null) {\n      if (args.inputShape == null) {\n        throw new ValueError(\n            'An InputLayer should be passed either a ' +\n            '`batchInputShape` or an `inputShape`.');\n      } else {\n        batchInputShape = [args.batchSize].concat(args.inputShape);\n      }\n    } else {\n      // TODO(michaelterry): Backport to PyKeras\n      if (args.batchSize != null) {\n        throw new ValueError(\n            'Cannot specify batchSize if batchInputShape is ' +\n            'specified when creating an InputLayer.');\n      }\n    }\n\n    const dtype = args.dtype || 'float32';\n\n    this.batchInputShape = batchInputShape;\n    this.dtype = dtype;\n    // TODO(michaelterry): Backport this to PyKeras?\n    this.inputSpec = [{shape: batchInputShape}];\n\n    const inputTensor = new SymbolicTensor(\n        this.dtype, this.batchInputShape, this, [], {}, this.name);\n    inputTensor.nodeIndex = 0;\n    inputTensor.tensorIndex = 0;\n\n    // Create an input node to add to this.outboundNode.\n    // (This call has side effects.)\n    // tslint:disable-next-line:no-unused-expression\n    new Node({\n      outboundLayer: this,\n      inboundLayers: [],\n      nodeIndices: [],\n      tensorIndices: [],\n      inputTensors: [inputTensor],\n      outputTensors: [inputTensor],\n      inputMasks: [null],\n      outputMasks: [null],\n      inputShapes: [batchInputShape],\n      outputShapes: [batchInputShape]\n    });\n  }\n\n  apply(\n      inputs: Tensor|Tensor[]|SymbolicTensor|SymbolicTensor[],\n      kwargs?: Kwargs): Tensor|Tensor[]|SymbolicTensor {\n    throw new ValueError(\n        'Cannot pass any input to an ' +\n        `InputLayer's apply() method. InputLayer name: ${this.name}`);\n  }\n\n  dispose(): DisposeResult {\n    // dispose() for InputLayer is overridden as no-op.\n    return {refCountAfterDispose: this._refCount, numDisposedVariables: 0};\n  }\n\n  getConfig(): serialization.ConfigDict {\n    return {\n      batchInputShape: this.batchInputShape,\n      dtype: this.dtype,\n      sparse: this.sparse,\n      name: this.name\n    };\n  }\n}\nserialization.registerClass(InputLayer);\n\n/**\n * Config for the Input function.\n *\n * Note: You should provide only shape or batchShape (not both).\n * If only shape is provided, then the batchShape becomes\n * [null].concat(inputShape).\n */\nexport interface InputConfig {\n  /**\n   * A shape, not including the batch size. For instance, `shape=[32]`\n   * indicates that the expected input will be batches of 32-dimensional\n   * vectors.\n   */\n  shape?: Shape;\n  /**\n   * A shape tuple (integer), including the batch size. For instance,\n   * `batchShape=[10, 32]` indicates that the expected input will be batches of\n   * 10 32-dimensional vectors. `batchShape=[null, 32]` indicates batches of an\n   * arbitrary number of 32-dimensional vectors.\n   */\n  batchShape?: Shape;\n  /**\n   * An optional name string for the layer. Should be unique in a model (do not\n   * reuse the same name twice). It will be autogenerated if it isn't provided.\n   */\n  name?: string;\n  dtype?: DataType;\n  /**\n   * A boolean specifying whether the placeholder to be created is sparse.\n   */\n  sparse?: boolean;\n}\n\nexport function Input(config: InputConfig): SymbolicTensor {\n  if (config.batchShape == null && config.shape == null) {\n    throw new Error(\n        'Please provide to Input either a `shape`' +\n        ' or a `batchShape` argument. Note that ' +\n        '`shape` does not include the batch ' +\n        'dimension.');\n  }\n  if (config.batchShape != null && config.shape != null) {\n    // TODO(michaelterry): Backport to PyKeras.\n    throw new ValueError(\n        'Please provide either a `shape` or `batchShape` ' +\n        'argument to Input, but not both.');\n  }\n  let batchShape = config.batchShape;\n  if (config.shape != null && batchShape == null) {\n    batchShape = [null].concat(config.shape);\n  }\n\n  let dtype = config.dtype;\n  if (dtype == null) {\n    dtype = 'float32';\n  }\n\n  const inputLayer = new InputLayer({\n    batchInputShape: batchShape,\n    name: config.name,\n    dtype,\n    sparse: config.sparse\n  });\n\n  const outputs = inputLayer.inboundNodes[0].outputTensors;\n  return outputs[0];\n}\n"]},"metadata":{},"sourceType":"module"}