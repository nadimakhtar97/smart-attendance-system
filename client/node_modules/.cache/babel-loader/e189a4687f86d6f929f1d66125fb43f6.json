{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { inferShape } from './tensor_util_env';\nimport { arraysEqual, encodeString, flatten, isString, isTypedArray } from './util';\nconst TEST_EPSILON_FLOAT32 = 1e-3;\nexport const TEST_EPSILON_FLOAT16 = 1e-1;\nexport function expectArraysClose(actual, expected, epsilon) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n\n  return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, epsilon));\n}\nexport function testEpsilon() {\n  return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;\n}\n\nfunction expectArraysPredicate(actual, expected, predicate) {\n  let checkClassType = true;\n\n  if (isTypedArray(actual) || isTypedArray(expected)) {\n    checkClassType = false;\n  }\n\n  if (isTypedArray(actual) && isTypedArray(expected)) {\n    checkClassType = true;\n  }\n\n  if (checkClassType) {\n    const aType = actual.constructor.name;\n    const bType = expected.constructor.name;\n\n    if (aType !== bType) {\n      throw new Error(`Arrays are of different type. Actual: ${aType}. ` + `Expected: ${bType}`);\n    }\n  }\n\n  if (Array.isArray(actual) && Array.isArray(expected)) {\n    const actualShape = inferShape(actual);\n    const expectedShape = inferShape(expected);\n\n    if (!arraysEqual(actualShape, expectedShape)) {\n      throw new Error(`Arrays have different shapes. ` + `Actual: [${actualShape}]. Expected: [${expectedShape}]`);\n    }\n  }\n\n  const actualFlat = isTypedArray(actual) ? actual : flatten(actual);\n  const expectedFlat = isTypedArray(expected) ? expected : flatten(expected);\n\n  if (actualFlat.length !== expectedFlat.length) {\n    throw new Error(`Arrays have different lengths actual: ${actualFlat.length} vs ` + `expected: ${expectedFlat.length}.\\n` + `Actual:   ${actualFlat}.\\n` + `Expected: ${expectedFlat}.`);\n  }\n\n  for (let i = 0; i < expectedFlat.length; ++i) {\n    const a = actualFlat[i];\n    const e = expectedFlat[i];\n\n    if (!predicate(a, e)) {\n      throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${e}.\\n` + `Actual:   ${actualFlat}.\\n` + `Expected: ${expectedFlat}.`);\n    }\n  }\n}\n\nexport function expectPromiseToFail(fn, done) {\n  fn().then(() => done.fail(), () => done());\n}\nexport function expectArraysEqual(actual, expected) {\n  const exp = typeof expected === 'string' || typeof expected === 'number' || typeof expected === 'boolean' ? [expected] : expected;\n\n  if (isString(actual) || isString(actual[0]) || isString(expected) || isString(expected[0])) {\n    // tslint:disable-next-line: triple-equals\n    return expectArraysPredicate(actual, exp, (a, b) => a == b);\n  }\n\n  return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, 0));\n}\nexport function expectNumbersClose(a, e, epsilon) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n\n  if (!areClose(a, e, epsilon)) {\n    throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);\n  }\n}\n\nfunction areClose(a, e, epsilon) {\n  if (!isFinite(a) && !isFinite(e)) {\n    return true;\n  }\n\n  if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function expectValuesInRange(actual, low, high) {\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] < low || actual[i] > high) {\n      throw new Error(`Value out of range:${actual[i]} low: ${low}, high: ${high}`);\n    }\n  }\n}\nexport function expectArrayBuffersEqual(actual, expected) {\n  // Safari does not like comparing ArrayBuffers directly. Wrapping in\n  // a Float32Array solves this issue.\n  const actualArray = new Float32Array(actual);\n  const expectedArray = new Float32Array(expected);\n\n  if (actualArray.length !== expectedArray.length) {\n    throw new Error('Expected ArrayBuffer to be of length ' + `${expectedArray.length}, but it was ${actualArray.length}`);\n  }\n\n  for (let i = 0; i < expectedArray.length; i++) {\n    if (actualArray[i] !== expectedArray[i]) {\n      throw new Error(`Expected ArrayBuffer value at ${i} to be ` + `${expectedArray[i]} but got ${actualArray[i]} instead`);\n    }\n  }\n}\n/** Encodes strings into utf-8 bytes. */\n\nexport function encodeStrings(a) {\n  for (let i = 0; i < a.length; i++) {\n    const val = a[i];\n\n    if (Array.isArray(val)) {\n      encodeStrings(val);\n    } else {\n      a[i] = encodeString(val);\n    }\n  }\n\n  return a;\n}","map":{"version":3,"mappings":"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","names":["ENGINE","inferShape","arraysEqual","encodeString","flatten","isString","isTypedArray","TEST_EPSILON_FLOAT32","TEST_EPSILON_FLOAT16","expectArraysClose","actual","expected","epsilon","testEpsilon","expectArraysPredicate","a","b","areClose","backend","floatPrecision","predicate","checkClassType","aType","constructor","name","bType","Error","Array","isArray","actualShape","expectedShape","actualFlat","expectedFlat","length","i","e","expectPromiseToFail","fn","done","then","fail","expectArraysEqual","exp","expectNumbersClose","isFinite","isNaN","Math","abs","expectValuesInRange","low","high","expectArrayBuffersEqual","actualArray","Float32Array","expectedArray","encodeStrings","val"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/test_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from './engine';\nimport {inferShape} from './tensor_util_env';\nimport {RecursiveArray, TensorLike, TypedArray} from './types';\nimport {arraysEqual, encodeString, flatten, isString, isTypedArray} from './util';\n\nconst TEST_EPSILON_FLOAT32 = 1e-3;\nexport const TEST_EPSILON_FLOAT16 = 1e-1;\n\nexport function expectArraysClose(\n    actual: TypedArray|number|RecursiveArray<number>,\n    expected: TypedArray|number|RecursiveArray<number>, epsilon?: number) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n  return expectArraysPredicate(\n      actual, expected, (a, b) => areClose(a as number, b as number, epsilon));\n}\n\nexport function testEpsilon() {\n  return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 :\n                                                  TEST_EPSILON_FLOAT16;\n}\n\nfunction expectArraysPredicate(\n    actual: TensorLike, expected: TensorLike,\n    predicate: (a: {}, b: {}) => boolean) {\n  let checkClassType = true;\n  if (isTypedArray(actual) || isTypedArray(expected)) {\n    checkClassType = false;\n  }\n  if (isTypedArray(actual) && isTypedArray(expected)) {\n    checkClassType = true;\n  }\n  if (checkClassType) {\n    const aType = actual.constructor.name;\n    const bType = expected.constructor.name;\n\n    if (aType !== bType) {\n      throw new Error(\n          `Arrays are of different type. Actual: ${aType}. ` +\n          `Expected: ${bType}`);\n    }\n  }\n\n  if (Array.isArray(actual) && Array.isArray(expected)) {\n    const actualShape = inferShape(actual);\n    const expectedShape = inferShape(expected);\n    if (!arraysEqual(actualShape, expectedShape)) {\n      throw new Error(\n          `Arrays have different shapes. ` +\n          `Actual: [${actualShape}]. Expected: [${expectedShape}]`);\n    }\n  }\n\n  const actualFlat =\n      isTypedArray(actual) ? actual : flatten(actual as RecursiveArray<number>);\n  const expectedFlat = isTypedArray(expected) ?\n      expected :\n      flatten(expected as RecursiveArray<number>);\n\n  if (actualFlat.length !== expectedFlat.length) {\n    throw new Error(\n        `Arrays have different lengths actual: ${actualFlat.length} vs ` +\n        `expected: ${expectedFlat.length}.\\n` +\n        `Actual:   ${actualFlat}.\\n` +\n        `Expected: ${expectedFlat}.`);\n  }\n  for (let i = 0; i < expectedFlat.length; ++i) {\n    const a = actualFlat[i];\n    const e = expectedFlat[i];\n\n    if (!predicate(a, e)) {\n      throw new Error(\n          `Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${e}.\\n` +\n          `Actual:   ${actualFlat}.\\n` +\n          `Expected: ${expectedFlat}.`);\n    }\n  }\n}\n\nexport interface DoneFn {\n  (): void;\n  fail: (message?: Error|string) => void;\n}\n\nexport function expectPromiseToFail(fn: () => Promise<{}>, done: DoneFn): void {\n  fn().then(() => done.fail(), () => done());\n}\n\nexport function expectArraysEqual(actual: TensorLike, expected: TensorLike) {\n  const exp = typeof expected === 'string' || typeof expected === 'number' ||\n          typeof expected === 'boolean' ?\n      [expected] as number[] :\n      expected as number[];\n  if (isString(actual) || isString((actual as string[])[0]) ||\n      isString(expected) || isString((expected as string[])[0])) {\n    // tslint:disable-next-line: triple-equals\n    return expectArraysPredicate(actual, exp, (a, b) => a == b);\n  }\n  return expectArraysPredicate(\n      actual, expected, (a, b) => areClose(a as number, b as number, 0));\n}\n\nexport function expectNumbersClose(a: number, e: number, epsilon?: number) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n  if (!areClose(a, e, epsilon)) {\n    throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);\n  }\n}\n\nfunction areClose(a: number, e: number, epsilon: number): boolean {\n  if (!isFinite(a) && !isFinite(e)) {\n    return true;\n  }\n  if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {\n    return false;\n  }\n  return true;\n}\n\nexport function expectValuesInRange(\n    actual: TypedArray|number[], low: number, high: number) {\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] < low || actual[i] > high) {\n      throw new Error(\n          `Value out of range:${actual[i]} low: ${low}, high: ${high}`);\n    }\n  }\n}\n\nexport function expectArrayBuffersEqual(\n    actual: ArrayBuffer, expected: ArrayBuffer) {\n  // Safari does not like comparing ArrayBuffers directly. Wrapping in\n  // a Float32Array solves this issue.\n  const actualArray = new Float32Array(actual);\n  const expectedArray = new Float32Array(expected);\n  if (actualArray.length !== expectedArray.length) {\n    throw new Error(\n        'Expected ArrayBuffer to be of length ' +\n        `${expectedArray.length}, but it was ${actualArray.length}`);\n  }\n\n  for (let i = 0; i < expectedArray.length; i++) {\n    if (actualArray[i] !== expectedArray[i]) {\n      throw new Error(\n          `Expected ArrayBuffer value at ${i} to be ` +\n          `${expectedArray[i]} but got ${actualArray[i]} instead`);\n    }\n  }\n}\n\n/** Encodes strings into utf-8 bytes. */\nexport function encodeStrings(a: RecursiveArray<{}>):\n    RecursiveArray<Uint8Array> {\n  for (let i = 0; i < (a as Array<{}>).length; i++) {\n    const val = a[i];\n    if (Array.isArray(val)) {\n      encodeStrings(val);\n    } else {\n      a[i] = encodeString(val as string);\n    }\n  }\n  return a as RecursiveArray<Uint8Array>;\n}\n"]},"metadata":{},"sourceType":"module"}