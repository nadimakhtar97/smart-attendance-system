{"ast":null,"code":"import * as losses from './losses';\nimport * as metrics from './metrics';\n/**\n * Binary accuracy metric function.\n *\n * `yTrue` and `yPred` can have 0-1 values. Example:\n * ```js\n * const x = tf.tensor2d([[1, 1, 1, 1], [0, 0, 0, 0]], [2, 4]);\n * const y = tf.tensor2d([[1, 0, 1, 0], [0, 0, 0, 1]], [2, 4]);\n * const accuracy = tf.metrics.binaryAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * `yTrue` and `yPred` can also have floating-number values between 0 and 1, in\n * which case the values will be thresholded at 0.5 to yield 0-1 values (i.e.,\n * a value >= 0.5 and <= 1.0 is interpreted as 1.\n * )\n * Example:\n * ```js\n * const x = tf.tensor1d([1, 1, 1, 1, 0, 0, 0, 0]);\n * const y = tf.tensor1d([0.2, 0.4, 0.6, 0.8, 0.2, 0.3, 0.4, 0.7]);\n * const accuracy = tf.metrics.binaryAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth.\n * @param yPred Binary Tensor of prediction.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function binaryAccuracy(yTrue, yPred) {\n  return metrics.binaryAccuracy(yTrue, yPred);\n}\n/**\n * Binary crossentropy metric function.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d([[0], [1], [1], [1]]);\n * const y = tf.tensor2d([[0], [0], [0.5], [1]]);\n * const crossentropy = tf.metrics.binaryCrossentropy(x, y);\n * crossentropy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth.\n * @param yPred Binary Tensor of prediction, probabilities for the `1` case.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function binaryCrossentropy(yTrue, yPred) {\n  return metrics.binaryCrossentropy(yTrue, yPred);\n}\n/**\n * Sparse categorical accuracy metric function.\n *\n * Example:\n * ```js\n *\n * const yTrue = tf.tensor1d([1, 1, 2, 2, 0]);\n * const yPred = tf.tensor2d(\n *      [[0, 1, 0], [1, 0, 0], [0, 0.4, 0.6], [0, 0.6, 0.4], [0.7, 0.3, 0]]);\n * const crossentropy = tf.metrics.sparseCategoricalAccuracy(yTrue, yPred);\n * crossentropy.print();\n * ```\n *\n * @param yTrue True labels: indices.\n * @param yPred Predicted probabilities or logits.\n * @returns Accuracy tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function sparseCategoricalAccuracy(yTrue, yPred) {\n  return metrics.sparseCategoricalAccuracy(yTrue, yPred);\n}\n/**\n * Categorical accuracy metric function.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d([[0, 0, 0, 1], [0, 0, 0, 1]]);\n * const y = tf.tensor2d([[0.1, 0.8, 0.05, 0.05], [0.1, 0.05, 0.05, 0.8]]);\n * const accuracy = tf.metrics.categoricalAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth: one-hot encoding of categories.\n * @param yPred Binary Tensor of prediction: probabilities or logits for the\n *   same categories as in `yTrue`.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function categoricalAccuracy(yTrue, yPred) {\n  return metrics.categoricalAccuracy(yTrue, yPred);\n}\n/**\n * Categorical crossentropy between an output tensor and a target tensor.\n *\n * @param target A tensor of the same shape as `output`.\n * @param output A tensor resulting from a softmax (unless `fromLogits` is\n *  `true`, in which case `output` is expected to be the logits).\n * @param fromLogits Boolean, whether `output` is the result of a softmax, or is\n *   a tensor of logits.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function categoricalCrossentropy(yTrue, yPred) {\n  return metrics.categoricalCrossentropy(yTrue, yPred);\n}\n/**\n * Computes the precision of the predictions with respect to the labels.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d(\n *    [\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [1, 0, 0, 0],\n *      [0, 0, 1, 0]\n *    ]\n * );\n *\n * const y = tf.tensor2d(\n *    [\n *      [0, 0, 1, 0],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 1, 0, 0]\n *    ]\n * );\n *\n * const precision = tf.metrics.precision(x, y);\n * precision.print();\n * ```\n *\n * @param yTrue The ground truth values. Expected to be contain only 0-1 values.\n * @param yPred The predicted values. Expected to be contain only 0-1 values.\n * @return Precision Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function precision(yTrue, yPred) {\n  return metrics.precision(yTrue, yPred);\n}\n/**\n * Computes the recall of the predictions with respect to the labels.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d(\n *    [\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [1, 0, 0, 0],\n *      [0, 0, 1, 0]\n *    ]\n * );\n *\n * const y = tf.tensor2d(\n *    [\n *      [0, 0, 1, 0],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 1, 0, 0]\n *    ]\n * );\n *\n * const recall = tf.metrics.recall(x, y);\n * recall.print();\n * ```\n *\n * @param yTrue The ground truth values. Expected to be contain only 0-1 values.\n * @param yPred The predicted values. Expected to be contain only 0-1 values.\n * @return Recall Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function recall(yTrue, yPred) {\n  return metrics.recall(yTrue, yPred);\n}\n/**\n * Loss or metric function: Cosine proximity.\n *\n * Mathematically, cosine proximity is defined as:\n *   `-sum(l2Normalize(yTrue) * l2Normalize(yPred))`,\n * wherein `l2Normalize()` normalizes the L2 norm of the input to 1 and `*`\n * represents element-wise multiplication.\n *\n * ```js\n * const yTrue = tf.tensor2d([[1, 0], [1, 0]]);\n * const yPred = tf.tensor2d([[1 / Math.sqrt(2), 1 / Math.sqrt(2)], [0, 1]]);\n * const proximity = tf.metrics.cosineProximity(yTrue, yPred);\n * proximity.print();\n * ```\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Cosine proximity Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function cosineProximity(yTrue, yPred) {\n  return losses.cosineProximity(yTrue, yPred);\n}\n/**\n * Loss or metric function: Mean absolute error.\n *\n * Mathematically, mean absolute error is defined as:\n *   `mean(abs(yPred - yTrue))`,\n * wherein the `mean` is applied over feature dimensions.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [0, 0], [2, 3]]);\n * const yPred = tf.tensor2d([[0, 1], [0, 1], [-2, -3]]);\n * const mse = tf.metrics.meanAbsoluteError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean absolute error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function meanAbsoluteError(yTrue, yPred) {\n  return losses.meanAbsoluteError(yTrue, yPred);\n}\n/**\n * Loss or metric function: Mean absolute percentage error.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [10, 20]]);\n * const yPred = tf.tensor2d([[0, 1], [11, 24]]);\n * const mse = tf.metrics.meanAbsolutePercentageError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * Aliases: `tf.metrics.MAPE`, `tf.metrics.mape`.\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean absolute percentage error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function meanAbsolutePercentageError(yTrue, yPred) {\n  return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\nexport function MAPE(yTrue, yPred) {\n  return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\nexport function mape(yTrue, yPred) {\n  return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\n/**\n * Loss or metric function: Mean squared error.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [3, 4]]);\n * const yPred = tf.tensor2d([[0, 1], [-3, -4]]);\n * const mse = tf.metrics.meanSquaredError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * Aliases: `tf.metrics.MSE`, `tf.metrics.mse`.\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean squared error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nexport function meanSquaredError(yTrue, yPred) {\n  return losses.meanSquaredError(yTrue, yPred);\n}\nexport function MSE(yTrue, yPred) {\n  return losses.meanSquaredError(yTrue, yPred);\n}\nexport function mse(yTrue, yPred) {\n  return losses.meanSquaredError(yTrue, yPred);\n}","map":{"version":3,"mappings":"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","names":["losses","metrics","binaryAccuracy","yTrue","yPred","binaryCrossentropy","sparseCategoricalAccuracy","categoricalAccuracy","categoricalCrossentropy","precision","recall","cosineProximity","meanAbsoluteError","meanAbsolutePercentageError","MAPE","mape","meanSquaredError","MSE","mse"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-layers/src/exports_metrics.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport {Tensor} from '@tensorflow/tfjs-core';\n\nimport * as losses from './losses';\nimport * as metrics from './metrics';\n\n/**\n * Binary accuracy metric function.\n *\n * `yTrue` and `yPred` can have 0-1 values. Example:\n * ```js\n * const x = tf.tensor2d([[1, 1, 1, 1], [0, 0, 0, 0]], [2, 4]);\n * const y = tf.tensor2d([[1, 0, 1, 0], [0, 0, 0, 1]], [2, 4]);\n * const accuracy = tf.metrics.binaryAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * `yTrue` and `yPred` can also have floating-number values between 0 and 1, in\n * which case the values will be thresholded at 0.5 to yield 0-1 values (i.e.,\n * a value >= 0.5 and <= 1.0 is interpreted as 1.\n * )\n * Example:\n * ```js\n * const x = tf.tensor1d([1, 1, 1, 1, 0, 0, 0, 0]);\n * const y = tf.tensor1d([0.2, 0.4, 0.6, 0.8, 0.2, 0.3, 0.4, 0.7]);\n * const accuracy = tf.metrics.binaryAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth.\n * @param yPred Binary Tensor of prediction.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function binaryAccuracy(yTrue: Tensor, yPred: Tensor): Tensor {\n  return metrics.binaryAccuracy(yTrue, yPred);\n}\n\n/**\n * Binary crossentropy metric function.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d([[0], [1], [1], [1]]);\n * const y = tf.tensor2d([[0], [0], [0.5], [1]]);\n * const crossentropy = tf.metrics.binaryCrossentropy(x, y);\n * crossentropy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth.\n * @param yPred Binary Tensor of prediction, probabilities for the `1` case.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function binaryCrossentropy(yTrue: Tensor, yPred: Tensor): Tensor {\n  return metrics.binaryCrossentropy(yTrue, yPred);\n}\n\n/**\n * Sparse categorical accuracy metric function.\n *\n * Example:\n * ```js\n *\n * const yTrue = tf.tensor1d([1, 1, 2, 2, 0]);\n * const yPred = tf.tensor2d(\n *      [[0, 1, 0], [1, 0, 0], [0, 0.4, 0.6], [0, 0.6, 0.4], [0.7, 0.3, 0]]);\n * const crossentropy = tf.metrics.sparseCategoricalAccuracy(yTrue, yPred);\n * crossentropy.print();\n * ```\n *\n * @param yTrue True labels: indices.\n * @param yPred Predicted probabilities or logits.\n * @returns Accuracy tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function sparseCategoricalAccuracy(\n    yTrue: Tensor, yPred: Tensor): Tensor {\n  return metrics.sparseCategoricalAccuracy(yTrue, yPred);\n}\n\n/**\n * Categorical accuracy metric function.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d([[0, 0, 0, 1], [0, 0, 0, 1]]);\n * const y = tf.tensor2d([[0.1, 0.8, 0.05, 0.05], [0.1, 0.05, 0.05, 0.8]]);\n * const accuracy = tf.metrics.categoricalAccuracy(x, y);\n * accuracy.print();\n * ```\n *\n * @param yTrue Binary Tensor of truth: one-hot encoding of categories.\n * @param yPred Binary Tensor of prediction: probabilities or logits for the\n *   same categories as in `yTrue`.\n * @return Accuracy Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function categoricalAccuracy(yTrue: Tensor, yPred: Tensor): Tensor {\n  return metrics.categoricalAccuracy(yTrue, yPred);\n}\n\n/**\n * Categorical crossentropy between an output tensor and a target tensor.\n *\n * @param target A tensor of the same shape as `output`.\n * @param output A tensor resulting from a softmax (unless `fromLogits` is\n *  `true`, in which case `output` is expected to be the logits).\n * @param fromLogits Boolean, whether `output` is the result of a softmax, or is\n *   a tensor of logits.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function categoricalCrossentropy(yTrue: Tensor, yPred: Tensor): Tensor {\n  return metrics.categoricalCrossentropy(yTrue, yPred);\n}\n\n/**\n * Computes the precision of the predictions with respect to the labels.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d(\n *    [\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [1, 0, 0, 0],\n *      [0, 0, 1, 0]\n *    ]\n * );\n *\n * const y = tf.tensor2d(\n *    [\n *      [0, 0, 1, 0],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 1, 0, 0]\n *    ]\n * );\n *\n * const precision = tf.metrics.precision(x, y);\n * precision.print();\n * ```\n *\n * @param yTrue The ground truth values. Expected to be contain only 0-1 values.\n * @param yPred The predicted values. Expected to be contain only 0-1 values.\n * @return Precision Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function precision(yTrue: Tensor, yPred: Tensor): Tensor {\n  return metrics.precision(yTrue, yPred);\n}\n\n/**\n * Computes the recall of the predictions with respect to the labels.\n *\n * Example:\n * ```js\n * const x = tf.tensor2d(\n *    [\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [1, 0, 0, 0],\n *      [0, 0, 1, 0]\n *    ]\n * );\n *\n * const y = tf.tensor2d(\n *    [\n *      [0, 0, 1, 0],\n *      [0, 1, 0, 0],\n *      [0, 0, 0, 1],\n *      [0, 1, 0, 0],\n *      [0, 1, 0, 0]\n *    ]\n * );\n *\n * const recall = tf.metrics.recall(x, y);\n * recall.print();\n * ```\n *\n * @param yTrue The ground truth values. Expected to be contain only 0-1 values.\n * @param yPred The predicted values. Expected to be contain only 0-1 values.\n * @return Recall Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function recall(yTrue: Tensor, yPred: Tensor): Tensor {\n  return metrics.recall(yTrue, yPred);\n}\n\n/**\n * Loss or metric function: Cosine proximity.\n *\n * Mathematically, cosine proximity is defined as:\n *   `-sum(l2Normalize(yTrue) * l2Normalize(yPred))`,\n * wherein `l2Normalize()` normalizes the L2 norm of the input to 1 and `*`\n * represents element-wise multiplication.\n *\n * ```js\n * const yTrue = tf.tensor2d([[1, 0], [1, 0]]);\n * const yPred = tf.tensor2d([[1 / Math.sqrt(2), 1 / Math.sqrt(2)], [0, 1]]);\n * const proximity = tf.metrics.cosineProximity(yTrue, yPred);\n * proximity.print();\n * ```\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Cosine proximity Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function cosineProximity(yTrue: Tensor, yPred: Tensor): Tensor {\n  return losses.cosineProximity(yTrue, yPred);\n}\n\n/**\n * Loss or metric function: Mean absolute error.\n *\n * Mathematically, mean absolute error is defined as:\n *   `mean(abs(yPred - yTrue))`,\n * wherein the `mean` is applied over feature dimensions.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [0, 0], [2, 3]]);\n * const yPred = tf.tensor2d([[0, 1], [0, 1], [-2, -3]]);\n * const mse = tf.metrics.meanAbsoluteError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean absolute error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function meanAbsoluteError(yTrue: Tensor, yPred: Tensor): Tensor {\n  return losses.meanAbsoluteError(yTrue, yPred);\n}\n\n/**\n * Loss or metric function: Mean absolute percentage error.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [10, 20]]);\n * const yPred = tf.tensor2d([[0, 1], [11, 24]]);\n * const mse = tf.metrics.meanAbsolutePercentageError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * Aliases: `tf.metrics.MAPE`, `tf.metrics.mape`.\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean absolute percentage error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function meanAbsolutePercentageError(\n    yTrue: Tensor, yPred: Tensor): Tensor {\n  return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\n\nexport function MAPE(yTrue: Tensor, yPred: Tensor): Tensor {\n  return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\n\nexport function mape(yTrue: Tensor, yPred: Tensor): Tensor {\n  return losses.meanAbsolutePercentageError(yTrue, yPred);\n}\n\n/**\n * Loss or metric function: Mean squared error.\n *\n * ```js\n * const yTrue = tf.tensor2d([[0, 1], [3, 4]]);\n * const yPred = tf.tensor2d([[0, 1], [-3, -4]]);\n * const mse = tf.metrics.meanSquaredError(yTrue, yPred);\n * mse.print();\n * ```\n *\n * Aliases: `tf.metrics.MSE`, `tf.metrics.mse`.\n *\n * @param yTrue Truth Tensor.\n * @param yPred Prediction Tensor.\n * @return Mean squared error Tensor.\n *\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport function meanSquaredError(yTrue: Tensor, yPred: Tensor): Tensor {\n  return losses.meanSquaredError(yTrue, yPred);\n}\n\nexport function MSE(yTrue: Tensor, yPred: Tensor): Tensor {\n  return losses.meanSquaredError(yTrue, yPred);\n}\n\nexport function mse(yTrue: Tensor, yPred: Tensor): Tensor {\n  return losses.meanSquaredError(yTrue, yPred);\n}\n"]},"metadata":{},"sourceType":"module"}