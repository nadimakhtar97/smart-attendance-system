{"ast":null,"code":"import { convertToTensor, convertToTensorArray } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes the next states and outputs of a stack of LSTMCells.\n *\n * Each cell output is used as input to the next cell.\n *\n * Returns `[cellState, cellOutput]`.\n *\n * Derived from tf.contrib.rn.MultiRNNCell.\n *\n * @param lstmCells Array of LSTMCell functions.\n * @param data The input to the cell.\n * @param c Array of previous cell states.\n * @param h Array of previous cell outputs.\n *\n * @doc {heading: 'Operations', subheading: 'RNN'}\n */\n\nfunction multiRNNCell_(lstmCells, data, c, h) {\n  const $data = convertToTensor(data, 'data', 'multiRNNCell');\n  const $c = convertToTensorArray(c, 'c', 'multiRNNCell');\n  const $h = convertToTensorArray(h, 'h', 'multiRNNCell');\n  let input = $data;\n  const newStates = [];\n\n  for (let i = 0; i < lstmCells.length; i++) {\n    const output = lstmCells[i](input, $c[i], $h[i]);\n    newStates.push(output[0]);\n    newStates.push(output[1]);\n    input = output[1];\n  }\n\n  const newC = [];\n  const newH = [];\n\n  for (let i = 0; i < newStates.length; i += 2) {\n    newC.push(newStates[i]);\n    newH.push(newStates[i + 1]);\n  }\n\n  return [newC, newH];\n}\n\nexport const multiRNNCell = op({\n  multiRNNCell_\n});","map":{"version":3,"mappings":"AAiBA,SAAQA,eAAR,EAAyBC,oBAAzB,QAAoD,oBAApD;AAEA,SAAQC,EAAR,QAAiB,aAAjB;AASA;;;;;;;;;;;;;;;;;AAgBA,SAASC,aAAT,CACIC,SADJ,EAC+BC,IAD/B,EAEIC,CAFJ,EAGIC,CAHJ,EAGiC;AAC/B,QAAMC,KAAK,GAAGR,eAAe,CAACK,IAAD,EAAO,MAAP,EAAe,cAAf,CAA7B;AACA,QAAMI,EAAE,GAAGR,oBAAoB,CAACK,CAAD,EAAI,GAAJ,EAAS,cAAT,CAA/B;AACA,QAAMI,EAAE,GAAGT,oBAAoB,CAACM,CAAD,EAAI,GAAJ,EAAS,cAAT,CAA/B;AAEA,MAAII,KAAK,GAAGH,KAAZ;AACA,QAAMI,SAAS,GAAG,EAAlB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,SAAS,CAACU,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACzC,UAAME,MAAM,GAAGX,SAAS,CAACS,CAAD,CAAT,CAAaF,KAAb,EAAoBF,EAAE,CAACI,CAAD,CAAtB,EAA2BH,EAAE,CAACG,CAAD,CAA7B,CAAf;AACAD,aAAS,CAACI,IAAV,CAAeD,MAAM,CAAC,CAAD,CAArB;AACAH,aAAS,CAACI,IAAV,CAAeD,MAAM,CAAC,CAAD,CAArB;AACAJ,SAAK,GAAGI,MAAM,CAAC,CAAD,CAAd;AACD;;AACD,QAAME,IAAI,GAAe,EAAzB;AACA,QAAMC,IAAI,GAAe,EAAzB;;AACA,OAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,SAAS,CAACE,MAA9B,EAAsCD,CAAC,IAAI,CAA3C,EAA8C;AAC5CI,QAAI,CAACD,IAAL,CAAUJ,SAAS,CAACC,CAAD,CAAnB;AACAK,QAAI,CAACF,IAAL,CAAUJ,SAAS,CAACC,CAAC,GAAG,CAAL,CAAnB;AACD;;AACD,SAAO,CAACI,IAAD,EAAOC,IAAP,CAAP;AACD;;AACD,OAAO,MAAMC,YAAY,GAAGjB,EAAE,CAAC;AAACC;AAAD,CAAD,CAAvB","names":["convertToTensor","convertToTensorArray","op","multiRNNCell_","lstmCells","data","c","h","$data","$c","$h","input","newStates","i","length","output","push","newC","newH","multiRNNCell"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/ops/multi_rnn_cell.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor2D} from '../tensor';\nimport {convertToTensor, convertToTensorArray} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * @docalias (data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D]\n */\nexport type LSTMCellFunc = {\n  (data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D];\n};\n\n/**\n * Computes the next states and outputs of a stack of LSTMCells.\n *\n * Each cell output is used as input to the next cell.\n *\n * Returns `[cellState, cellOutput]`.\n *\n * Derived from tf.contrib.rn.MultiRNNCell.\n *\n * @param lstmCells Array of LSTMCell functions.\n * @param data The input to the cell.\n * @param c Array of previous cell states.\n * @param h Array of previous cell outputs.\n *\n * @doc {heading: 'Operations', subheading: 'RNN'}\n */\nfunction multiRNNCell_(\n    lstmCells: LSTMCellFunc[], data: Tensor2D|TensorLike,\n    c: Array<Tensor2D|TensorLike>,\n    h: Array<Tensor2D|TensorLike>): [Tensor2D[], Tensor2D[]] {\n  const $data = convertToTensor(data, 'data', 'multiRNNCell');\n  const $c = convertToTensorArray(c, 'c', 'multiRNNCell');\n  const $h = convertToTensorArray(h, 'h', 'multiRNNCell');\n\n  let input = $data;\n  const newStates = [];\n  for (let i = 0; i < lstmCells.length; i++) {\n    const output = lstmCells[i](input, $c[i], $h[i]);\n    newStates.push(output[0]);\n    newStates.push(output[1]);\n    input = output[1];\n  }\n  const newC: Tensor2D[] = [];\n  const newH: Tensor2D[] = [];\n  for (let i = 0; i < newStates.length; i += 2) {\n    newC.push(newStates[i]);\n    newH.push(newStates[i + 1]);\n  }\n  return [newC, newH];\n}\nexport const multiRNNCell = op({multiRNNCell_});\n"]},"metadata":{},"sourceType":"module"}