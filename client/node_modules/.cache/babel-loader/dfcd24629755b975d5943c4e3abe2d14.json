{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer, CropAndResize, util } from '@tensorflow/tfjs-core';\nexport function cropAndResize(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    image,\n    boxes,\n    boxInd\n  } = inputs;\n  const {\n    cropSize,\n    method,\n    extrapolationValue\n  } = attrs;\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const numBoxes = boxes.shape[0];\n  const [cropHeight, cropWidth] = cropSize;\n  const output = buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n  const boxVals = backend.data.get(boxes.dataId).values;\n  const boxIndVals = backend.data.get(boxInd.dataId).values;\n  const imageVals = backend.data.get(image.dataId).values;\n  const inStride = util.computeStrides(image.shape); // to calculate flat indexes into image\n\n  const outStride = util.computeStrides(output.shape); // to calculate flat indexes into output\n  // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n\n  for (let b = 0; b < numBoxes; b++) {\n    const startInd = b * 4;\n    const y1 = boxVals[startInd];\n    const x1 = boxVals[startInd + 1];\n    const y2 = boxVals[startInd + 2];\n    const x2 = boxVals[startInd + 3];\n    const bInd = boxIndVals[b];\n\n    if (bInd >= batch) {\n      continue;\n    }\n\n    const heightScale = cropHeight > 1 ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;\n    const widthScale = cropWidth > 1 ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n\n    for (let y = 0; y < cropHeight; y++) {\n      const yInd = cropHeight > 1 ? y1 * (imageHeight - 1) + y * heightScale : 0.5 * (y1 + y2) * (imageHeight - 1);\n\n      if (yInd < 0 || yInd > imageHeight - 1) {\n        for (let x = 0; x < cropWidth; x++) {\n          for (let c = 0; c < numChannels; c++) {\n            const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[ind] = extrapolationValue;\n          }\n        }\n\n        continue;\n      }\n\n      if (method === 'bilinear') {\n        const topInd = Math.floor(yInd);\n        const bottomInd = Math.ceil(yInd);\n        const yLerp = yInd - topInd;\n\n        for (let x = 0; x < cropWidth; x++) {\n          const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);\n\n          if (xInd < 0 || xInd > imageWidth - 1) {\n            for (let c = 0; c < numChannels; c++) {\n              const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[ind] = extrapolationValue;\n            }\n\n            continue;\n          }\n\n          const leftInd = Math.floor(xInd);\n          const rightInd = Math.ceil(xInd);\n          const xLerp = xInd - leftInd;\n\n          for (let c = 0; c < numChannels; c++) {\n            let ind = c + leftInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];\n            const topLeft = imageVals[ind];\n            ind = c + rightInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];\n            const topRight = imageVals[ind];\n            ind = c + leftInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];\n            const bottomLeft = imageVals[ind];\n            ind = c + rightInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];\n            const bottomRight = imageVals[ind];\n            const top = topLeft + (topRight - topLeft) * xLerp;\n            const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n            ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[ind] = top + (bottom - top) * yLerp;\n          }\n        }\n      } else {\n        // method == \"nearest\"\n        for (let x = 0; x < cropWidth; ++x) {\n          const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);\n\n          if (xInd < 0 || xInd > imageWidth - 1) {\n            for (let c = 0; c < numChannels; c++) {\n              const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[ind] = extrapolationValue;\n            }\n\n            continue;\n          }\n\n          const closestX = Math.round(xInd);\n          const closestY = Math.round(yInd);\n\n          for (let c = 0; c < numChannels; c++) {\n            const inInd = c + closestX * inStride[2] + closestY * inStride[1] + bInd * inStride[0];\n            const outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[outInd] = imageVals[inInd];\n          }\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(output.shape, output.dtype, output.values);\n}\nexport const cropAndResizeConfig = {\n  kernelName: CropAndResize,\n  backendName: 'cpu',\n  kernelFunc: cropAndResize\n};","map":{"version":3,"mappings":"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","names":["buffer","CropAndResize","util","cropAndResize","args","inputs","backend","attrs","image","boxes","boxInd","cropSize","method","extrapolationValue","batch","imageHeight","imageWidth","numChannels","shape","numBoxes","cropHeight","cropWidth","output","boxVals","data","get","dataId","values","boxIndVals","imageVals","inStride","computeStrides","outStride","b","startInd","y1","x1","y2","x2","bInd","heightScale","widthScale","y","yInd","x","c","ind","topInd","Math","floor","bottomInd","ceil","yLerp","xInd","leftInd","rightInd","xLerp","topLeft","topRight","bottomLeft","bottomRight","top","bottom","closestX","round","closestY","inInd","outInd","makeTensorInfo","dtype","cropAndResizeConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/CropAndResize.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, CropAndResize, CropAndResizeAttrs, CropAndResizeInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function cropAndResize(args: {\n  inputs: CropAndResizeInputs,\n  backend: MathBackendCPU,\n  attrs: CropAndResizeAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {image, boxes, boxInd} = inputs;\n  const {cropSize, method, extrapolationValue} = attrs;\n\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const numBoxes = boxes.shape[0];\n\n  const [cropHeight, cropWidth] = cropSize;\n  const output =\n      buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n\n  const boxVals = backend.data.get(boxes.dataId).values as TypedArray;\n  const boxIndVals = backend.data.get(boxInd.dataId).values as TypedArray;\n  const imageVals = backend.data.get(image.dataId).values as TypedArray;\n\n  const inStride =\n      util.computeStrides(image.shape);  // to calculate flat indexes into image\n  const outStride = util.computeStrides(\n      output.shape);  // to calculate flat indexes into output\n\n  // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n  for (let b = 0; b < numBoxes; b++) {\n    const startInd = b * 4;\n    const y1 = boxVals[startInd];\n    const x1 = boxVals[startInd + 1];\n    const y2 = boxVals[startInd + 2];\n    const x2 = boxVals[startInd + 3];\n\n    const bInd: number = boxIndVals[b];\n    if (bInd >= batch) {\n      continue;\n    }\n\n    const heightScale =\n        (cropHeight > 1) ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;\n    const widthScale =\n        (cropWidth > 1) ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n\n    for (let y = 0; y < cropHeight; y++) {\n      const yInd: number = (cropHeight > 1) ?\n          y1 * (imageHeight - 1) + y * (heightScale) :\n          0.5 * (y1 + y2) * (imageHeight - 1);\n\n      if (yInd < 0 || yInd > imageHeight - 1) {\n        for (let x = 0; x < cropWidth; x++) {\n          for (let c = 0; c < numChannels; c++) {\n            const ind =\n                c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[ind] = extrapolationValue;\n          }\n        }\n        continue;\n      }\n\n      if (method === 'bilinear') {\n        const topInd = Math.floor(yInd);\n        const bottomInd = Math.ceil(yInd);\n        const yLerp = yInd - topInd;\n\n        for (let x = 0; x < cropWidth; x++) {\n          const xInd = (cropWidth > 1) ?\n              x1 * (imageWidth - 1) + x * widthScale :\n              0.5 * (x1 + x2) * (imageWidth - 1);\n\n          if (xInd < 0 || xInd > imageWidth - 1) {\n            for (let c = 0; c < numChannels; c++) {\n              const ind =\n                  c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[ind] = extrapolationValue;\n            }\n            continue;\n          }\n\n          const leftInd = Math.floor(xInd);\n          const rightInd = Math.ceil(xInd);\n          const xLerp = xInd - leftInd;\n\n          for (let c = 0; c < numChannels; c++) {\n            let ind = c + leftInd * inStride[2] + topInd * inStride[1] +\n                bInd * inStride[0];\n            const topLeft = imageVals[ind];\n\n            ind = c + rightInd * inStride[2] + topInd * inStride[1] +\n                bInd * inStride[0];\n            const topRight = imageVals[ind];\n\n            ind = c + leftInd * inStride[2] + bottomInd * inStride[1] +\n                bInd * inStride[0];\n            const bottomLeft = imageVals[ind];\n\n            ind = c + rightInd * inStride[2] + bottomInd * inStride[1] +\n                bInd * inStride[0];\n            const bottomRight = imageVals[ind];\n\n            const top = topLeft + (topRight - topLeft) * xLerp;\n            const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n\n            ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[ind] = top + ((bottom - top) * yLerp);\n          }\n        }\n      } else {  // method == \"nearest\"\n        for (let x = 0; x < cropWidth; ++x) {\n          const xInd = (cropWidth > 1) ?\n              x1 * (imageWidth - 1) + x * widthScale :\n              0.5 * (x1 + x2) * (imageWidth - 1);\n\n          if (xInd < 0 || xInd > imageWidth - 1) {\n            for (let c = 0; c < numChannels; c++) {\n              const ind =\n                  c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[ind] = extrapolationValue;\n            }\n            continue;\n          }\n\n          const closestX = Math.round(xInd);\n          const closestY = Math.round(yInd);\n          for (let c = 0; c < numChannels; c++) {\n            const inInd = c + closestX * inStride[2] + closestY * inStride[1] +\n                bInd * inStride[0];\n            const outInd =\n                c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n            output.values[outInd] = imageVals[inInd];\n          }\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(output.shape, output.dtype, output.values);\n}\n\nexport const cropAndResizeConfig: KernelConfig = {\n  kernelName: CropAndResize,\n  backendName: 'cpu',\n  kernelFunc: cropAndResize as {} as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module"}