{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Gets the new shape of the input Tensor after it's been reshaped\n * to:\n * [blockShape[0], ..., blockShape[M-1], batch / prod(blockShape),\n * inputShape[1], ..., inputShape[N-1]]\n *\n * See step 1: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshaped(inputShape, blockShape, prod) {\n  let batchToSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  let reshaped = [];\n\n  if (batchToSpace) {\n    reshaped = reshaped.concat(blockShape.slice(0));\n    reshaped.push(inputShape[0] / prod);\n    reshaped = reshaped.concat(inputShape.slice(1));\n  } else {\n    reshaped = reshaped.concat(inputShape[0]);\n    const spatialLength = blockShape.length;\n\n    for (let i = 0; i < spatialLength; ++i) {\n      reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);\n    }\n\n    reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));\n  }\n\n  return reshaped;\n}\n/**\n * Gets the permutation that will transpose the dimensions of the\n * reshaped tensor to shape:\n *\n * [batch / prod(block_shape),inputShape[1], blockShape[0], ...,\n * inputShape[M], blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * see step 2: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\n\nexport function getPermuted(reshapedRank, blockShapeRank) {\n  let batchToSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const permuted = [];\n\n  if (batchToSpace) {\n    permuted.push(blockShapeRank);\n\n    for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {\n      if (i <= 2 * blockShapeRank) {\n        permuted.push(i);\n        permuted.push(i - (blockShapeRank + 1));\n      } else {\n        permuted.push(i);\n      }\n    }\n  } else {\n    const permutedBeforeBatch = [];\n    const permutedAfterBatch = [];\n\n    for (let i = 1; i < reshapedRank; ++i) {\n      if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {\n        permutedAfterBatch.push(i);\n      } else {\n        permutedBeforeBatch.push(i);\n      }\n    }\n\n    permuted.push(...permutedBeforeBatch);\n    permuted.push(0);\n    permuted.push(...permutedAfterBatch);\n  }\n\n  return permuted;\n}\n/**\n * Gets the shape of the reshaped and permuted input Tensor before any cropping\n * is applied.  The new shape will be:\n *\n * [batch / prod(blockShape),inputShape[1] * blockShape[0], ...,\n * inputShape[M] * blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 3: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\n\nexport function getReshapedPermuted(inputShape, blockShape, prod) {\n  let batchToSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  const reshapedPermuted = [];\n\n  if (batchToSpace) {\n    reshapedPermuted.push(inputShape[0] / prod);\n  } else {\n    reshapedPermuted.push(inputShape[0] * prod);\n  }\n\n  for (let i = 1; i < inputShape.length; ++i) {\n    if (i <= blockShape.length) {\n      if (batchToSpace) {\n        reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);\n      } else {\n        reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);\n      }\n    } else {\n      reshapedPermuted.push(inputShape[i]);\n    }\n  }\n\n  return reshapedPermuted;\n}\n/**\n * Converts the crops argument into the beginning coordinates of a slice\n * operation.\n */\n\nexport function getSliceBeginCoords(crops, blockShape) {\n  const sliceBeginCoords = [0];\n\n  for (let i = 0; i < blockShape; ++i) {\n    sliceBeginCoords.push(crops[i][0]);\n  }\n\n  return sliceBeginCoords;\n}\n/**\n * Converts the crops argument into the size of a slice operation.  When\n * combined with getSliceBeginCoords this function allows the reshaped and\n * permuted Tensor to be cropped to its final output shape of:\n *\n * inputShape[1] * blockShape[0] - crops[0,0] - crops[0,1], ...,\n * inputShape[M] * blockShape[M-1] -crops[M-1,0] -\n * crops[M-1,1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 4: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\n\nexport function getSliceSize(uncroppedShape, crops, blockShape) {\n  const sliceSize = uncroppedShape.slice(0, 1);\n\n  for (let i = 0; i < blockShape; ++i) {\n    sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);\n  }\n\n  return sliceSize;\n}","map":{"version":3,"mappings":"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","names":["getReshaped","inputShape","blockShape","prod","batchToSpace","reshaped","concat","slice","push","spatialLength","length","i","getPermuted","reshapedRank","blockShapeRank","permuted","permutedBeforeBatch","permutedAfterBatch","getReshapedPermuted","reshapedPermuted","getSliceBeginCoords","crops","sliceBeginCoords","getSliceSize","uncroppedShape","sliceSize"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/ops/array_ops_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Gets the new shape of the input Tensor after it's been reshaped\n * to:\n * [blockShape[0], ..., blockShape[M-1], batch / prod(blockShape),\n * inputShape[1], ..., inputShape[N-1]]\n *\n * See step 1: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshaped(\n    inputShape: number[], blockShape: number[], prod: number,\n    batchToSpace = true): number[] {\n  let reshaped: number[] = [];\n  if (batchToSpace) {\n    reshaped = reshaped.concat(blockShape.slice(0));\n    reshaped.push(inputShape[0] / prod);\n    reshaped = reshaped.concat(inputShape.slice(1));\n  } else {\n    reshaped = reshaped.concat(inputShape[0]);\n    const spatialLength = blockShape.length;\n    for (let i = 0; i < spatialLength; ++i) {\n      reshaped =\n          reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);\n    }\n    reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));\n  }\n  return reshaped;\n}\n\n/**\n * Gets the permutation that will transpose the dimensions of the\n * reshaped tensor to shape:\n *\n * [batch / prod(block_shape),inputShape[1], blockShape[0], ...,\n * inputShape[M], blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * see step 2: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getPermuted(\n    reshapedRank: number, blockShapeRank: number,\n    batchToSpace = true): number[] {\n  const permuted = [];\n  if (batchToSpace) {\n    permuted.push(blockShapeRank);\n    for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {\n      if (i <= 2 * blockShapeRank) {\n        permuted.push(i);\n        permuted.push(i - (blockShapeRank + 1));\n      } else {\n        permuted.push(i);\n      }\n    }\n  } else {\n    const permutedBeforeBatch = [];\n    const permutedAfterBatch = [];\n    for (let i = 1; i < reshapedRank; ++i) {\n      if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {\n        permutedAfterBatch.push(i);\n      } else {\n        permutedBeforeBatch.push(i);\n      }\n    }\n    permuted.push(...permutedBeforeBatch);\n    permuted.push(0);\n    permuted.push(...permutedAfterBatch);\n  }\n  return permuted;\n}\n\n/**\n * Gets the shape of the reshaped and permuted input Tensor before any cropping\n * is applied.  The new shape will be:\n *\n * [batch / prod(blockShape),inputShape[1] * blockShape[0], ...,\n * inputShape[M] * blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 3: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshapedPermuted(\n    inputShape: number[], blockShape: number[], prod: number,\n    batchToSpace = true): number[] {\n  const reshapedPermuted = [];\n\n  if (batchToSpace) {\n    reshapedPermuted.push(inputShape[0] / prod);\n  } else {\n    reshapedPermuted.push(inputShape[0] * prod);\n  }\n\n  for (let i = 1; i < inputShape.length; ++i) {\n    if (i <= blockShape.length) {\n      if (batchToSpace) {\n        reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);\n      } else {\n        reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);\n      }\n    } else {\n      reshapedPermuted.push(inputShape[i]);\n    }\n  }\n\n  return reshapedPermuted;\n}\n\n/**\n * Converts the crops argument into the beginning coordinates of a slice\n * operation.\n */\nexport function getSliceBeginCoords(\n    crops: number[][], blockShape: number): number[] {\n  const sliceBeginCoords = [0];\n  for (let i = 0; i < blockShape; ++i) {\n    sliceBeginCoords.push(crops[i][0]);\n  }\n  return sliceBeginCoords;\n}\n\n/**\n * Converts the crops argument into the size of a slice operation.  When\n * combined with getSliceBeginCoords this function allows the reshaped and\n * permuted Tensor to be cropped to its final output shape of:\n *\n * inputShape[1] * blockShape[0] - crops[0,0] - crops[0,1], ...,\n * inputShape[M] * blockShape[M-1] -crops[M-1,0] -\n * crops[M-1,1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 4: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getSliceSize(\n    uncroppedShape: number[], crops: number[][], blockShape: number): number[] {\n  const sliceSize = uncroppedShape.slice(0, 1);\n  for (let i = 0; i < blockShape; ++i) {\n    sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);\n  }\n\n  return sliceSize;\n}\n"]},"metadata":{},"sourceType":"module"}