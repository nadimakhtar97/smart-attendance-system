{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Merge Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy, util } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { l2Normalize } from '../losses';\nimport * as generic_utils from '../utils/generic_utils';\nimport * as mathUtils from '../utils/math_utils';\nimport { getExactlyOneShape } from '../utils/types_utils';\n/**\n * Generic Merge layer for element-wise merge functions.\n *\n * Used to implement `Sum`, `Average`, `Concatenate`, etc.\n */\n\nexport class Merge extends Layer {\n  constructor(args) {\n    super(args || {});\n    this.supportsMasking = true;\n  }\n  /**\n   * Logic for merging multiple tensors, to be overridden by subclasses.\n   * @param inputs\n   */\n\n\n  mergeFunction(inputs) {\n    throw new NotImplementedError();\n  }\n  /**\n   * Computes the shape of the result of an elementwise operation.\n   *\n   * @param shape1: Shape of the first tensor.\n   * @param shape2: Shape of the second tensor.\n   * @returns Expected output shape when an elementwise operation is carried\n   *   out on 2 tensors with shapes `shape1` and `shape2`.\n   * @throws ValueError: If `shape1` and `shape2` are not compatible for\n   *   element-wise operations.\n   */\n\n\n  computeElementwiseOpOutputShape(shape1, shape2) {\n    if (shape1 == null || shape2 == null) {\n      return null;\n    } else if (shape1.length < shape2.length) {\n      return this.computeElementwiseOpOutputShape(shape2, shape1);\n    } else if (shape2.length === 0) {\n      return shape1;\n    }\n\n    const outputShape = shape1.slice(0, shape1.length - shape2.length);\n\n    for (let k = 0; k < shape2.length; ++k) {\n      const i = shape1[shape1.length - shape2.length + k];\n      const j = shape2[k];\n\n      if (i == null || j == null || i < 0 || j < 0) {\n        outputShape.push(null);\n      } else if (i === 1) {\n        outputShape.push(j);\n      } else if (j === 1) {\n        outputShape.push(i);\n      } else {\n        if (i !== j) {\n          throw new ValueError('Operands could not be broadcast together with shapes ' + JSON.stringify(shape1) + ' ' + JSON.stringify(shape2));\n        }\n\n        outputShape.push(i);\n      }\n    }\n\n    return outputShape;\n  }\n\n  build(inputShape) {\n    // Used purely for shape validation.\n    if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {\n      // Make sure that inputShape is an Array of shape.\n      inputShape = [getExactlyOneShape(inputShape)];\n    }\n\n    inputShape = inputShape;\n\n    if (inputShape.length < 2) {\n      throw new ValueError('A merge layer should be called on an Array of at least 2 inputs.' + ` Got ${inputShape.length} input(s).`);\n    } // Make sure that there is at most one unique batch size among the input\n    // shapes.\n\n\n    let batchSizes = [];\n\n    for (const shape of inputShape) {\n      if (shape != null && shape[0] !== null) {\n        batchSizes.push(shape[0]);\n      }\n    }\n\n    batchSizes = generic_utils.unique(batchSizes);\n\n    if (batchSizes.length > 1) {\n      throw new ValueError(`Can not merge tensors with different batch sizes. ` + `Got tensors with shapes: ${JSON.stringify(inputShape)}.`);\n    }\n\n    let outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);\n\n    for (let i = 1; i < inputShape.length; ++i) {\n      const shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n      outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n    } // If the inputs have different ranks, we have to reshape them to make them\n    // broadcastable.\n\n\n    const allRanks = inputShape.map(shape => shape.length);\n\n    if (inputShape.indexOf(null) === -1 && generic_utils.unique(allRanks).length === 1) {\n      this.reshapeRequired = false;\n    } else {\n      this.reshapeRequired = true;\n    }\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      inputs = inputs;\n\n      if (this.reshapeRequired) {\n        const reshapedInputs = [];\n        const inputDims = inputs.map(input => input.rank);\n\n        if (inputDims.indexOf(null) === -1) {\n          // If ranks of all inputs are available, we simply expand each of them\n          // at axis=1 until all of them have the same rank.\n          const maxNDim = mathUtils.max(inputDims);\n\n          for (let x of inputs) {\n            const xNDim = x.rank;\n\n            for (let k = 0; k < maxNDim - xNDim; ++k) {\n              x = K.expandDims(x, 1);\n            }\n\n            reshapedInputs.push(x);\n          }\n\n          return this.mergeFunction(reshapedInputs);\n        } else {\n          // Transpose all inputs so that batch size is the last dimension.\n          // [batchSize, dim1, dim2, ...] -> [dim1, dim2, ..., batchSize]\n          let transposed = false;\n\n          for (const x of inputs) {\n            const xNDim = x.rank;\n\n            if (xNDim == null) {\n              const xShape = x.shape;\n              const batchSize = xShape[0];\n              const newShape = xShape.slice(1).concat([batchSize]);\n              let xTransposed = tfc.reshape(x, [batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));\n              xTransposed = tfc.transpose(xTransposed, [1, 0]);\n              xTransposed = tfc.reshape(xTransposed, newShape);\n              reshapedInputs.push(xTransposed);\n              transposed = true;\n            } else if (xNDim > 1) {\n              const dims = mathUtils.range(1, xNDim).concat([0]);\n              reshapedInputs.push(tfc.transpose(x, dims));\n              transposed = true;\n            } else {\n              // We don't transpose inputs if they are 1D vectors or scalars.\n              reshapedInputs.push(x);\n            }\n          }\n\n          let y = this.mergeFunction(reshapedInputs);\n          const yNDim = y.rank;\n\n          if (transposed) {\n            // If inputs have been transposed, we have to transpose the output\n            // too.\n            if (yNDim == null) {\n              const yShape = y.shape;\n              const yNDim = yShape.length;\n              const batchSize = yShape[yNDim - 1];\n              const newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));\n              y = tfc.reshape(tfc.transpose(tfc.reshape(y, [-1, batchSize]), [1, 0]), newShape);\n            } else if (yNDim > 1) {\n              const dims = [yNDim - 1].concat(mathUtils.range(0, yNDim - 1));\n              y = tfc.transpose(y, dims);\n            }\n          }\n\n          return y;\n        }\n      } else {\n        return this.mergeFunction(inputs);\n      }\n    });\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = inputShape;\n    let outputShape;\n\n    if (inputShape[0] == null) {\n      outputShape = null;\n    } else {\n      outputShape = inputShape[0].slice(1);\n    }\n\n    for (let i = 1; i < inputShape.length; ++i) {\n      const shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n      outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n    }\n\n    let batchSizes = [];\n\n    for (const shape of inputShape) {\n      if (shape != null && shape[0] !== null) {\n        batchSizes.push(shape[0]);\n      }\n    }\n\n    batchSizes = generic_utils.unique(batchSizes);\n\n    if (batchSizes.length === 1) {\n      outputShape = batchSizes.concat(outputShape);\n    } else {\n      outputShape = [null].concat(outputShape);\n    }\n\n    return outputShape;\n  }\n\n  computeMask(inputs, mask) {\n    return tfc.tidy(() => {\n      if (mask == null) {\n        return null;\n      }\n\n      if (!Array.isArray(mask)) {\n        throw new ValueError('`mask` should be an Array');\n      }\n\n      if (!Array.isArray(inputs)) {\n        throw new ValueError('`inputs` should be an Array');\n      }\n\n      if (mask.length !== inputs.length) {\n        throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same ` + `length, but have different lengths ` + `(${inputs.length} vs ${mask.length})`);\n      }\n\n      if (mask.every(m => m == null)) {\n        return null;\n      }\n\n      mask = mask.map(m => m == null ? m : tfc.expandDims(m, 0));\n      let output = mask[0];\n\n      for (let i = 1; i < mask.length - 1; ++i) {\n        output = tfc.logicalAnd(output, mask[i]);\n      }\n\n      return output;\n    });\n  }\n\n}\nexport class Add extends Merge {\n  constructor(args) {\n    super(args);\n  }\n\n  mergeFunction(inputs) {\n    return tidy(() => {\n      let output = inputs[0].clone();\n\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.add(output, inputs[i]);\n      }\n\n      return output;\n    });\n  }\n\n}\n/** @nocollapse */\n\nAdd.className = 'Add';\nserialization.registerClass(Add);\n/**\n * Calculate the element-wise sum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Add` layer, by using no input argument\n *    or a single configuration argument. The resultant `Add` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const addLayer = tf.layers.add();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = addLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.add([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.add([input1, input2]).print();\n * // Gives [[11, 22], [33, 44]].\n *\n */\n\nexport function add(config) {\n  if (Array.isArray(config)) {\n    const layer = new Add({});\n    return layer.apply(config);\n  } else {\n    return new Add(config);\n  }\n}\nexport class Multiply extends Merge {\n  constructor(args) {\n    super(args);\n  }\n\n  mergeFunction(inputs) {\n    return tidy(() => {\n      let output = inputs[0].clone();\n\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.mul(output, inputs[i]);\n      }\n\n      return output;\n    });\n  }\n\n}\n/** @nocollapse */\n\nMultiply.className = 'Multiply';\nserialization.registerClass(Multiply);\n/**\n * Calculate the element-wise product of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Multiply` layer, by using no input argument\n *    or a single configuration argument. The resultant `Multiply` layer can\n *    then be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const multiplyLayer = tf.layers.multiply();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = multiplyLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.multiply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.multiply([input1, input2]).print();\n * // Gives [[10, 40], [90, 160]].\n *\n */\n\nexport function multiply(config) {\n  if (Array.isArray(config)) {\n    const layer = new Multiply({});\n    return layer.apply(config);\n  } else {\n    return new Multiply(config);\n  }\n}\nexport class Average extends Merge {\n  constructor(args) {\n    super(args);\n  }\n\n  mergeFunction(inputs) {\n    return tidy(() => {\n      let output = inputs[0].clone();\n\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.add(output, inputs[i]);\n      }\n\n      return tfc.mul(1 / inputs.length, output);\n    });\n  }\n\n}\n/** @nocollapse */\n\nAverage.className = 'Average';\nserialization.registerClass(Average);\n/**\n * Calculate the element-wise arithmetic mean of inputs, which all have the same\n * shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Average` layer, by using no input argument\n *    or a single configuration argument. The resultant `Average` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const averageLayer = tf.layers.average();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = averageLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.average([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.average([input1, input2]).print();\n * // Gives [[5.5, 11], [16.5, 22]].\n *\n */\n\nexport function average(config) {\n  if (Array.isArray(config)) {\n    const layer = new Average({});\n    return layer.apply(config);\n  } else {\n    return new Average(config);\n  }\n}\nexport class Maximum extends Merge {\n  constructor(args) {\n    super(args);\n  }\n\n  mergeFunction(inputs) {\n    return tidy(() => {\n      let output = inputs[0];\n\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.maximum(output, inputs[i]);\n      }\n\n      return output;\n    });\n  }\n\n}\n/** @nocollapse */\n\nMaximum.className = 'Maximum';\nserialization.registerClass(Maximum);\n/**\n * Calculate the element-wise maximum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Maximum` layer, by using no input argument\n *    or a single configuration argument. The resultant `Maximum` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const maximumLayer = tf.layers.maximum();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = maximumLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.maximum([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 20, 3, 40], [2, 2]);\n * const input2 = tf.tensor2d([10, 2, 30, 4], [2, 2]);\n * tf.layers.maximum([input1, input2]).print();\n * // Gives [[10, 20], [30, 40]].\n *\n */\n\nexport function maximum(config) {\n  if (Array.isArray(config)) {\n    const layer = new Maximum({});\n    return layer.apply(config);\n  } else {\n    return new Maximum(config);\n  }\n}\nexport class Minimum extends Merge {\n  constructor(args) {\n    super(args);\n  }\n\n  mergeFunction(inputs) {\n    return tidy(() => {\n      let output = inputs[0];\n\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.minimum(output, inputs[i]);\n      }\n\n      return output;\n    });\n  }\n\n}\n/** @nocollapse */\n\nMinimum.className = 'Minimum';\nserialization.registerClass(Minimum);\n/**\n * Calculate the element-wise minimum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Minimum` layer, by using no input argument\n *    or a single configuration argument. The resultant `Minimum` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const minimumLayer = tf.layers.minimum();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = minimumLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.minimum([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 20, 3, 40], [2, 2]);\n * const input2 = tf.tensor2d([10, 2, 30, 4], [2, 2]);\n * tf.layers.minimum([input1, input2]).print();\n * // Gives [[1, 2], [3, 4]].\n *\n */\n\nexport function minimum(config) {\n  if (Array.isArray(config)) {\n    const layer = new Minimum({});\n    return layer.apply(config);\n  } else {\n    return new Minimum(config);\n  }\n}\nexport class Concatenate extends Merge {\n  constructor(args) {\n    super(args);\n    this.DEFAULT_AXIS = -1;\n\n    if (args == null) {\n      args = {};\n    }\n\n    this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;\n    this.supportsMasking = true;\n    this.reshapeRequired = false;\n  }\n\n  build(inputShape) {\n    // Used purely for shape validation.]\n    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) || inputShape.length === 1) {\n      throw new ValueError('A `Concatenate` layer should be called on a list of at least 2 ' + 'inputs');\n    }\n\n    inputShape = inputShape;\n    let allNoneShape = true;\n\n    for (const shape of inputShape) {\n      if (shape != null) {\n        allNoneShape = false;\n        break;\n      }\n    }\n\n    if (allNoneShape) {\n      return;\n    }\n\n    const shapeSet = [];\n\n    for (let i = 0; i < inputShape.length; ++i) {\n      const shapeWithoutConcatAxis = inputShape[i].slice();\n      shapeWithoutConcatAxis.splice(this.axis, 1);\n      let exists = false;\n\n      for (const shape of shapeSet) {\n        if (util.arraysEqual(shape, shapeWithoutConcatAxis)) {\n          exists = true;\n          break;\n        }\n      }\n\n      if (!exists) {\n        shapeSet.push(shapeWithoutConcatAxis);\n      }\n    }\n\n    if (shapeSet.length > 1) {\n      throw new ValueError('A `Concatenate` layer requires inputs with matching shapes ' + 'except for the concat axis. Got input shapes: ' + JSON.stringify(inputShape));\n    }\n  }\n\n  mergeFunction(inputs) {\n    return tidy(() => {\n      return K.concatenate(inputs, this.axis);\n    });\n  }\n\n  computeOutputShape(inputShape) {\n    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {\n      throw new ValueError('A `Concatenate` layer should be called on a list of inputs.');\n    }\n\n    const inputShapes = inputShape;\n    const outputShape = inputShapes[0].slice();\n    const axis = this.axis < 0 ? outputShape.length + this.axis : this.axis; // Porting Note: the line above is because TypeScript doesn't support\n    //   negative indices.\n\n    for (const shape of inputShapes.slice(1)) {\n      if (outputShape[axis] == null || shape[axis] == null) {\n        outputShape[axis] = null;\n        break;\n      }\n\n      outputShape[axis] += shape[axis];\n    }\n\n    return outputShape;\n  }\n\n  computeMask(inputs, mask) {\n    if (mask == null) {\n      return null;\n    }\n\n    if (!Array.isArray(mask)) {\n      throw new ValueError('`mask` should be an array for Concatenate');\n    }\n\n    if (!Array.isArray(inputs)) {\n      throw new ValueError('`inputs` should be an array for Concatenate');\n    }\n\n    if (mask.length !== inputs.length) {\n      throw new ValueError(`Mismatch in the length of mask (${mask.length}) ` + `and the legnth of inputs (${inputs.length})`);\n    }\n\n    return tfc.tidy(() => {\n      let allNullMasks = true;\n      mask.forEach(m => {\n        if (m != null) {\n          allNullMasks = false;\n          return;\n        }\n      });\n\n      if (allNullMasks) {\n        return null;\n      }\n\n      const outputMasks = [];\n\n      for (let i = 0; i < inputs.length; ++i) {\n        if (mask[i] == null) {\n          // Input is unmasked. Append all 1's to masks.\n          outputMasks.push(tfc.cast(tfc.onesLike(inputs[i]), 'bool'));\n        } else if (mask[i].rank < inputs[i].rank) {\n          // Mask is smaller than the input, expand it.\n          outputMasks.push(tfc.expandDims(mask[i], -1));\n        } else {\n          outputMasks.push(mask[i]);\n        }\n      }\n\n      const concatenatedMasks = tfc.concat(outputMasks, this.axis);\n      return tfc.all(concatenatedMasks, -1, false);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      'axis': this.axis\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\n/** @nocollapse */\n\nConcatenate.className = 'Concatenate';\nserialization.registerClass(Concatenate);\n/**\n * Concatenate an `Array` of inputs.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Concatenate` layer, by using no input argument\n *    or a single configuration argument. The resultant `Concatenate` layer can\n *    then be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const concatLayer = tf.layers.concatenate();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 3]});\n * const input2 = tf.input({shape: [2, 4]});\n * const output = concatLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 7], with the first dimension as the undetermined batch\n * // dimension and the last dimension as the result of concatenating the\n * // last dimensions of the two inputs.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 3]});\n * const input2 = tf.input({shape: [2, 4]});\n * const output = tf.layers.concatenate([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension and the last dimension as the result of concatenating the\n * // last dimensions of the two inputs.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([[1, 2], [3, 4]], [2, 2]);\n * const input2 = tf.tensor2d([[10, 20], [30, 40]], [2, 2]);\n * tf.layers.concatenate([input1, input2]).print();\n * // Gives [[1, 2, 10, 20], [3, 4, 30, 40]].\n *\n */\n\nexport function concatenate(config) {\n  if (Array.isArray(config)) {\n    const layer = new Concatenate({});\n    return layer.apply(config);\n  } else {\n    return new Concatenate(config);\n  }\n}\n/**\n * Interpretable potentially negative axis index.\n *\n * For example, given axis = -1, and dim = 3, this function will return 2.\n *\n * @param axis The axis index, may be a positive, zero or negative integer.\n * @param dim Total number of dimensions, a positive integer.\n * @returns A non-negative axis index equivalent to the input `axis`.\n */\n\nfunction interpretAxis(axis, dim) {\n  while (axis < 0) {\n    axis += dim;\n  }\n\n  return axis;\n}\n\nfunction batchDot(x, y, axes) {\n  if (x.shape.length > 3 || y.shape.length > 3) {\n    throw new NotImplementedError('batchDot is not implemented for tensors of 4D or higher rank yet');\n  }\n\n  tfc.util.assert(x.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, ` + `but got ${x.shape.length}`);\n  tfc.util.assert(x.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, ` + `but got ${y.shape.length}`);\n\n  if (typeof axes === 'number') {\n    axes = [axes, axes];\n  }\n\n  if (x.dtype === 'complex64' || y.dtype === 'complex64') {\n    throw new NotImplementedError('batchDot is not implemented for complex64-type Tensors yet.');\n  }\n\n  const xNDim = x.shape.length;\n  const yNDim = y.shape.length;\n\n  if (axes == null) {\n    // Behave like batchMatmul by default.\n    axes = [xNDim - 1, yNDim - 2];\n  }\n\n  const axesArray = axes;\n  return tfc.tidy(() => {\n    let diff;\n\n    if (xNDim > yNDim) {\n      diff = xNDim - yNDim;\n      const diffShape = [];\n\n      for (let i = 0; i < diff; ++i) {\n        diffShape.push(1);\n      }\n\n      y = tfc.reshape(y, y.shape.concat(diffShape));\n    } else if (yNDim > xNDim) {\n      diff = yNDim - xNDim;\n      const diffShape = [];\n\n      for (let i = 0; i < diff; ++i) {\n        diffShape.push(1);\n      }\n\n      x = tfc.reshape(x, x.shape.concat(diffShape));\n    } else {\n      diff = 0;\n    }\n\n    let out;\n\n    if (x.shape.length === 2 && y.shape.length === 2) {\n      if (axesArray[0] === axesArray[1]) {\n        out = tfc.sum(tfc.mul(x, y), axesArray[0]);\n      } else {\n        out = tfc.sum(tfc.mul(tfc.transpose(x, [1, 0]), y), axesArray[1]);\n      }\n    } else {\n      const adjX = axesArray[0] !== x.shape.length - 1;\n      const adjY = axesArray[1] === y.shape.length - 1;\n      out = tfc.matMul(x, y, adjX, adjY);\n    }\n\n    if (diff > 0) {\n      let idx;\n\n      if (xNDim > yNDim) {\n        idx = xNDim + yNDim - 3;\n      } else {\n        idx = xNDim - 1;\n      }\n\n      const squeezeAxes = [];\n\n      for (let i = idx; i < idx + diff; ++i) {\n        squeezeAxes.push(i);\n      }\n\n      out = tfc.squeeze(out, squeezeAxes);\n    }\n\n    if (out.shape.length === 1) {\n      out = tfc.expandDims(out, 1);\n    }\n\n    return out;\n  });\n}\n\nexport class Dot extends Merge {\n  constructor(args) {\n    super(args);\n    this.axes = args.axes;\n    this.normalize = args.normalize == null ? false : args.normalize;\n    this.supportsMasking = true;\n    this.reshapeRequired = false;\n  }\n\n  build(inputShape) {\n    tfc.util.assert(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => 'A `Dot` layer should be called on a list of exactly 2 inputs.');\n    const shape1 = inputShape[0];\n    const shape2 = inputShape[1];\n\n    if (shape1.length > 3 || shape2.length > 3) {\n      throw new NotImplementedError('Dot layer does not support tensors of 4D or higher rank yet.');\n    }\n\n    const axes = this.interpretAxes(shape1, shape2);\n\n    if (shape1[axes[0]] !== shape2[axes[1]]) {\n      throw new ValueError(`Dimension incompatibility: ` + `${shape1[axes[0]]} !== ${shape2[axes[1]]}`);\n    }\n  }\n\n  mergeFunction(inputs) {\n    if (inputs.length !== 2) {\n      throw new ValueError('A `Dot` layer must be called on exactly 2 inputs, ' + `but received ${inputs.length} input(s).`);\n    }\n\n    let x1 = inputs[0];\n    let x2 = inputs[1];\n    let axes;\n\n    if (!Array.isArray(this.axes)) {\n      axes = [interpretAxis(this.axes, x1.shape.length), interpretAxis(this.axes, x2.shape.length)];\n    } else {\n      axes = this.axes.map((axis, i) => interpretAxis(axis, inputs[i].shape.length));\n    }\n\n    if (this.normalize) {\n      x1 = l2Normalize(x1, axes[0]);\n      x2 = l2Normalize(x2, axes[1]);\n    }\n\n    return batchDot(x1, x2, axes);\n  }\n\n  interpretAxes(shape1, shape2) {\n    let axes;\n\n    if (!Array.isArray(this.axes)) {\n      // `this.axes` is a single integer.\n      axes = [interpretAxis(this.axes, shape1.length), interpretAxis(this.axes, shape2.length)];\n    } else {\n      // `this.axes` is an Array of integers.\n      axes = this.axes;\n    }\n\n    return axes;\n  }\n\n  computeOutputShape(inputShape) {\n    tfc.util.assert(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => 'A `Dot` layer should be called on a list of exactly 2 inputs.');\n    const shape1 = inputShape[0].slice();\n    const shape2 = inputShape[1].slice();\n\n    if (shape1.length > 3 || shape2.length > 3) {\n      throw new NotImplementedError('Dot layer does not support tensors of 4D or higher rank yet.');\n    }\n\n    const axes = this.interpretAxes(shape1, shape2);\n    shape1.splice(axes[0], 1);\n    shape2.splice(axes[1], 1);\n    shape2.splice(0, 1);\n    const outputShape = shape1.concat(shape2);\n\n    if (outputShape.length === 1) {\n      outputShape.push(1);\n    }\n\n    return outputShape;\n  }\n\n  computeMask(inputs, mask) {\n    return null;\n  }\n\n  getConfig() {\n    const config = {\n      'axes': this.axes,\n      'normalize': this.normalize\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\n/** @nocollapse */\n\nDot.className = 'Dot';\nserialization.registerClass(Dot); // TODO(cais): Add functional interfaces for the merge layers.","map":{"version":3,"mappings":"AAAA;;;;;;;;;;AAUA;;;AAIA,OAAO,KAAKA,GAAZ,MAAqB,uBAArB;AACA,SAAQC,aAAR,EAA+BC,IAA/B,EAAqCC,IAArC,QAAgD,uBAAhD;AACA,OAAO,KAAKC,CAAZ,MAAmB,yBAAnB;AACA,SAAQC,KAAR,QAA+C,oBAA/C;AACA,SAAQC,mBAAR,EAA6BC,UAA7B,QAA8C,WAA9C;AAEA,SAAQC,WAAR,QAA0B,WAA1B;AAEA,OAAO,KAAKC,aAAZ,MAA+B,wBAA/B;AACA,OAAO,KAAKC,SAAZ,MAA2B,qBAA3B;AACA,SAAQC,kBAAR,QAAiC,sBAAjC;AAEA;;;;;;AAKA,OAAM,MAAgBC,KAAhB,SAA8BP,KAA9B,CAAmC;AAGvCQ,cAAYC,IAAZ,EAA4B;AAC1B,UAAMA,IAAI,IAAI,EAAd;AACA,SAAKC,eAAL,GAAuB,IAAvB;AACD;AAED;;;;;;AAIUC,eAAa,CAACC,MAAD,EAAiB;AACtC,UAAM,IAAIX,mBAAJ,EAAN;AACD;AAED;;;;;;;;;;;;AAUQY,iCAA+B,CAACC,MAAD,EAAgBC,MAAhB,EAA6B;AAClE,QAAID,MAAM,IAAI,IAAV,IAAkBC,MAAM,IAAI,IAAhC,EAAsC;AACpC,aAAO,IAAP;AACD,KAFD,MAEO,IAAID,MAAM,CAACE,MAAP,GAAgBD,MAAM,CAACC,MAA3B,EAAmC;AACxC,aAAO,KAAKH,+BAAL,CAAqCE,MAArC,EAA6CD,MAA7C,CAAP;AACD,KAFM,MAEA,IAAIC,MAAM,CAACC,MAAP,KAAkB,CAAtB,EAAyB;AAC9B,aAAOF,MAAP;AACD;;AACD,UAAMG,WAAW,GAAUH,MAAM,CAACI,KAAP,CAAa,CAAb,EAAgBJ,MAAM,CAACE,MAAP,GAAgBD,MAAM,CAACC,MAAvC,CAA3B;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACC,MAA3B,EAAmC,EAAEG,CAArC,EAAwC;AACtC,YAAMC,CAAC,GAAGN,MAAM,CAACA,MAAM,CAACE,MAAP,GAAgBD,MAAM,CAACC,MAAvB,GAAgCG,CAAjC,CAAhB;AACA,YAAME,CAAC,GAAGN,MAAM,CAACI,CAAD,CAAhB;;AACA,UAAIC,CAAC,IAAI,IAAL,IAAaC,CAAC,IAAI,IAAlB,IAA0BD,CAAC,GAAG,CAA9B,IAAmCC,CAAC,GAAG,CAA3C,EAA8C;AAC5CJ,mBAAW,CAACK,IAAZ,CAAiB,IAAjB;AACD,OAFD,MAEO,IAAIF,CAAC,KAAK,CAAV,EAAa;AAClBH,mBAAW,CAACK,IAAZ,CAAiBD,CAAjB;AACD,OAFM,MAEA,IAAIA,CAAC,KAAK,CAAV,EAAa;AAClBJ,mBAAW,CAACK,IAAZ,CAAiBF,CAAjB;AACD,OAFM,MAEA;AACL,YAAIA,CAAC,KAAKC,CAAV,EAAa;AACX,gBAAM,IAAInB,UAAJ,CACF,0DACAqB,IAAI,CAACC,SAAL,CAAeV,MAAf,CADA,GACyB,GADzB,GAC+BS,IAAI,CAACC,SAAL,CAAeT,MAAf,CAF7B,CAAN;AAGD;;AACDE,mBAAW,CAACK,IAAZ,CAAiBF,CAAjB;AACD;AACF;;AACD,WAAOH,WAAP;AACD;;AAEDQ,OAAK,CAACC,UAAD,EAA0B;AAC7B;AACA,QAAIC,KAAK,CAACC,OAAN,CAAcF,UAAd,KAA6B,CAACC,KAAK,CAACC,OAAN,CAAcF,UAAU,CAAC,CAAD,CAAxB,CAAlC,EAAgE;AAC9D;AACAA,gBAAU,GAAG,CAACpB,kBAAkB,CAACoB,UAAD,CAAnB,CAAb;AACD;;AACDA,cAAU,GAAGA,UAAb;;AACA,QAAIA,UAAU,CAACV,MAAX,GAAoB,CAAxB,EAA2B;AACzB,YAAM,IAAId,UAAJ,CACF,qEACA,QAAQwB,UAAU,CAACV,MAAM,YAFvB,CAAN;AAGD,KAX4B,CAa7B;AACA;;;AACA,QAAIa,UAAU,GAAa,EAA3B;;AACA,SAAK,MAAMC,KAAX,IAAoBJ,UAApB,EAAgC;AAC9B,UAAII,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAAC,CAAD,CAAL,KAAa,IAAlC,EAAwC;AACtCD,kBAAU,CAACP,IAAX,CAAgBQ,KAAK,CAAC,CAAD,CAArB;AACD;AACF;;AACDD,cAAU,GAAGzB,aAAa,CAAC2B,MAAd,CAAqBF,UAArB,CAAb;;AACA,QAAIA,UAAU,CAACb,MAAX,GAAoB,CAAxB,EAA2B;AACzB,YAAM,IAAId,UAAJ,CACF,uDACA,4BAA4BqB,IAAI,CAACC,SAAL,CAAeE,UAAf,CAA0B,GAFpD,CAAN;AAGD;;AAED,QAAIT,WAAW,GACXS,UAAU,CAAC,CAAD,CAAV,IAAiB,IAAjB,GAAwB,IAAxB,GAA+BA,UAAU,CAAC,CAAD,CAAV,CAAcR,KAAd,CAAoB,CAApB,CADnC;;AAEA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,UAAU,CAACV,MAA/B,EAAuC,EAAEI,CAAzC,EAA4C;AAC1C,YAAMU,KAAK,GAAGJ,UAAU,CAACN,CAAD,CAAV,IAAiB,IAAjB,GAAwB,IAAxB,GAA+BM,UAAU,CAACN,CAAD,CAAV,CAAcF,KAAd,CAAoB,CAApB,CAA7C;AACAD,iBAAW,GAAG,KAAKJ,+BAAL,CAAqCI,WAArC,EAAkDa,KAAlD,CAAd;AACD,KAjC4B,CAkC7B;AACA;;;AACA,UAAME,QAAQ,GAAGN,UAAU,CAACO,GAAX,CAAeH,KAAK,IAAIA,KAAK,CAACd,MAA9B,CAAjB;;AACA,QAAIU,UAAU,CAACQ,OAAX,CAAmB,IAAnB,MAA6B,CAAC,CAA9B,IACA9B,aAAa,CAAC2B,MAAd,CAAqBC,QAArB,EAA+BhB,MAA/B,KAA0C,CAD9C,EACiD;AAC/C,WAAKmB,eAAL,GAAuB,KAAvB;AACD,KAHD,MAGO;AACL,WAAKA,eAAL,GAAuB,IAAvB;AACD;AACF;;AAEDC,MAAI,CAACxB,MAAD,EAA0ByB,MAA1B,EAAwC;AAC1C,WAAOxC,IAAI,CAAC,MAAK;AACfe,YAAM,GAAGA,MAAT;;AACA,UAAI,KAAKuB,eAAT,EAA0B;AACxB,cAAMG,cAAc,GAAa,EAAjC;AACA,cAAMC,SAAS,GAAG3B,MAAM,CAACqB,GAAP,CAAWO,KAAK,IAAIA,KAAK,CAACC,IAA1B,CAAlB;;AACA,YAAIF,SAAS,CAACL,OAAV,CAAkB,IAAlB,MAA4B,CAAC,CAAjC,EAAoC;AAClC;AACA;AACA,gBAAMQ,OAAO,GAAGrC,SAAS,CAACsC,GAAV,CAAcJ,SAAd,CAAhB;;AACA,eAAK,IAAIK,CAAT,IAAchC,MAAd,EAAsB;AACpB,kBAAMiC,KAAK,GAAGD,CAAC,CAACH,IAAhB;;AACA,iBAAK,IAAItB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuB,OAAO,GAAGG,KAA9B,EAAqC,EAAE1B,CAAvC,EAA0C;AACxCyB,eAAC,GAAG7C,CAAC,CAAC+C,UAAF,CAAaF,CAAb,EAAgB,CAAhB,CAAJ;AACD;;AACDN,0BAAc,CAAChB,IAAf,CAAoBsB,CAApB;AACD;;AACD,iBAAO,KAAKjC,aAAL,CAAmB2B,cAAnB,CAAP;AACD,SAZD,MAYO;AACL;AACA;AACA,cAAIS,UAAU,GAAG,KAAjB;;AACA,eAAK,MAAMH,CAAX,IAAgBhC,MAAhB,EAAwB;AACtB,kBAAMiC,KAAK,GAAGD,CAAC,CAACH,IAAhB;;AACA,gBAAII,KAAK,IAAI,IAAb,EAAmB;AACjB,oBAAMG,MAAM,GAAGJ,CAAC,CAACd,KAAjB;AACA,oBAAMmB,SAAS,GAAGD,MAAM,CAAC,CAAD,CAAxB;AACA,oBAAME,QAAQ,GAAGF,MAAM,CAAC9B,KAAP,CAAa,CAAb,EAAgBiC,MAAhB,CAAuB,CAACF,SAAD,CAAvB,CAAjB;AACA,kBAAIG,WAAW,GAAGzD,GAAG,CAAC0D,OAAJ,CACdT,CADc,EACX,CAACK,SAAD,EAAYE,MAAZ,CAAmB9C,SAAS,CAACiD,SAAV,CAAoBN,MAAM,CAAC9B,KAAP,CAAa,CAAb,CAApB,CAAnB,CADW,CAAlB;AAEAkC,yBAAW,GAAGzD,GAAG,CAAC4D,SAAJ,CAAcH,WAAd,EAA2B,CAAC,CAAD,EAAI,CAAJ,CAA3B,CAAd;AACAA,yBAAW,GAAGzD,GAAG,CAAC0D,OAAJ,CAAYD,WAAZ,EAAyBF,QAAzB,CAAd;AACAZ,4BAAc,CAAChB,IAAf,CAAoB8B,WAApB;AACAL,wBAAU,GAAG,IAAb;AACD,aAVD,MAUO,IAAIF,KAAK,GAAG,CAAZ,EAAe;AACpB,oBAAMW,IAAI,GAAGnD,SAAS,CAACoD,KAAV,CAAgB,CAAhB,EAAmBZ,KAAnB,EAA0BM,MAA1B,CAAiC,CAAC,CAAD,CAAjC,CAAb;AACAb,4BAAc,CAAChB,IAAf,CAAoB3B,GAAG,CAAC4D,SAAJ,CAAcX,CAAd,EAAiBY,IAAjB,CAApB;AACAT,wBAAU,GAAG,IAAb;AACD,aAJM,MAIA;AACL;AACAT,4BAAc,CAAChB,IAAf,CAAoBsB,CAApB;AACD;AACF;;AACD,cAAIc,CAAC,GAAG,KAAK/C,aAAL,CAAmB2B,cAAnB,CAAR;AACA,gBAAMqB,KAAK,GAAGD,CAAC,CAACjB,IAAhB;;AACA,cAAIM,UAAJ,EAAgB;AACd;AACA;AACA,gBAAIY,KAAK,IAAI,IAAb,EAAmB;AACjB,oBAAMC,MAAM,GAAGF,CAAC,CAAC5B,KAAjB;AACA,oBAAM6B,KAAK,GAAGC,MAAM,CAAC5C,MAArB;AACA,oBAAMiC,SAAS,GAAGW,MAAM,CAACD,KAAK,GAAG,CAAT,CAAxB;AACA,oBAAMT,QAAQ,GACV,CAACD,SAAD,EAAYE,MAAZ,CAAmBS,MAAM,CAAC1C,KAAP,CAAa,CAAb,EAAgB0C,MAAM,CAAC5C,MAAP,GAAgB,CAAhC,CAAnB,CADJ;AAEA0C,eAAC,GAAG/D,GAAG,CAAC0D,OAAJ,CACA1D,GAAG,CAAC4D,SAAJ,CAAc5D,GAAG,CAAC0D,OAAJ,CAAYK,CAAZ,EAAe,CAAC,CAAC,CAAF,EAAKT,SAAL,CAAf,CAAd,EAA+C,CAAC,CAAD,EAAI,CAAJ,CAA/C,CADA,EAEAC,QAFA,CAAJ;AAGD,aATD,MASO,IAAIS,KAAK,GAAG,CAAZ,EAAe;AACpB,oBAAMH,IAAI,GAAG,CAACG,KAAK,GAAG,CAAT,EAAYR,MAAZ,CAAmB9C,SAAS,CAACoD,KAAV,CAAgB,CAAhB,EAAmBE,KAAK,GAAG,CAA3B,CAAnB,CAAb;AACAD,eAAC,GAAG/D,GAAG,CAAC4D,SAAJ,CAAcG,CAAd,EAAiBF,IAAjB,CAAJ;AACD;AACF;;AACD,iBAAOE,CAAP;AACD;AACF,OA7DD,MA6DO;AACL,eAAO,KAAK/C,aAAL,CAAmBC,MAAnB,CAAP;AACD;AACF,KAlEU,CAAX;AAmED;;AAEDiD,oBAAkB,CAACnC,UAAD,EAA0B;AAC1CA,cAAU,GAAGA,UAAb;AACA,QAAIT,WAAJ;;AACA,QAAIS,UAAU,CAAC,CAAD,CAAV,IAAiB,IAArB,EAA2B;AACzBT,iBAAW,GAAG,IAAd;AACD,KAFD,MAEO;AACLA,iBAAW,GAAGS,UAAU,CAAC,CAAD,CAAV,CAAcR,KAAd,CAAoB,CAApB,CAAd;AACD;;AACD,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,UAAU,CAACV,MAA/B,EAAuC,EAAEI,CAAzC,EAA4C;AAC1C,YAAMU,KAAK,GAAGJ,UAAU,CAACN,CAAD,CAAV,IAAiB,IAAjB,GAAwB,IAAxB,GAA+BM,UAAU,CAACN,CAAD,CAAV,CAAcF,KAAd,CAAoB,CAApB,CAA7C;AACAD,iBAAW,GAAG,KAAKJ,+BAAL,CAAqCI,WAArC,EAAkDa,KAAlD,CAAd;AACD;;AAED,QAAID,UAAU,GAAa,EAA3B;;AACA,SAAK,MAAMC,KAAX,IAAoBJ,UAApB,EAAgC;AAC9B,UAAII,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAAC,CAAD,CAAL,KAAa,IAAlC,EAAwC;AACtCD,kBAAU,CAACP,IAAX,CAAgBQ,KAAK,CAAC,CAAD,CAArB;AACD;AACF;;AACDD,cAAU,GAAGzB,aAAa,CAAC2B,MAAd,CAAqBF,UAArB,CAAb;;AACA,QAAIA,UAAU,CAACb,MAAX,KAAsB,CAA1B,EAA6B;AAC3BC,iBAAW,GAAGY,UAAU,CAACsB,MAAX,CAAkBlC,WAAlB,CAAd;AACD,KAFD,MAEO;AACLA,iBAAW,GAAG,CAAC,IAAD,EAAOkC,MAAP,CAAclC,WAAd,CAAd;AACD;;AACD,WAAOA,WAAP;AACD;;AAED6C,aAAW,CAAClD,MAAD,EAA0BmD,IAA1B,EAAgD;AACzD,WAAOpE,GAAG,CAACE,IAAJ,CAAS,MAAK;AACnB,UAAIkE,IAAI,IAAI,IAAZ,EAAkB;AAChB,eAAO,IAAP;AACD;;AACD,UAAI,CAACpC,KAAK,CAACC,OAAN,CAAcmC,IAAd,CAAL,EAA0B;AACxB,cAAM,IAAI7D,UAAJ,CAAe,2BAAf,CAAN;AACD;;AACD,UAAI,CAACyB,KAAK,CAACC,OAAN,CAAchB,MAAd,CAAL,EAA4B;AAC1B,cAAM,IAAIV,UAAJ,CAAe,6BAAf,CAAN;AACD;;AACD,UAAI6D,IAAI,CAAC/C,MAAL,KAAgBJ,MAAM,CAACI,MAA3B,EAAmC;AACjC,cAAM,IAAId,UAAJ,CACF,iEACA,qCADA,GAEA,IAAIU,MAAM,CAACI,MAAM,OAAO+C,IAAI,CAAC/C,MAAM,GAHjC,CAAN;AAID;;AACD,UAAI+C,IAAI,CAACC,KAAL,CAAWC,CAAC,IAAIA,CAAC,IAAI,IAArB,CAAJ,EAAgC;AAC9B,eAAO,IAAP;AACD;;AACDF,UAAI,GAAGA,IAAI,CAAC9B,GAAL,CAASgC,CAAC,IAAIA,CAAC,IAAI,IAAL,GAAYA,CAAZ,GAAgBtE,GAAG,CAACmD,UAAJ,CAAemB,CAAf,EAAkB,CAAlB,CAA9B,CAAP;AACA,UAAIC,MAAM,GAAGH,IAAI,CAAC,CAAD,CAAjB;;AACA,WAAK,IAAI3C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2C,IAAI,CAAC/C,MAAL,GAAc,CAAlC,EAAqC,EAAEI,CAAvC,EAA0C;AACxC8C,cAAM,GAAGvE,GAAG,CAACwE,UAAJ,CAAeD,MAAf,EAAuBH,IAAI,CAAC3C,CAAD,CAA3B,CAAT;AACD;;AACD,aAAO8C,MAAP;AACD,KAzBM,CAAP;AA0BD;;AAlOsC;AAqOzC,OAAM,MAAOE,GAAP,SAAmB7D,KAAnB,CAAwB;AAG5BC,cAAYC,IAAZ,EAA4B;AAC1B,UAAMA,IAAN;AACD;;AAESE,eAAa,CAACC,MAAD,EAAiB;AACtC,WAAOf,IAAI,CAAC,MAAK;AACf,UAAIqE,MAAM,GAAGtD,MAAM,CAAC,CAAD,CAAN,CAAUyD,KAAV,EAAb;;AACA,WAAK,IAAIjD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,MAAM,CAACI,MAA3B,EAAmC,EAAEI,CAArC,EAAwC;AACtC8C,cAAM,GAAGvE,GAAG,CAAC2E,GAAJ,CAAQJ,MAAR,EAAgBtD,MAAM,CAACQ,CAAD,CAAtB,CAAT;AACD;;AACD,aAAO8C,MAAP;AACD,KANU,CAAX;AAOD;;AAf2B;AAC5B;;AACOE,gBAAY,KAAZ;AAeTxE,aAAa,CAAC2E,aAAd,CAA4BH,GAA5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA,OAAM,SAAUE,GAAV,CAAcE,MAAd,EAA0D;AAE9D,MAAI7C,KAAK,CAACC,OAAN,CAAc4C,MAAd,CAAJ,EAA2B;AACzB,UAAMC,KAAK,GAAG,IAAIL,GAAJ,CAAQ,EAAR,CAAd;AACA,WAAOK,KAAK,CAACC,KAAN,CAAYF,MAAZ,CAAP;AACD,GAHD,MAGO;AACL,WAAO,IAAIJ,GAAJ,CAAQI,MAAR,CAAP;AACD;AACF;AAED,OAAM,MAAOG,QAAP,SAAwBpE,KAAxB,CAA6B;AAGjCC,cAAYC,IAAZ,EAA4B;AAC1B,UAAMA,IAAN;AACD;;AAESE,eAAa,CAACC,MAAD,EAAiB;AACtC,WAAOf,IAAI,CAAC,MAAK;AACf,UAAIqE,MAAM,GAAGtD,MAAM,CAAC,CAAD,CAAN,CAAUyD,KAAV,EAAb;;AACA,WAAK,IAAIjD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,MAAM,CAACI,MAA3B,EAAmC,EAAEI,CAArC,EAAwC;AACtC8C,cAAM,GAAGvE,GAAG,CAACiF,GAAJ,CAAQV,MAAR,EAAgBtD,MAAM,CAACQ,CAAD,CAAtB,CAAT;AACD;;AACD,aAAO8C,MAAP;AACD,KANU,CAAX;AAOD;;AAfgC;AACjC;;AACOS,qBAAY,UAAZ;AAeT/E,aAAa,CAAC2E,aAAd,CAA4BI,QAA5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA,OAAM,SAAUE,QAAV,CAAmBL,MAAnB,EAA+D;AAEnE,MAAI7C,KAAK,CAACC,OAAN,CAAc4C,MAAd,CAAJ,EAA2B;AACzB,UAAMC,KAAK,GAAG,IAAIE,QAAJ,CAAa,EAAb,CAAd;AACA,WAAOF,KAAK,CAACC,KAAN,CAAYF,MAAZ,CAAP;AACD,GAHD,MAGO;AACL,WAAO,IAAIG,QAAJ,CAAaH,MAAb,CAAP;AACD;AACF;AAED,OAAM,MAAOM,OAAP,SAAuBvE,KAAvB,CAA4B;AAGhCC,cAAYC,IAAZ,EAA4B;AAC1B,UAAMA,IAAN;AACD;;AAESE,eAAa,CAACC,MAAD,EAAiB;AACtC,WAAOf,IAAI,CAAC,MAAK;AACf,UAAIqE,MAAM,GAAGtD,MAAM,CAAC,CAAD,CAAN,CAAUyD,KAAV,EAAb;;AACA,WAAK,IAAIjD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,MAAM,CAACI,MAA3B,EAAmC,EAAEI,CAArC,EAAwC;AACtC8C,cAAM,GAAGvE,GAAG,CAAC2E,GAAJ,CAAQJ,MAAR,EAAgBtD,MAAM,CAACQ,CAAD,CAAtB,CAAT;AACD;;AACD,aAAOzB,GAAG,CAACiF,GAAJ,CAAQ,IAAIhE,MAAM,CAACI,MAAnB,EAA2BkD,MAA3B,CAAP;AACD,KANU,CAAX;AAOD;;AAf+B;AAChC;;AACOY,oBAAY,SAAZ;AAeTlF,aAAa,CAAC2E,aAAd,CAA4BO,OAA5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA,OAAM,SAAUC,OAAV,CAAkBP,MAAlB,EAA8D;AAElE,MAAI7C,KAAK,CAACC,OAAN,CAAc4C,MAAd,CAAJ,EAA2B;AACzB,UAAMC,KAAK,GAAG,IAAIK,OAAJ,CAAY,EAAZ,CAAd;AACA,WAAOL,KAAK,CAACC,KAAN,CAAYF,MAAZ,CAAP;AACD,GAHD,MAGO;AACL,WAAO,IAAIM,OAAJ,CAAYN,MAAZ,CAAP;AACD;AACF;AAED,OAAM,MAAOQ,OAAP,SAAuBzE,KAAvB,CAA4B;AAGhCC,cAAYC,IAAZ,EAA4B;AAC1B,UAAMA,IAAN;AACD;;AAESE,eAAa,CAACC,MAAD,EAAiB;AACtC,WAAOf,IAAI,CAAC,MAAK;AACf,UAAIqE,MAAM,GAAGtD,MAAM,CAAC,CAAD,CAAnB;;AACA,WAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,MAAM,CAACI,MAA3B,EAAmC,EAAEI,CAArC,EAAwC;AACtC8C,cAAM,GAAGvE,GAAG,CAACsF,OAAJ,CAAYf,MAAZ,EAAoBtD,MAAM,CAACQ,CAAD,CAA1B,CAAT;AACD;;AACD,aAAO8C,MAAP;AACD,KANU,CAAX;AAOD;;AAf+B;AAChC;;AACOc,oBAAY,SAAZ;AAeTpF,aAAa,CAAC2E,aAAd,CAA4BS,OAA5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA,OAAM,SAAUC,OAAV,CAAkBT,MAAlB,EAA8D;AAElE,MAAI7C,KAAK,CAACC,OAAN,CAAc4C,MAAd,CAAJ,EAA2B;AACzB,UAAMC,KAAK,GAAG,IAAIO,OAAJ,CAAY,EAAZ,CAAd;AACA,WAAOP,KAAK,CAACC,KAAN,CAAYF,MAAZ,CAAP;AACD,GAHD,MAGO;AACL,WAAO,IAAIQ,OAAJ,CAAYR,MAAZ,CAAP;AACD;AACF;AAED,OAAM,MAAOU,OAAP,SAAuB3E,KAAvB,CAA4B;AAGhCC,cAAYC,IAAZ,EAA4B;AAC1B,UAAMA,IAAN;AACD;;AAESE,eAAa,CAACC,MAAD,EAAiB;AACtC,WAAOf,IAAI,CAAC,MAAK;AACf,UAAIqE,MAAM,GAAGtD,MAAM,CAAC,CAAD,CAAnB;;AACA,WAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,MAAM,CAACI,MAA3B,EAAmC,EAAEI,CAArC,EAAwC;AACtC8C,cAAM,GAAGvE,GAAG,CAACwF,OAAJ,CAAYjB,MAAZ,EAAoBtD,MAAM,CAACQ,CAAD,CAA1B,CAAT;AACD;;AACD,aAAO8C,MAAP;AACD,KANU,CAAX;AAOD;;AAf+B;AAChC;;AACOgB,oBAAY,SAAZ;AAeTtF,aAAa,CAAC2E,aAAd,CAA4BW,OAA5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA,OAAM,SAAUC,OAAV,CAAkBX,MAAlB,EAA8D;AAElE,MAAI7C,KAAK,CAACC,OAAN,CAAc4C,MAAd,CAAJ,EAA2B;AACzB,UAAMC,KAAK,GAAG,IAAIS,OAAJ,CAAY,EAAZ,CAAd;AACA,WAAOT,KAAK,CAACC,KAAN,CAAYF,MAAZ,CAAP;AACD,GAHD,MAGO;AACL,WAAO,IAAIU,OAAJ,CAAYV,MAAZ,CAAP;AACD;AACF;AASD,OAAM,MAAOY,WAAP,SAA2B7E,KAA3B,CAAgC;AAMpCC,cAAYC,IAAZ,EAAuC;AACrC,UAAMA,IAAN;AAJO,wBAAe,CAAC,CAAhB;;AAKP,QAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChBA,UAAI,GAAG,EAAP;AACD;;AACD,SAAK4E,IAAL,GAAY5E,IAAI,CAAC4E,IAAL,IAAa,IAAb,GAAoB,KAAKC,YAAzB,GAAwC7E,IAAI,CAAC4E,IAAzD;AACA,SAAK3E,eAAL,GAAuB,IAAvB;AACA,SAAKyB,eAAL,GAAuB,KAAvB;AACD;;AAEDV,OAAK,CAACC,UAAD,EAA0B;AAC7B;AACA,QAAI,EAAEC,KAAK,CAACC,OAAN,CAAcF,UAAd,KAA6BC,KAAK,CAACC,OAAN,CAAcF,UAAU,CAAC,CAAD,CAAxB,CAA/B,KACAA,UAAU,CAACV,MAAX,KAAsB,CAD1B,EAC6B;AAC3B,YAAM,IAAId,UAAJ,CACF,oEACA,QAFE,CAAN;AAGD;;AACDwB,cAAU,GAAGA,UAAb;AAEA,QAAI6D,YAAY,GAAG,IAAnB;;AACA,SAAK,MAAMzD,KAAX,IAAoBJ,UAApB,EAAgC;AAC9B,UAAII,KAAK,IAAI,IAAb,EAAmB;AACjByD,oBAAY,GAAG,KAAf;AACA;AACD;AACF;;AACD,QAAIA,YAAJ,EAAkB;AAChB;AACD;;AAED,UAAMC,QAAQ,GAAY,EAA1B;;AACA,SAAK,IAAIpE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,UAAU,CAACV,MAA/B,EAAuC,EAAEI,CAAzC,EAA4C;AAC1C,YAAMqE,sBAAsB,GAAG/D,UAAU,CAACN,CAAD,CAAV,CAAcF,KAAd,EAA/B;AACAuE,4BAAsB,CAACC,MAAvB,CAA8B,KAAKL,IAAnC,EAAyC,CAAzC;AACA,UAAIM,MAAM,GAAG,KAAb;;AACA,WAAK,MAAM7D,KAAX,IAAoB0D,QAApB,EAA8B;AAC5B,YAAI1F,IAAI,CAAC8F,WAAL,CAAiB9D,KAAjB,EAAwB2D,sBAAxB,CAAJ,EAAqD;AACnDE,gBAAM,GAAG,IAAT;AACA;AACD;AACF;;AACD,UAAI,CAACA,MAAL,EAAa;AACXH,gBAAQ,CAAClE,IAAT,CAAcmE,sBAAd;AACD;AACF;;AACD,QAAID,QAAQ,CAACxE,MAAT,GAAkB,CAAtB,EAAyB;AACvB,YAAM,IAAId,UAAJ,CACF,gEACA,gDADA,GAEAqB,IAAI,CAACC,SAAL,CAAeE,UAAf,CAHE,CAAN;AAID;AACF;;AAESf,eAAa,CAACC,MAAD,EAAiB;AACtC,WAAOf,IAAI,CAAC,MAAK;AACf,aAAOE,CAAC,CAAC8F,WAAF,CAAcjF,MAAd,EAAsB,KAAKyE,IAA3B,CAAP;AACD,KAFU,CAAX;AAGD;;AAEDxB,oBAAkB,CAACnC,UAAD,EAA0B;AAC1C,QAAI,EAAEC,KAAK,CAACC,OAAN,CAAcF,UAAd,KAA6BC,KAAK,CAACC,OAAN,CAAcF,UAAU,CAAC,CAAD,CAAxB,CAA/B,CAAJ,EAAkE;AAChE,YAAM,IAAIxB,UAAJ,CACF,6DADE,CAAN;AAED;;AACD,UAAM4F,WAAW,GAAGpE,UAApB;AACA,UAAMT,WAAW,GAAG6E,WAAW,CAAC,CAAD,CAAX,CAAe5E,KAAf,EAApB;AACA,UAAMmE,IAAI,GAAG,KAAKA,IAAL,GAAY,CAAZ,GAAgBpE,WAAW,CAACD,MAAZ,GAAqB,KAAKqE,IAA1C,GAAiD,KAAKA,IAAnE,CAP0C,CAQ1C;AACA;;AACA,SAAK,MAAMvD,KAAX,IAAoBgE,WAAW,CAAC5E,KAAZ,CAAkB,CAAlB,CAApB,EAA0C;AACxC,UAAID,WAAW,CAACoE,IAAD,CAAX,IAAqB,IAArB,IAA6BvD,KAAK,CAACuD,IAAD,CAAL,IAAe,IAAhD,EAAsD;AACpDpE,mBAAW,CAACoE,IAAD,CAAX,GAAoB,IAApB;AACA;AACD;;AACDpE,iBAAW,CAACoE,IAAD,CAAX,IAAqBvD,KAAK,CAACuD,IAAD,CAA1B;AACD;;AACD,WAAOpE,WAAP;AACD;;AAED6C,aAAW,CAAClD,MAAD,EAA0BmD,IAA1B,EAAgD;AACzD,QAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChB,aAAO,IAAP;AACD;;AACD,QAAI,CAACpC,KAAK,CAACC,OAAN,CAAcmC,IAAd,CAAL,EAA0B;AACxB,YAAM,IAAI7D,UAAJ,CAAe,2CAAf,CAAN;AACD;;AACD,QAAI,CAACyB,KAAK,CAACC,OAAN,CAAchB,MAAd,CAAL,EAA4B;AAC1B,YAAM,IAAIV,UAAJ,CAAe,6CAAf,CAAN;AACD;;AACD,QAAI6D,IAAI,CAAC/C,MAAL,KAAgBJ,MAAM,CAACI,MAA3B,EAAmC;AACjC,YAAM,IAAId,UAAJ,CACF,mCAAmC6D,IAAI,CAAC/C,MAAM,IAA9C,GACA,6BAA6BJ,MAAM,CAACI,MAAM,GAFxC,CAAN;AAGD;;AACD,WAAOrB,GAAG,CAACE,IAAJ,CAAS,MAAK;AACnB,UAAIkG,YAAY,GAAG,IAAnB;AACAhC,UAAI,CAACiC,OAAL,CAAa/B,CAAC,IAAG;AACf,YAAIA,CAAC,IAAI,IAAT,EAAe;AACb8B,sBAAY,GAAG,KAAf;AACA;AACD;AACF,OALD;;AAMA,UAAIA,YAAJ,EAAkB;AAChB,eAAO,IAAP;AACD;;AACD,YAAME,WAAW,GAAa,EAA9B;;AACA,WAAK,IAAI7E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,MAAM,CAACI,MAA3B,EAAmC,EAAEI,CAArC,EAAwC;AACtC,YAAI2C,IAAI,CAAC3C,CAAD,CAAJ,IAAW,IAAf,EAAqB;AACnB;AACA6E,qBAAW,CAAC3E,IAAZ,CAAiB3B,GAAG,CAACuG,IAAJ,CAASvG,GAAG,CAACwG,QAAJ,CAAavF,MAAM,CAACQ,CAAD,CAAnB,CAAT,EAAkC,MAAlC,CAAjB;AACD,SAHD,MAGO,IAAI2C,IAAI,CAAC3C,CAAD,CAAJ,CAAQqB,IAAR,GAAe7B,MAAM,CAACQ,CAAD,CAAN,CAAUqB,IAA7B,EAAmC;AACxC;AACAwD,qBAAW,CAAC3E,IAAZ,CAAiB3B,GAAG,CAACmD,UAAJ,CAAeiB,IAAI,CAAC3C,CAAD,CAAnB,EAAwB,CAAC,CAAzB,CAAjB;AACD,SAHM,MAGA;AACL6E,qBAAW,CAAC3E,IAAZ,CAAiByC,IAAI,CAAC3C,CAAD,CAArB;AACD;AACF;;AACD,YAAMgF,iBAAiB,GAAGzG,GAAG,CAACwD,MAAJ,CAAW8C,WAAX,EAAwB,KAAKZ,IAA7B,CAA1B;AACA,aAAO1F,GAAG,CAAC0G,GAAJ,CAAQD,iBAAR,EAA2B,CAAC,CAA5B,EAA+B,KAA/B,CAAP;AACD,KAzBM,CAAP;AA0BD;;AAEDE,WAAS;AACP,UAAM9B,MAAM,GAA6B;AACvC,cAAQ,KAAKa;AAD0B,KAAzC;AAGA,UAAMkB,UAAU,GAAG,MAAMD,SAAN,EAAnB;AACAE,UAAM,CAACC,MAAP,CAAcjC,MAAd,EAAsB+B,UAAtB;AACA,WAAO/B,MAAP;AACD;;AAxImC;AACpC;;AACOY,wBAAY,aAAZ;AAwITxF,aAAa,CAAC2E,aAAd,CAA4Ba,WAA5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDA,OAAM,SAAUS,WAAV,CAAsBrB,MAAtB,EAC0C;AAC9C,MAAI7C,KAAK,CAACC,OAAN,CAAc4C,MAAd,CAAJ,EAA2B;AACzB,UAAMC,KAAK,GAAG,IAAIW,WAAJ,CAAgB,EAAhB,CAAd;AACA,WAAOX,KAAK,CAACC,KAAN,CAAYF,MAAZ,CAAP;AACD,GAHD,MAGO;AACL,WAAO,IAAIY,WAAJ,CAAgBZ,MAAhB,CAAP;AACD;AACF;AAoBD;;;;;;;;;;AASA,SAASkC,aAAT,CAAuBrB,IAAvB,EAAqCsB,GAArC,EAAgD;AAC9C,SAAOtB,IAAI,GAAG,CAAd,EAAiB;AACfA,QAAI,IAAIsB,GAAR;AACD;;AACD,SAAOtB,IAAP;AACD;;AAED,SAASuB,QAAT,CAAkBhE,CAAlB,EAA6Bc,CAA7B,EAAwCmD,IAAxC,EAAqE;AACnE,MAAIjE,CAAC,CAACd,KAAF,CAAQd,MAAR,GAAiB,CAAjB,IAAsB0C,CAAC,CAAC5B,KAAF,CAAQd,MAAR,GAAiB,CAA3C,EAA8C;AAC5C,UAAM,IAAIf,mBAAJ,CACF,kEADE,CAAN;AAED;;AACDN,KAAG,CAACG,IAAJ,CAASgH,MAAT,CACIlE,CAAC,CAACd,KAAF,CAAQd,MAAR,IAAkB,CADtB,EAEI,MAAM,iDACF,WAAW4B,CAAC,CAACd,KAAF,CAAQd,MAAM,EAHjC;AAIArB,KAAG,CAACG,IAAJ,CAASgH,MAAT,CACIlE,CAAC,CAACd,KAAF,CAAQd,MAAR,IAAkB,CADtB,EAEI,MAAM,iDACF,WAAW0C,CAAC,CAAC5B,KAAF,CAAQd,MAAM,EAHjC;;AAKA,MAAI,OAAO6F,IAAP,KAAgB,QAApB,EAA8B;AAC5BA,QAAI,GAAG,CAACA,IAAD,EAAOA,IAAP,CAAP;AACD;;AAED,MAAIjE,CAAC,CAACmE,KAAF,KAAY,WAAZ,IAA2BrD,CAAC,CAACqD,KAAF,KAAY,WAA3C,EAAwD;AACtD,UAAM,IAAI9G,mBAAJ,CACF,6DADE,CAAN;AAED;;AAED,QAAM4C,KAAK,GAAGD,CAAC,CAACd,KAAF,CAAQd,MAAtB;AACA,QAAM2C,KAAK,GAAGD,CAAC,CAAC5B,KAAF,CAAQd,MAAtB;;AACA,MAAI6F,IAAI,IAAI,IAAZ,EAAkB;AAChB;AACAA,QAAI,GAAG,CAAChE,KAAK,GAAG,CAAT,EAAYc,KAAK,GAAG,CAApB,CAAP;AACD;;AACD,QAAMqD,SAAS,GAAGH,IAAlB;AAEA,SAAOlH,GAAG,CAACE,IAAJ,CAAS,MAAK;AACnB,QAAIoH,IAAJ;;AACA,QAAIpE,KAAK,GAAGc,KAAZ,EAAmB;AACjBsD,UAAI,GAAGpE,KAAK,GAAGc,KAAf;AACA,YAAMuD,SAAS,GAAU,EAAzB;;AACA,WAAK,IAAI9F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6F,IAApB,EAA0B,EAAE7F,CAA5B,EAA+B;AAC7B8F,iBAAS,CAAC5F,IAAV,CAAe,CAAf;AACD;;AACDoC,OAAC,GAAG/D,GAAG,CAAC0D,OAAJ,CAAYK,CAAZ,EAAeA,CAAC,CAAC5B,KAAF,CAAQqB,MAAR,CAAe+D,SAAf,CAAf,CAAJ;AACD,KAPD,MAOO,IAAIvD,KAAK,GAAGd,KAAZ,EAAmB;AACxBoE,UAAI,GAAGtD,KAAK,GAAGd,KAAf;AACA,YAAMqE,SAAS,GAAU,EAAzB;;AACA,WAAK,IAAI9F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6F,IAApB,EAA0B,EAAE7F,CAA5B,EAA+B;AAC7B8F,iBAAS,CAAC5F,IAAV,CAAe,CAAf;AACD;;AACDsB,OAAC,GAAGjD,GAAG,CAAC0D,OAAJ,CAAYT,CAAZ,EAAeA,CAAC,CAACd,KAAF,CAAQqB,MAAR,CAAe+D,SAAf,CAAf,CAAJ;AACD,KAPM,MAOA;AACLD,UAAI,GAAG,CAAP;AACD;;AAED,QAAIE,GAAJ;;AACA,QAAIvE,CAAC,CAACd,KAAF,CAAQd,MAAR,KAAmB,CAAnB,IAAwB0C,CAAC,CAAC5B,KAAF,CAAQd,MAAR,KAAmB,CAA/C,EAAkD;AAChD,UAAIgG,SAAS,CAAC,CAAD,CAAT,KAAiBA,SAAS,CAAC,CAAD,CAA9B,EAAmC;AACjCG,WAAG,GAAGxH,GAAG,CAACyH,GAAJ,CAAQzH,GAAG,CAACiF,GAAJ,CAAQhC,CAAR,EAAWc,CAAX,CAAR,EAAuBsD,SAAS,CAAC,CAAD,CAAhC,CAAN;AACD,OAFD,MAEO;AACLG,WAAG,GAAGxH,GAAG,CAACyH,GAAJ,CAAQzH,GAAG,CAACiF,GAAJ,CAAQjF,GAAG,CAAC4D,SAAJ,CAAcX,CAAd,EAAiB,CAAC,CAAD,EAAI,CAAJ,CAAjB,CAAR,EAAkCc,CAAlC,CAAR,EAA8CsD,SAAS,CAAC,CAAD,CAAvD,CAAN;AACD;AACF,KAND,MAMO;AACL,YAAMK,IAAI,GAAGL,SAAS,CAAC,CAAD,CAAT,KAAiBpE,CAAC,CAACd,KAAF,CAAQd,MAAR,GAAiB,CAA/C;AACA,YAAMsG,IAAI,GAAGN,SAAS,CAAC,CAAD,CAAT,KAAiBtD,CAAC,CAAC5B,KAAF,CAAQd,MAAR,GAAiB,CAA/C;AACAmG,SAAG,GAAGxH,GAAG,CAAC4H,MAAJ,CAAW3E,CAAX,EAAcc,CAAd,EAAiB2D,IAAjB,EAAuBC,IAAvB,CAAN;AACD;;AAED,QAAIL,IAAI,GAAG,CAAX,EAAc;AACZ,UAAIO,GAAJ;;AACA,UAAI3E,KAAK,GAAGc,KAAZ,EAAmB;AACjB6D,WAAG,GAAG3E,KAAK,GAAGc,KAAR,GAAgB,CAAtB;AACD,OAFD,MAEO;AACL6D,WAAG,GAAG3E,KAAK,GAAG,CAAd;AACD;;AACD,YAAM4E,WAAW,GAAa,EAA9B;;AACA,WAAK,IAAIrG,CAAC,GAAGoG,GAAb,EAAkBpG,CAAC,GAAGoG,GAAG,GAAGP,IAA5B,EAAkC,EAAE7F,CAApC,EAAuC;AACrCqG,mBAAW,CAACnG,IAAZ,CAAiBF,CAAjB;AACD;;AACD+F,SAAG,GAAGxH,GAAG,CAAC+H,OAAJ,CAAYP,GAAZ,EAAiBM,WAAjB,CAAN;AACD;;AACD,QAAIN,GAAG,CAACrF,KAAJ,CAAUd,MAAV,KAAqB,CAAzB,EAA4B;AAC1BmG,SAAG,GAAGxH,GAAG,CAACmD,UAAJ,CAAeqE,GAAf,EAAoB,CAApB,CAAN;AACD;;AACD,WAAOA,GAAP;AACD,GAlDM,CAAP;AAmDD;;AAED,OAAM,MAAOQ,GAAP,SAAmBpH,KAAnB,CAAwB;AAO5BC,cAAYC,IAAZ,EAA8B;AAC5B,UAAMA,IAAN;AACA,SAAKoG,IAAL,GAAYpG,IAAI,CAACoG,IAAjB;AACA,SAAKe,SAAL,GAAiBnH,IAAI,CAACmH,SAAL,IAAkB,IAAlB,GAAyB,KAAzB,GAAiCnH,IAAI,CAACmH,SAAvD;AACA,SAAKlH,eAAL,GAAuB,IAAvB;AACA,SAAKyB,eAAL,GAAuB,KAAvB;AACD;;AAEDV,OAAK,CAACC,UAAD,EAA0B;AAC7B/B,OAAG,CAACG,IAAJ,CAASgH,MAAT,CACInF,KAAK,CAACC,OAAN,CAAcF,UAAd,KAA6BA,UAAU,CAACV,MAAX,KAAsB,CAAnD,IACIW,KAAK,CAACC,OAAN,CAAcF,UAAU,CAAC,CAAD,CAAxB,CADJ,IACoCC,KAAK,CAACC,OAAN,CAAcF,UAAU,CAAC,CAAD,CAAxB,CAFxC,EAGI,MAAM,+DAHV;AAIA,UAAMZ,MAAM,GAAGY,UAAU,CAAC,CAAD,CAAzB;AACA,UAAMX,MAAM,GAAGW,UAAU,CAAC,CAAD,CAAzB;;AACA,QAAIZ,MAAM,CAACE,MAAP,GAAgB,CAAhB,IAAqBD,MAAM,CAACC,MAAP,GAAgB,CAAzC,EAA4C;AAC1C,YAAM,IAAIf,mBAAJ,CACF,8DADE,CAAN;AAED;;AAED,UAAM4G,IAAI,GAAG,KAAKgB,aAAL,CAAmB/G,MAAnB,EAA2BC,MAA3B,CAAb;;AACA,QAAID,MAAM,CAAC+F,IAAI,CAAC,CAAD,CAAL,CAAN,KAAoB9F,MAAM,CAAC8F,IAAI,CAAC,CAAD,CAAL,CAA9B,EAAyC;AACvC,YAAM,IAAI3G,UAAJ,CACF,gCACA,GAAGY,MAAM,CAAC+F,IAAI,CAAC,CAAD,CAAL,CAAS,QAAQ9F,MAAM,CAAC8F,IAAI,CAAC,CAAD,CAAL,CAAS,EAFvC,CAAN;AAGD;AACF;;AAESlG,eAAa,CAACC,MAAD,EAAiB;AACtC,QAAIA,MAAM,CAACI,MAAP,KAAkB,CAAtB,EAAyB;AACvB,YAAM,IAAId,UAAJ,CACF,uDACA,gBAAgBU,MAAM,CAACI,MAAM,YAF3B,CAAN;AAGD;;AAED,QAAI8G,EAAE,GAAGlH,MAAM,CAAC,CAAD,CAAf;AACA,QAAImH,EAAE,GAAGnH,MAAM,CAAC,CAAD,CAAf;AACA,QAAIiG,IAAJ;;AACA,QAAI,CAAClF,KAAK,CAACC,OAAN,CAAc,KAAKiF,IAAnB,CAAL,EAA+B;AAC7BA,UAAI,GAAG,CACLH,aAAa,CAAC,KAAKG,IAAN,EAAYiB,EAAE,CAAChG,KAAH,CAASd,MAArB,CADR,EAEL0F,aAAa,CAAC,KAAKG,IAAN,EAAYkB,EAAE,CAACjG,KAAH,CAASd,MAArB,CAFR,CAAP;AAID,KALD,MAKO;AACL6F,UAAI,GAAG,KAAKA,IAAL,CAAU5E,GAAV,CACI,CAACoD,IAAD,EAAOjE,CAAP,KAAasF,aAAa,CACtBrB,IADsB,EAChBzE,MAAM,CAACQ,CAAD,CAAN,CAAUU,KAAV,CAAgBd,MADA,CAD9B,CAAP;AAGD;;AACD,QAAI,KAAK4G,SAAT,EAAoB;AAClBE,QAAE,GAAG3H,WAAW,CAAC2H,EAAD,EAAKjB,IAAI,CAAC,CAAD,CAAT,CAAhB;AACAkB,QAAE,GAAG5H,WAAW,CAAC4H,EAAD,EAAKlB,IAAI,CAAC,CAAD,CAAT,CAAhB;AACD;;AACD,WAAOD,QAAQ,CAACkB,EAAD,EAAKC,EAAL,EAASlB,IAAT,CAAf;AACD;;AAEOgB,eAAa,CAAC/G,MAAD,EAAgBC,MAAhB,EAA6B;AAChD,QAAI8F,IAAJ;;AACA,QAAI,CAAClF,KAAK,CAACC,OAAN,CAAc,KAAKiF,IAAnB,CAAL,EAA+B;AAC7B;AACAA,UAAI,GAAG,CACLH,aAAa,CAAC,KAAKG,IAAN,EAAY/F,MAAM,CAACE,MAAnB,CADR,EAEL0F,aAAa,CAAC,KAAKG,IAAN,EAAY9F,MAAM,CAACC,MAAnB,CAFR,CAAP;AAID,KAND,MAMO;AACL;AACA6F,UAAI,GAAG,KAAKA,IAAZ;AACD;;AACD,WAAOA,IAAP;AACD;;AAEDhD,oBAAkB,CAACnC,UAAD,EAA0B;AAC1C/B,OAAG,CAACG,IAAJ,CAASgH,MAAT,CACInF,KAAK,CAACC,OAAN,CAAcF,UAAd,KAA6BA,UAAU,CAACV,MAAX,KAAsB,CAAnD,IACIW,KAAK,CAACC,OAAN,CAAcF,UAAU,CAAC,CAAD,CAAxB,CADJ,IACoCC,KAAK,CAACC,OAAN,CAAcF,UAAU,CAAC,CAAD,CAAxB,CAFxC,EAGI,MAAM,+DAHV;AAIA,UAAMZ,MAAM,GAAIY,UAAU,CAAC,CAAD,CAAV,CAAwBR,KAAxB,EAAhB;AACA,UAAMH,MAAM,GAAIW,UAAU,CAAC,CAAD,CAAV,CAAwBR,KAAxB,EAAhB;;AACA,QAAIJ,MAAM,CAACE,MAAP,GAAgB,CAAhB,IAAqBD,MAAM,CAACC,MAAP,GAAgB,CAAzC,EAA4C;AAC1C,YAAM,IAAIf,mBAAJ,CACF,8DADE,CAAN;AAED;;AAED,UAAM4G,IAAI,GAAG,KAAKgB,aAAL,CAAmB/G,MAAnB,EAA2BC,MAA3B,CAAb;AACAD,UAAM,CAAC4E,MAAP,CAAcmB,IAAI,CAAC,CAAD,CAAlB,EAAuB,CAAvB;AACA9F,UAAM,CAAC2E,MAAP,CAAcmB,IAAI,CAAC,CAAD,CAAlB,EAAuB,CAAvB;AACA9F,UAAM,CAAC2E,MAAP,CAAc,CAAd,EAAiB,CAAjB;AACA,UAAMzE,WAAW,GAAGH,MAAM,CAACqC,MAAP,CAAcpC,MAAd,CAApB;;AACA,QAAIE,WAAW,CAACD,MAAZ,KAAuB,CAA3B,EAA8B;AAC5BC,iBAAW,CAACK,IAAZ,CAAiB,CAAjB;AACD;;AACD,WAAOL,WAAP;AACD;;AAED6C,aAAW,CAAClD,MAAD,EAA0BmD,IAA1B,EAAgD;AACzD,WAAO,IAAP;AACD;;AAEDuC,WAAS;AACP,UAAM9B,MAAM,GAA6B;AACvC,cAAQ,KAAKqC,IAD0B;AAEvC,mBAAa,KAAKe;AAFqB,KAAzC;AAIA,UAAMrB,UAAU,GAAG,MAAMD,SAAN,EAAnB;AACAE,UAAM,CAACC,MAAP,CAAcjC,MAAd,EAAsB+B,UAAtB;AACA,WAAO/B,MAAP;AACD;;AAhH2B;AAC5B;;AACOmD,gBAAY,KAAZ;AAgHT/H,aAAa,CAAC2E,aAAd,CAA4BoD,GAA5B,E,CAEA","names":["tfc","serialization","tidy","util","K","Layer","NotImplementedError","ValueError","l2Normalize","generic_utils","mathUtils","getExactlyOneShape","Merge","constructor","args","supportsMasking","mergeFunction","inputs","computeElementwiseOpOutputShape","shape1","shape2","length","outputShape","slice","k","i","j","push","JSON","stringify","build","inputShape","Array","isArray","batchSizes","shape","unique","allRanks","map","indexOf","reshapeRequired","call","kwargs","reshapedInputs","inputDims","input","rank","maxNDim","max","x","xNDim","expandDims","transposed","xShape","batchSize","newShape","concat","xTransposed","reshape","arrayProd","transpose","dims","range","y","yNDim","yShape","computeOutputShape","computeMask","mask","every","m","output","logicalAnd","Add","clone","add","registerClass","config","layer","apply","Multiply","mul","multiply","Average","average","Maximum","maximum","Minimum","minimum","Concatenate","axis","DEFAULT_AXIS","allNoneShape","shapeSet","shapeWithoutConcatAxis","splice","exists","arraysEqual","concatenate","inputShapes","allNullMasks","forEach","outputMasks","cast","onesLike","concatenatedMasks","all","getConfig","baseConfig","Object","assign","interpretAxis","dim","batchDot","axes","assert","dtype","axesArray","diff","diffShape","out","sum","adjX","adjY","matMul","idx","squeezeAxes","squeeze","Dot","normalize","interpretAxes","x1","x2"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-layers/src/layers/merge.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Merge Layers.\n */\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {serialization, Tensor, tidy, util} from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport {Layer, LayerArgs, SymbolicTensor} from '../engine/topology';\nimport {NotImplementedError, ValueError} from '../errors';\nimport {Shape} from '../keras_format/common';\nimport {l2Normalize} from '../losses';\nimport {Kwargs} from '../types';\nimport * as generic_utils from '../utils/generic_utils';\nimport * as mathUtils from '../utils/math_utils';\nimport {getExactlyOneShape} from '../utils/types_utils';\n\n/**\n * Generic Merge layer for element-wise merge functions.\n *\n * Used to implement `Sum`, `Average`, `Concatenate`, etc.\n */\nexport abstract class Merge extends Layer {\n  protected reshapeRequired: boolean;\n\n  constructor(args?: LayerArgs) {\n    super(args || {});\n    this.supportsMasking = true;\n  }\n\n  /**\n   * Logic for merging multiple tensors, to be overridden by subclasses.\n   * @param inputs\n   */\n  protected mergeFunction(inputs: Tensor[]): Tensor {\n    throw new NotImplementedError();\n  }\n\n  /**\n   * Computes the shape of the result of an elementwise operation.\n   *\n   * @param shape1: Shape of the first tensor.\n   * @param shape2: Shape of the second tensor.\n   * @returns Expected output shape when an elementwise operation is carried\n   *   out on 2 tensors with shapes `shape1` and `shape2`.\n   * @throws ValueError: If `shape1` and `shape2` are not compatible for\n   *   element-wise operations.\n   */\n  private computeElementwiseOpOutputShape(shape1: Shape, shape2: Shape): Shape {\n    if (shape1 == null || shape2 == null) {\n      return null;\n    } else if (shape1.length < shape2.length) {\n      return this.computeElementwiseOpOutputShape(shape2, shape1);\n    } else if (shape2.length === 0) {\n      return shape1;\n    }\n    const outputShape: Shape = shape1.slice(0, shape1.length - shape2.length);\n    for (let k = 0; k < shape2.length; ++k) {\n      const i = shape1[shape1.length - shape2.length + k];\n      const j = shape2[k];\n      if (i == null || j == null || i < 0 || j < 0) {\n        outputShape.push(null);\n      } else if (i === 1) {\n        outputShape.push(j);\n      } else if (j === 1) {\n        outputShape.push(i);\n      } else {\n        if (i !== j) {\n          throw new ValueError(\n              'Operands could not be broadcast together with shapes ' +\n              JSON.stringify(shape1) + ' ' + JSON.stringify(shape2));\n        }\n        outputShape.push(i);\n      }\n    }\n    return outputShape;\n  }\n\n  build(inputShape: Shape|Shape[]): void {\n    // Used purely for shape validation.\n    if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {\n      // Make sure that inputShape is an Array of shape.\n      inputShape = [getExactlyOneShape(inputShape)];\n    }\n    inputShape = inputShape as Shape[];\n    if (inputShape.length < 2) {\n      throw new ValueError(\n          'A merge layer should be called on an Array of at least 2 inputs.' +\n          ` Got ${inputShape.length} input(s).`);\n    }\n\n    // Make sure that there is at most one unique batch size among the input\n    // shapes.\n    let batchSizes: number[] = [];\n    for (const shape of inputShape) {\n      if (shape != null && shape[0] !== null) {\n        batchSizes.push(shape[0]);\n      }\n    }\n    batchSizes = generic_utils.unique(batchSizes);\n    if (batchSizes.length > 1) {\n      throw new ValueError(\n          `Can not merge tensors with different batch sizes. ` +\n          `Got tensors with shapes: ${JSON.stringify(inputShape)}.`);\n    }\n\n    let outputShape: Shape =\n        inputShape[0] == null ? null : inputShape[0].slice(1);\n    for (let i = 1; i < inputShape.length; ++i) {\n      const shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n      outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n    }\n    // If the inputs have different ranks, we have to reshape them to make them\n    // broadcastable.\n    const allRanks = inputShape.map(shape => shape.length);\n    if (inputShape.indexOf(null) === -1 &&\n        generic_utils.unique(allRanks).length === 1) {\n      this.reshapeRequired = false;\n    } else {\n      this.reshapeRequired = true;\n    }\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      inputs = inputs as Tensor[];\n      if (this.reshapeRequired) {\n        const reshapedInputs: Tensor[] = [];\n        const inputDims = inputs.map(input => input.rank);\n        if (inputDims.indexOf(null) === -1) {\n          // If ranks of all inputs are available, we simply expand each of them\n          // at axis=1 until all of them have the same rank.\n          const maxNDim = mathUtils.max(inputDims);\n          for (let x of inputs) {\n            const xNDim = x.rank;\n            for (let k = 0; k < maxNDim - xNDim; ++k) {\n              x = K.expandDims(x, 1);\n            }\n            reshapedInputs.push(x);\n          }\n          return this.mergeFunction(reshapedInputs);\n        } else {\n          // Transpose all inputs so that batch size is the last dimension.\n          // [batchSize, dim1, dim2, ...] -> [dim1, dim2, ..., batchSize]\n          let transposed = false;\n          for (const x of inputs) {\n            const xNDim = x.rank;\n            if (xNDim == null) {\n              const xShape = x.shape;\n              const batchSize = xShape[0];\n              const newShape = xShape.slice(1).concat([batchSize]);\n              let xTransposed = tfc.reshape(\n                  x, [batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));\n              xTransposed = tfc.transpose(xTransposed, [1, 0]);\n              xTransposed = tfc.reshape(xTransposed, newShape);\n              reshapedInputs.push(xTransposed);\n              transposed = true;\n            } else if (xNDim > 1) {\n              const dims = mathUtils.range(1, xNDim).concat([0]);\n              reshapedInputs.push(tfc.transpose(x, dims));\n              transposed = true;\n            } else {\n              // We don't transpose inputs if they are 1D vectors or scalars.\n              reshapedInputs.push(x);\n            }\n          }\n          let y = this.mergeFunction(reshapedInputs);\n          const yNDim = y.rank;\n          if (transposed) {\n            // If inputs have been transposed, we have to transpose the output\n            // too.\n            if (yNDim == null) {\n              const yShape = y.shape;\n              const yNDim = yShape.length;\n              const batchSize = yShape[yNDim - 1];\n              const newShape =\n                  [batchSize].concat(yShape.slice(0, yShape.length - 1));\n              y = tfc.reshape(\n                  tfc.transpose(tfc.reshape(y, [-1, batchSize]), [1, 0]),\n                  newShape);\n            } else if (yNDim > 1) {\n              const dims = [yNDim - 1].concat(mathUtils.range(0, yNDim - 1));\n              y = tfc.transpose(y, dims);\n            }\n          }\n          return y;\n        }\n      } else {\n        return this.mergeFunction(inputs);\n      }\n    });\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = inputShape as Shape[];\n    let outputShape: Shape;\n    if (inputShape[0] == null) {\n      outputShape = null;\n    } else {\n      outputShape = inputShape[0].slice(1);\n    }\n    for (let i = 1; i < inputShape.length; ++i) {\n      const shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n      outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n    }\n\n    let batchSizes: number[] = [];\n    for (const shape of inputShape) {\n      if (shape != null && shape[0] !== null) {\n        batchSizes.push(shape[0]);\n      }\n    }\n    batchSizes = generic_utils.unique(batchSizes);\n    if (batchSizes.length === 1) {\n      outputShape = batchSizes.concat(outputShape);\n    } else {\n      outputShape = [null].concat(outputShape);\n    }\n    return outputShape;\n  }\n\n  computeMask(inputs: Tensor|Tensor[], mask?: Tensor|Tensor[]): Tensor {\n    return tfc.tidy(() => {\n      if (mask == null) {\n        return null;\n      }\n      if (!Array.isArray(mask)) {\n        throw new ValueError('`mask` should be an Array');\n      }\n      if (!Array.isArray(inputs)) {\n        throw new ValueError('`inputs` should be an Array');\n      }\n      if (mask.length !== inputs.length) {\n        throw new ValueError(\n            `The Array 'inputs' and 'mask' are expected to have the same ` +\n            `length, but have different lengths ` +\n            `(${inputs.length} vs ${mask.length})`);\n      }\n      if (mask.every(m => m == null)) {\n        return null;\n      }\n      mask = mask.map(m => m == null ? m : tfc.expandDims(m, 0));\n      let output = mask[0];\n      for (let i = 1; i < mask.length - 1; ++i) {\n        output = tfc.logicalAnd(output, mask[i]);\n      }\n      return output;\n    });\n  }\n}\n\nexport class Add extends Merge {\n  /** @nocollapse */\n  static className = 'Add';\n  constructor(args?: LayerArgs) {\n    super(args);\n  }\n\n  protected mergeFunction(inputs: Tensor[]): Tensor {\n    return tidy(() => {\n      let output = inputs[0].clone();\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.add(output, inputs[i]);\n      }\n      return output;\n    });\n  }\n}\nserialization.registerClass(Add);\n\n/**\n * Calculate the element-wise sum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Add` layer, by using no input argument\n *    or a single configuration argument. The resultant `Add` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const addLayer = tf.layers.add();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = addLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.add([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.add([input1, input2]).print();\n * // Gives [[11, 22], [33, 44]].\n *\n */\nexport function add(config?: SymbolicTensor[]|Tensor[]|LayerArgs): Layer|\n    SymbolicTensor|Tensor {\n  if (Array.isArray(config)) {\n    const layer = new Add({});\n    return layer.apply(config) as SymbolicTensor | Tensor;\n  } else {\n    return new Add(config);\n  }\n}\n\nexport class Multiply extends Merge {\n  /** @nocollapse */\n  static className = 'Multiply';\n  constructor(args?: LayerArgs) {\n    super(args);\n  }\n\n  protected mergeFunction(inputs: Tensor[]): Tensor {\n    return tidy(() => {\n      let output = inputs[0].clone();\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.mul(output, inputs[i]);\n      }\n      return output;\n    });\n  }\n}\nserialization.registerClass(Multiply);\n\n/**\n * Calculate the element-wise product of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Multiply` layer, by using no input argument\n *    or a single configuration argument. The resultant `Multiply` layer can\n *    then be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const multiplyLayer = tf.layers.multiply();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = multiplyLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.multiply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.multiply([input1, input2]).print();\n * // Gives [[10, 40], [90, 160]].\n *\n */\nexport function multiply(config?: SymbolicTensor[]|Tensor[]|LayerArgs): Layer|\n    SymbolicTensor|Tensor {\n  if (Array.isArray(config)) {\n    const layer = new Multiply({});\n    return layer.apply(config) as SymbolicTensor | Tensor;\n  } else {\n    return new Multiply(config);\n  }\n}\n\nexport class Average extends Merge {\n  /** @nocollapse */\n  static className = 'Average';\n  constructor(args?: LayerArgs) {\n    super(args);\n  }\n\n  protected mergeFunction(inputs: Tensor[]): Tensor {\n    return tidy(() => {\n      let output = inputs[0].clone();\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.add(output, inputs[i]);\n      }\n      return tfc.mul(1 / inputs.length, output);\n    });\n  }\n}\nserialization.registerClass(Average);\n\n/**\n * Calculate the element-wise arithmetic mean of inputs, which all have the same\n * shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Average` layer, by using no input argument\n *    or a single configuration argument. The resultant `Average` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const averageLayer = tf.layers.average();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = averageLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.average([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.average([input1, input2]).print();\n * // Gives [[5.5, 11], [16.5, 22]].\n *\n */\nexport function average(config?: SymbolicTensor[]|Tensor[]|LayerArgs): Layer|\n    SymbolicTensor|Tensor {\n  if (Array.isArray(config)) {\n    const layer = new Average({});\n    return layer.apply(config) as SymbolicTensor | Tensor;\n  } else {\n    return new Average(config);\n  }\n}\n\nexport class Maximum extends Merge {\n  /** @nocollapse */\n  static className = 'Maximum';\n  constructor(args?: LayerArgs) {\n    super(args);\n  }\n\n  protected mergeFunction(inputs: Tensor[]): Tensor {\n    return tidy(() => {\n      let output = inputs[0];\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.maximum(output, inputs[i]);\n      }\n      return output;\n    });\n  }\n}\nserialization.registerClass(Maximum);\n\n/**\n * Calculate the element-wise maximum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Maximum` layer, by using no input argument\n *    or a single configuration argument. The resultant `Maximum` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const maximumLayer = tf.layers.maximum();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = maximumLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.maximum([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 20, 3, 40], [2, 2]);\n * const input2 = tf.tensor2d([10, 2, 30, 4], [2, 2]);\n * tf.layers.maximum([input1, input2]).print();\n * // Gives [[10, 20], [30, 40]].\n *\n */\nexport function maximum(config?: SymbolicTensor[]|Tensor[]|LayerArgs): Layer|\n    SymbolicTensor|Tensor {\n  if (Array.isArray(config)) {\n    const layer = new Maximum({});\n    return layer.apply(config) as SymbolicTensor | Tensor;\n  } else {\n    return new Maximum(config);\n  }\n}\n\nexport class Minimum extends Merge {\n  /** @nocollapse */\n  static className = 'Minimum';\n  constructor(args?: LayerArgs) {\n    super(args);\n  }\n\n  protected mergeFunction(inputs: Tensor[]): Tensor {\n    return tidy(() => {\n      let output = inputs[0];\n      for (let i = 1; i < inputs.length; ++i) {\n        output = tfc.minimum(output, inputs[i]);\n      }\n      return output;\n    });\n  }\n}\nserialization.registerClass(Minimum);\n\n/**\n * Calculate the element-wise minimum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Minimum` layer, by using no input argument\n *    or a single configuration argument. The resultant `Minimum` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const minimumLayer = tf.layers.minimum();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = minimumLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.minimum([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 20, 3, 40], [2, 2]);\n * const input2 = tf.tensor2d([10, 2, 30, 4], [2, 2]);\n * tf.layers.minimum([input1, input2]).print();\n * // Gives [[1, 2], [3, 4]].\n *\n */\nexport function minimum(config?: SymbolicTensor[]|Tensor[]|LayerArgs): Layer|\n    SymbolicTensor|Tensor {\n  if (Array.isArray(config)) {\n    const layer = new Minimum({});\n    return layer.apply(config) as SymbolicTensor | Tensor;\n  } else {\n    return new Minimum(config);\n  }\n}\n\nexport declare interface ConcatenateLayerArgs extends LayerArgs {\n  /**\n   * Axis along which to concatenate.\n   */\n  axis?: number;\n}\n\nexport class Concatenate extends Merge {\n  /** @nocollapse */\n  static className = 'Concatenate';\n  readonly DEFAULT_AXIS = -1;\n  private readonly axis: number;\n\n  constructor(args?: ConcatenateLayerArgs) {\n    super(args);\n    if (args == null) {\n      args = {};\n    }\n    this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;\n    this.supportsMasking = true;\n    this.reshapeRequired = false;\n  }\n\n  build(inputShape: Shape|Shape[]): void {\n    // Used purely for shape validation.]\n    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) ||\n        inputShape.length === 1) {\n      throw new ValueError(\n          'A `Concatenate` layer should be called on a list of at least 2 ' +\n          'inputs');\n    }\n    inputShape = inputShape as Shape[];\n\n    let allNoneShape = true;\n    for (const shape of inputShape) {\n      if (shape != null) {\n        allNoneShape = false;\n        break;\n      }\n    }\n    if (allNoneShape) {\n      return;\n    }\n\n    const shapeSet: Shape[] = [];\n    for (let i = 0; i < inputShape.length; ++i) {\n      const shapeWithoutConcatAxis = inputShape[i].slice();\n      shapeWithoutConcatAxis.splice(this.axis, 1);\n      let exists = false;\n      for (const shape of shapeSet) {\n        if (util.arraysEqual(shape, shapeWithoutConcatAxis)) {\n          exists = true;\n          break;\n        }\n      }\n      if (!exists) {\n        shapeSet.push(shapeWithoutConcatAxis);\n      }\n    }\n    if (shapeSet.length > 1) {\n      throw new ValueError(\n          'A `Concatenate` layer requires inputs with matching shapes ' +\n          'except for the concat axis. Got input shapes: ' +\n          JSON.stringify(inputShape));\n    }\n  }\n\n  protected mergeFunction(inputs: Tensor[]): Tensor {\n    return tidy(() => {\n      return K.concatenate(inputs, this.axis);\n    });\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {\n      throw new ValueError(\n          'A `Concatenate` layer should be called on a list of inputs.');\n    }\n    const inputShapes = inputShape as Shape[];\n    const outputShape = inputShapes[0].slice();\n    const axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;\n    // Porting Note: the line above is because TypeScript doesn't support\n    //   negative indices.\n    for (const shape of inputShapes.slice(1)) {\n      if (outputShape[axis] == null || shape[axis] == null) {\n        outputShape[axis] = null;\n        break;\n      }\n      outputShape[axis] += shape[axis];\n    }\n    return outputShape;\n  }\n\n  computeMask(inputs: Tensor|Tensor[], mask?: Tensor|Tensor[]): Tensor {\n    if (mask == null) {\n      return null;\n    }\n    if (!Array.isArray(mask)) {\n      throw new ValueError('`mask` should be an array for Concatenate');\n    }\n    if (!Array.isArray(inputs)) {\n      throw new ValueError('`inputs` should be an array for Concatenate');\n    }\n    if (mask.length !== inputs.length) {\n      throw new ValueError(\n          `Mismatch in the length of mask (${mask.length}) ` +\n          `and the legnth of inputs (${inputs.length})`);\n    }\n    return tfc.tidy(() => {\n      let allNullMasks = true;\n      mask.forEach(m => {\n        if (m != null) {\n          allNullMasks = false;\n          return;\n        }\n      });\n      if (allNullMasks) {\n        return null;\n      }\n      const outputMasks: Tensor[] = [];\n      for (let i = 0; i < inputs.length; ++i) {\n        if (mask[i] == null) {\n          // Input is unmasked. Append all 1's to masks.\n          outputMasks.push(tfc.cast(tfc.onesLike(inputs[i]), 'bool'));\n        } else if (mask[i].rank < inputs[i].rank) {\n          // Mask is smaller than the input, expand it.\n          outputMasks.push(tfc.expandDims(mask[i], -1));\n        } else {\n          outputMasks.push(mask[i]);\n        }\n      }\n      const concatenatedMasks = tfc.concat(outputMasks, this.axis);\n      return tfc.all(concatenatedMasks, -1, false);\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      'axis': this.axis,\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nserialization.registerClass(Concatenate);\n\n/**\n * Concatenate an `Array` of inputs.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Concatenate` layer, by using no input argument\n *    or a single configuration argument. The resultant `Concatenate` layer can\n *    then be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const concatLayer = tf.layers.concatenate();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 3]});\n * const input2 = tf.input({shape: [2, 4]});\n * const output = concatLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 7], with the first dimension as the undetermined batch\n * // dimension and the last dimension as the result of concatenating the\n * // last dimensions of the two inputs.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 3]});\n * const input2 = tf.input({shape: [2, 4]});\n * const output = tf.layers.concatenate([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension and the last dimension as the result of concatenating the\n * // last dimensions of the two inputs.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([[1, 2], [3, 4]], [2, 2]);\n * const input2 = tf.tensor2d([[10, 20], [30, 40]], [2, 2]);\n * tf.layers.concatenate([input1, input2]).print();\n * // Gives [[1, 2, 10, 20], [3, 4, 30, 40]].\n *\n */\nexport function concatenate(config?: SymbolicTensor[]|Tensor[]|\n                            ConcatenateLayerArgs): Layer|SymbolicTensor|Tensor {\n  if (Array.isArray(config)) {\n    const layer = new Concatenate({});\n    return layer.apply(config) as SymbolicTensor | Tensor;\n  } else {\n    return new Concatenate(config);\n  }\n}\n\nexport declare interface DotLayerArgs extends LayerArgs {\n  /**\n   * Axis or axes along which the dot product will be taken.\n   *\n   * Integer or an Array of integers.\n   */\n  axes: number|[number, number];\n\n  /**\n   * Whether to L2-normalize samples along the dot product axis\n   * before taking the dot product.\n   *\n   * If set to `true`, the output of the dot product isthe cosine\n   * proximity between the two samples.\n   */\n  normalize?: boolean;\n}\n\n/**\n * Interpretable potentially negative axis index.\n *\n * For example, given axis = -1, and dim = 3, this function will return 2.\n *\n * @param axis The axis index, may be a positive, zero or negative integer.\n * @param dim Total number of dimensions, a positive integer.\n * @returns A non-negative axis index equivalent to the input `axis`.\n */\nfunction interpretAxis(axis: number, dim: number): number {\n  while (axis < 0) {\n    axis += dim;\n  }\n  return axis;\n}\n\nfunction batchDot(x: Tensor, y: Tensor, axes: number|[number, number]): Tensor {\n  if (x.shape.length > 3 || y.shape.length > 3) {\n    throw new NotImplementedError(\n        'batchDot is not implemented for tensors of 4D or higher rank yet');\n  }\n  tfc.util.assert(\n      x.shape.length >= 2,\n      () => `batchDot requires the rank of x to be >= 2, ` +\n          `but got ${x.shape.length}`);\n  tfc.util.assert(\n      x.shape.length >= 2,\n      () => `batchDot requires the rank of y to be >= 2, ` +\n          `but got ${y.shape.length}`);\n\n  if (typeof axes === 'number') {\n    axes = [axes, axes];\n  }\n\n  if (x.dtype === 'complex64' || y.dtype === 'complex64') {\n    throw new NotImplementedError(\n        'batchDot is not implemented for complex64-type Tensors yet.');\n  }\n\n  const xNDim = x.shape.length;\n  const yNDim = y.shape.length;\n  if (axes == null) {\n    // Behave like batchMatmul by default.\n    axes = [xNDim - 1, yNDim - 2];\n  }\n  const axesArray = axes as [number, number];\n\n  return tfc.tidy(() => {\n    let diff: number;\n    if (xNDim > yNDim) {\n      diff = xNDim - yNDim;\n      const diffShape: Shape = [];\n      for (let i = 0; i < diff; ++i) {\n        diffShape.push(1);\n      }\n      y = tfc.reshape(y, y.shape.concat(diffShape));\n    } else if (yNDim > xNDim) {\n      diff = yNDim - xNDim;\n      const diffShape: Shape = [];\n      for (let i = 0; i < diff; ++i) {\n        diffShape.push(1);\n      }\n      x = tfc.reshape(x, x.shape.concat(diffShape));\n    } else {\n      diff = 0;\n    }\n\n    let out: Tensor;\n    if (x.shape.length === 2 && y.shape.length === 2) {\n      if (axesArray[0] === axesArray[1]) {\n        out = tfc.sum(tfc.mul(x, y), axesArray[0]);\n      } else {\n        out = tfc.sum(tfc.mul(tfc.transpose(x, [1, 0]), y), axesArray[1]);\n      }\n    } else {\n      const adjX = axesArray[0] !== x.shape.length - 1;\n      const adjY = axesArray[1] === y.shape.length - 1;\n      out = tfc.matMul(x, y, adjX, adjY);\n    }\n\n    if (diff > 0) {\n      let idx: number;\n      if (xNDim > yNDim) {\n        idx = xNDim + yNDim - 3;\n      } else {\n        idx = xNDim - 1;\n      }\n      const squeezeAxes: number[] = [];\n      for (let i = idx; i < idx + diff; ++i) {\n        squeezeAxes.push(i);\n      }\n      out = tfc.squeeze(out, squeezeAxes);\n    }\n    if (out.shape.length === 1) {\n      out = tfc.expandDims(out, 1);\n    }\n    return out;\n  });\n}\n\nexport class Dot extends Merge {\n  /** @nocollapse */\n  static className = 'Dot';\n\n  private axes: number|[number, number];\n  private normalize: boolean;\n\n  constructor(args: DotLayerArgs) {\n    super(args);\n    this.axes = args.axes;\n    this.normalize = args.normalize == null ? false : args.normalize;\n    this.supportsMasking = true;\n    this.reshapeRequired = false;\n  }\n\n  build(inputShape: Shape|Shape[]): void {\n    tfc.util.assert(\n        Array.isArray(inputShape) && inputShape.length === 2 &&\n            Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]),\n        () => 'A `Dot` layer should be called on a list of exactly 2 inputs.');\n    const shape1 = inputShape[0] as Shape;\n    const shape2 = inputShape[1] as Shape;\n    if (shape1.length > 3 || shape2.length > 3) {\n      throw new NotImplementedError(\n          'Dot layer does not support tensors of 4D or higher rank yet.');\n    }\n\n    const axes = this.interpretAxes(shape1, shape2);\n    if (shape1[axes[0]] !== shape2[axes[1]]) {\n      throw new ValueError(\n          `Dimension incompatibility: ` +\n          `${shape1[axes[0]]} !== ${shape2[axes[1]]}`);\n    }\n  }\n\n  protected mergeFunction(inputs: Tensor[]): Tensor {\n    if (inputs.length !== 2) {\n      throw new ValueError(\n          'A `Dot` layer must be called on exactly 2 inputs, ' +\n          `but received ${inputs.length} input(s).`);\n    }\n\n    let x1 = inputs[0];\n    let x2 = inputs[1];\n    let axes: [number, number];\n    if (!Array.isArray(this.axes)) {\n      axes = [\n        interpretAxis(this.axes, x1.shape.length),\n        interpretAxis(this.axes, x2.shape.length)\n      ];\n    } else {\n      axes = this.axes.map(\n                 (axis, i) => interpretAxis(\n                     axis, inputs[i].shape.length)) as [number, number];\n    }\n    if (this.normalize) {\n      x1 = l2Normalize(x1, axes[0]);\n      x2 = l2Normalize(x2, axes[1]);\n    }\n    return batchDot(x1, x2, axes);\n  }\n\n  private interpretAxes(shape1: Shape, shape2: Shape): number[] {\n    let axes: number[];\n    if (!Array.isArray(this.axes)) {\n      // `this.axes` is a single integer.\n      axes = [\n        interpretAxis(this.axes, shape1.length),\n        interpretAxis(this.axes, shape2.length)\n      ];\n    } else {\n      // `this.axes` is an Array of integers.\n      axes = this.axes;\n    }\n    return axes;\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    tfc.util.assert(\n        Array.isArray(inputShape) && inputShape.length === 2 &&\n            Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]),\n        () => 'A `Dot` layer should be called on a list of exactly 2 inputs.');\n    const shape1 = (inputShape[0] as Shape).slice();\n    const shape2 = (inputShape[1] as Shape).slice();\n    if (shape1.length > 3 || shape2.length > 3) {\n      throw new NotImplementedError(\n          'Dot layer does not support tensors of 4D or higher rank yet.');\n    }\n\n    const axes = this.interpretAxes(shape1, shape2);\n    shape1.splice(axes[0], 1);\n    shape2.splice(axes[1], 1);\n    shape2.splice(0, 1);\n    const outputShape = shape1.concat(shape2);\n    if (outputShape.length === 1) {\n      outputShape.push(1);\n    }\n    return outputShape;\n  }\n\n  computeMask(inputs: Tensor|Tensor[], mask?: Tensor|Tensor[]): Tensor {\n    return null;\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config: serialization.ConfigDict = {\n      'axes': this.axes,\n      'normalize': this.normalize\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\nserialization.registerClass(Dot);\n\n// TODO(cais): Add functional interfaces for the merge layers.\n"]},"metadata":{},"sourceType":"module"}