{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\n\nexport function makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n\n  if (dtype === 'complex64') {\n    throw new Error(`Cannot construct a complex64 tensor directly. ` + `Please use tf.complex(real, imag).`);\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` + `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` + `(${inferredShape}) does not match the provided ` + `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,MAAR,QAAqB,WAArB;AAIA,SAAQC,MAAR,EAAgBC,kCAAhB,EAAoDC,OAApD,EAA6DC,UAA7D,EAAyEC,YAAzE,EAAuFC,aAAvF,EAAsGC,YAAtG,QAAyH,SAAzH;AAEA;;AACA,OAAM,SAAUC,UAAV,CACFC,MADE,EACkBC,KADlB,EACmCC,aADnC,EAEFC,KAFE,EAEc;AAClB,MAAIA,KAAK,IAAI,IAAb,EAAmB;AACjBA,SAAK,GAAGR,UAAU,CAACK,MAAD,CAAlB;AACD;;AACD,MAAIG,KAAK,KAAK,WAAd,EAA2B;AACzB,UAAM,IAAIC,KAAJ,CACF,mDACA,oCAFE,CAAN;AAGD;;AACD,MAAI,CAACR,YAAY,CAACI,MAAD,CAAb,IAAyB,CAACK,KAAK,CAACC,OAAN,CAAcN,MAAd,CAA1B,IACA,OAAOA,MAAP,KAAkB,QADlB,IAC8B,OAAOA,MAAP,KAAkB,SADhD,IAEA,OAAOA,MAAP,KAAkB,QAFtB,EAEgC;AAC9B,UAAM,IAAII,KAAJ,CACF,wEACA,uDAFE,CAAN;AAGD;;AACD,MAAIH,KAAK,IAAI,IAAb,EAAmB;AACjBR,sCAAkC,CAACQ,KAAD,CAAlC;AAEA,UAAMM,YAAY,GAAGV,aAAa,CAACI,KAAD,CAAlC;AACA,UAAMO,YAAY,GAAGX,aAAa,CAACK,aAAD,CAAlC;AACAV,UAAM,CACFe,YAAY,KAAKC,YADf,EAEF,MACI,iCAAiCP,KAAK,4BAAtC,GACA,GAAGM,YAAY,mBAAmBC,YAAY,EAJhD,CAAN;;AAMA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,aAAa,CAACQ,MAAlC,EAA0C,EAAED,CAA5C,EAA+C;AAC7C,YAAME,QAAQ,GAAGT,aAAa,CAACO,CAAD,CAA9B;AACA,YAAMG,iBAAiB,GAAGH,CAAC,KAAKP,aAAa,CAACQ,MAAd,GAAuB,CAA7B,GACtBC,QAAQ,KAAKd,aAAa,CAACI,KAAK,CAACY,KAAN,CAAYJ,CAAZ,CAAD,CADJ,GAEtB,IAFJ;AAGAjB,YAAM,CACFU,aAAa,CAACO,CAAD,CAAb,KAAqBR,KAAK,CAACQ,CAAD,CAA1B,IAAiC,CAACG,iBADhC,EAEF,MAAM,iDACF,IAAIV,aAAa,gCADf,GAEF,UAAUD,KAAK,KAJjB,CAAN;AAKD;AACF;;AAED,MAAI,CAACL,YAAY,CAACI,MAAD,CAAb,IAAyB,CAACK,KAAK,CAACC,OAAN,CAAcN,MAAd,CAA9B,EAAqD;AACnDA,UAAM,GAAG,CAACA,MAAD,CAAT;AACD;;AAEDC,OAAK,GAAGA,KAAK,IAAIC,aAAjB;AACAF,QAAM,GAAGG,KAAK,KAAK,QAAV,GACLL,YAAY,CAACE,MAAD,EAASG,KAAT,CADP,GAELT,OAAO,CAACM,MAAD,EAAqB,EAArB,EAAyB,IAAzB,CAFX;AAGA,SAAOT,MAAM,CAACQ,UAAP,CAAkBC,MAAlB,EAAwCC,KAAxC,EAA+CE,KAA/C,CAAP;AACD","names":["ENGINE","assert","assertNonNegativeIntegerDimensions","flatten","inferDtype","isTypedArray","sizeFromShape","toTypedArray","makeTensor","values","shape","inferredShape","dtype","Error","Array","isArray","providedSize","inferredSize","i","length","inferred","flatDimsDontMatch","slice"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/ops/tensor_ops_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {TensorLike, TypedArray} from '../types';\nimport {DataType} from '../types';\nimport {assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray} from '../util';\n\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(\n    values: TensorLike, shape: number[], inferredShape: number[],\n    dtype?: DataType): Tensor {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n  if (dtype === 'complex64') {\n    throw new Error(\n        `Cannot construct a complex64 tensor directly. ` +\n        `Please use tf.complex(real, imag).`);\n  }\n  if (!isTypedArray(values) && !Array.isArray(values) &&\n      typeof values !== 'number' && typeof values !== 'boolean' &&\n      typeof values !== 'string') {\n    throw new Error(\n        'values passed to tensor(values) must be a number/boolean/string or ' +\n        'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(\n        providedSize === inferredSize,\n        () =>\n            `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ?\n          inferred !== sizeFromShape(shape.slice(i)) :\n          true;\n      assert(\n          inferredShape[i] === shape[i] || !flatDimsDontMatch,\n          () => `Error creating a new Tensor. Inferred shape ` +\n              `(${inferredShape}) does not match the provided ` +\n              `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values] as number[];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ?\n      toTypedArray(values, dtype) :\n      flatten(values as string[], [], true) as string[];\n  return ENGINE.makeTensor(values as TypedArray, shape, dtype);\n}\n"]},"metadata":{},"sourceType":"module"}