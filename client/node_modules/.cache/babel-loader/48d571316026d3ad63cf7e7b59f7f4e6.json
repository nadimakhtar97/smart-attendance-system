{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { FlipLeftRight, util } from '@tensorflow/tfjs-core';\nexport const flipLeftRightConfig = {\n  kernelName: FlipLeftRight,\n  backendName: 'cpu',\n  kernelFunc: _ref => {\n    let {\n      inputs,\n      attrs,\n      backend\n    } = _ref;\n    const {\n      image\n    } = inputs;\n    const cpuBackend = backend;\n    const output = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(image.shape));\n    const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n    const imageVals = cpuBackend.data.get(image.dataId).values;\n\n    for (let batchIdx = 0; batchIdx < batch; batchIdx++) {\n      const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;\n\n      for (let row = 0; row < imageHeight; row++) {\n        const rowOffset = row * (imageWidth * numChannels);\n\n        for (let col = 0; col < imageWidth; col++) {\n          const colOffset = col * numChannels;\n\n          for (let channel = 0; channel < numChannels; channel++) {\n            const coordX = Math.round(imageWidth - col - 1);\n            const outIdx = batchOffset + rowOffset + colOffset + channel;\n            let outputValue = imageVals[outIdx]; // If the coordinate position falls within the image boundaries...\n\n            if (coordX >= 0 && coordX < imageWidth) {\n              // set the output to the image value at the coordinate position.\n              const rotatedColOffset = coordX * numChannels;\n              const imageIdx = batchOffset + rowOffset + rotatedColOffset + channel;\n              outputValue = imageVals[imageIdx];\n            }\n\n            output[outIdx] = outputValue;\n          }\n        }\n      }\n    }\n\n    const dataId = cpuBackend.write(output, image.shape, image.dtype);\n    return {\n      dataId,\n      shape: image.shape,\n      dtype: image.dtype\n    };\n  }\n};","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAkBA,SAAQA,aAAR,EAA4CC,IAA5C,QAAuD,uBAAvD;AAIA,OAAO,MAAMC,mBAAmB,GAAiB;AAC/CC,YAAU,EAAEH,aADmC;AAE/CI,aAAW,EAAE,KAFkC;AAG/CC,YAAU,EAAE,QAA6B;AAAA,QAA5B;AAACC,YAAD;AAASC,WAAT;AAAgBC;AAAhB,KAA4B;AACvC,UAAM;AAACC;AAAD,QAAUH,MAAhB;AACA,UAAMI,UAAU,GAAGF,OAAnB;AAEA,UAAMG,MAAM,GAAGV,IAAI,CAACW,sBAAL,CACXH,KAAK,CAACI,KADK,EACqBZ,IAAI,CAACa,aAAL,CAAmBL,KAAK,CAACM,KAAzB,CADrB,CAAf;AAEA,UAAM,CAACC,KAAD,EAAQC,WAAR,EAAqBC,UAArB,EAAiCC,WAAjC,IAAgDV,KAAK,CAACM,KAA5D;AAEA,UAAMK,SAAS,GAAGV,UAAU,CAACW,IAAX,CAAgBC,GAAhB,CAAoBb,KAAK,CAACc,MAA1B,EAAkCC,MAApD;;AAEA,SAAK,IAAIC,QAAQ,GAAG,CAApB,EAAuBA,QAAQ,GAAGT,KAAlC,EAAyCS,QAAQ,EAAjD,EAAqD;AACnD,YAAMC,WAAW,GAAGD,QAAQ,GAAGP,UAAX,GAAwBD,WAAxB,GAAsCE,WAA1D;;AAEA,WAAK,IAAIQ,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGV,WAAxB,EAAqCU,GAAG,EAAxC,EAA4C;AAC1C,cAAMC,SAAS,GAAGD,GAAG,IAAIT,UAAU,GAAGC,WAAjB,CAArB;;AAEA,aAAK,IAAIU,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGX,UAAxB,EAAoCW,GAAG,EAAvC,EAA2C;AACzC,gBAAMC,SAAS,GAAGD,GAAG,GAAGV,WAAxB;;AAEA,eAAK,IAAIY,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGZ,WAAhC,EAA6CY,OAAO,EAApD,EAAwD;AACtD,kBAAMC,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWhB,UAAU,GAAGW,GAAb,GAAmB,CAA9B,CAAf;AACA,kBAAMM,MAAM,GAAGT,WAAW,GAAGE,SAAd,GAA0BE,SAA1B,GAAsCC,OAArD;AAEA,gBAAIK,WAAW,GAAGhB,SAAS,CAACe,MAAD,CAA3B,CAJsD,CAKtD;;AACA,gBAAIH,MAAM,IAAI,CAAV,IAAeA,MAAM,GAAGd,UAA5B,EAAwC;AACtC;AACA,oBAAMmB,gBAAgB,GAAGL,MAAM,GAAGb,WAAlC;AACA,oBAAMmB,QAAQ,GACVZ,WAAW,GAAGE,SAAd,GAA0BS,gBAA1B,GAA6CN,OADjD;AAEAK,yBAAW,GAAGhB,SAAS,CAACkB,QAAD,CAAvB;AACD;;AACD3B,kBAAM,CAACwB,MAAD,CAAN,GAAiBC,WAAjB;AACD;AACF;AACF;AACF;;AAED,UAAMb,MAAM,GAAGb,UAAU,CAAC6B,KAAX,CAAiB5B,MAAjB,EAAyBF,KAAK,CAACM,KAA/B,EAAsCN,KAAK,CAACI,KAA5C,CAAf;AACA,WAAO;AAACU,YAAD;AAASR,WAAK,EAAEN,KAAK,CAACM,KAAtB;AAA6BF,WAAK,EAAEJ,KAAK,CAACI;AAA1C,KAAP;AACD;AA3C8C,CAA1C","names":["FlipLeftRight","util","flipLeftRightConfig","kernelName","backendName","kernelFunc","inputs","attrs","backend","image","cpuBackend","output","getTypedArrayFromDType","dtype","sizeFromShape","shape","batch","imageHeight","imageWidth","numChannels","imageVals","data","get","dataId","values","batchIdx","batchOffset","row","rowOffset","col","colOffset","channel","coordX","Math","round","outIdx","outputValue","rotatedColOffset","imageIdx","write"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/FlipLeftRight.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, NumericDataType, TypedArray} from '@tensorflow/tfjs-core';\nimport {FlipLeftRight, FlipLeftRightInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport const flipLeftRightConfig: KernelConfig = {\n  kernelName: FlipLeftRight,\n  backendName: 'cpu',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {image} = inputs as FlipLeftRightInputs;\n    const cpuBackend = backend as MathBackendCPU;\n\n    const output = util.getTypedArrayFromDType(\n        image.dtype as NumericDataType, util.sizeFromShape(image.shape));\n    const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n\n    const imageVals = cpuBackend.data.get(image.dataId).values as TypedArray;\n\n    for (let batchIdx = 0; batchIdx < batch; batchIdx++) {\n      const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;\n\n      for (let row = 0; row < imageHeight; row++) {\n        const rowOffset = row * (imageWidth * numChannels);\n\n        for (let col = 0; col < imageWidth; col++) {\n          const colOffset = col * numChannels;\n\n          for (let channel = 0; channel < numChannels; channel++) {\n            const coordX = Math.round(imageWidth - col - 1);\n            const outIdx = batchOffset + rowOffset + colOffset + channel;\n\n            let outputValue = imageVals[outIdx];\n            // If the coordinate position falls within the image boundaries...\n            if (coordX >= 0 && coordX < imageWidth) {\n              // set the output to the image value at the coordinate position.\n              const rotatedColOffset = coordX * numChannels;\n              const imageIdx =\n                  batchOffset + rowOffset + rotatedColOffset + channel;\n              outputValue = imageVals[imageIdx];\n            }\n            output[outIdx] = outputValue;\n          }\n        }\n      }\n    }\n\n    const dataId = cpuBackend.write(output, image.shape, image.dtype);\n    return {dataId, shape: image.shape, dtype: image.dtype};\n  }\n};\n"]},"metadata":{},"sourceType":"module"}