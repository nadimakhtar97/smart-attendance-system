{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { add } from '../kernels/Add';\nimport { complex } from '../kernels/Complex';\nimport { concat } from '../kernels/Concat';\nimport { identity } from '../kernels/Identity';\nimport { imag } from '../kernels/Imag';\nimport { multiply } from '../kernels/Multiply';\nimport { real } from '../kernels/Real';\nimport { realDivConfig } from '../kernels/RealDiv';\nimport { slice } from '../kernels/Slice';\nimport { sub } from '../kernels/Sub';\n/**\n * Calculate FFT of inner most elements of batch tensor.\n */\n\nexport function fftBatch(input, inverse, cpuBackend) {\n  const inputShape = input.shape;\n  const batch = inputShape[0];\n  const innerDim = inputShape[1];\n  const inputVals = cpuBackend.data.get(input.dataId);\n  const real2D = inputVals.complexTensorInfos.real;\n  const imag2D = inputVals.complexTensorInfos.imag; // Collects real and imaginary values separately.\n\n  const resultShape = [batch, innerDim];\n  const resultSize = util.sizeFromShape(resultShape);\n  const resultReal = util.getTypedArrayFromDType('float32', resultSize);\n  const resultImag = util.getTypedArrayFromDType('float32', resultSize);\n\n  for (let b = 0; b < batch; b++) {\n    // TODO: Support slice ops for complex type.\n    const r = slice({\n      inputs: {\n        x: real2D\n      },\n      backend: cpuBackend,\n      attrs: {\n        begin: [b, 0],\n        size: [1, innerDim]\n      }\n    });\n    const i = slice({\n      inputs: {\n        x: imag2D\n      },\n      backend: cpuBackend,\n      attrs: {\n        begin: [b, 0],\n        size: [1, innerDim]\n      }\n    });\n    const input = complex({\n      inputs: {\n        real: r,\n        imag: i\n      },\n      backend: cpuBackend\n    }); // Run FFT by batch element.\n\n    const {\n      real,\n      imag\n    } = fftImpl(input, inverse, cpuBackend);\n    const res = backend_util.mergeRealAndImagArrays(real, imag);\n\n    for (let d = 0; d < innerDim; d++) {\n      const c = backend_util.getComplexWithIndex(res, d);\n      resultReal[b * innerDim + d] = c.real;\n      resultImag[b * innerDim + d] = c.imag;\n    }\n\n    cpuBackend.disposeIntermediateTensorInfo(r);\n    cpuBackend.disposeIntermediateTensorInfo(i);\n    cpuBackend.disposeIntermediateTensorInfo(input);\n  }\n\n  const $realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n  const $imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n  const result = complex({\n    inputs: {\n      real: $realInfo,\n      imag: $imagInfo\n    },\n    backend: cpuBackend\n  });\n  cpuBackend.disposeIntermediateTensorInfo($realInfo);\n  cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n  return result;\n}\nexport function fftImpl(input, inverse, cpuBackend) {\n  const inputSize = util.sizeFromShape(input.shape);\n  const inputVals = cpuBackend.data.get(input.dataId);\n  const realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;\n  const imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;\n\n  if (isExponentOf2(inputSize)) {\n    const result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n    const resultShape = [input.shape[0], input.shape[1]];\n\n    if (inverse) {\n      const realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n      const imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n      const sizeInfo = cpuBackend.makeTensorInfo([], 'float32', util.createScalarValue(inputSize, 'float32'));\n      const sizeInfoCopy = identity({\n        inputs: {\n          x: sizeInfo\n        },\n        backend: cpuBackend\n      });\n      const divRealInfo = realDivConfig.kernelFunc({\n        inputs: {\n          a: realInfo,\n          b: sizeInfo\n        },\n        backend: cpuBackend\n      });\n      const divImagInfo = realDivConfig.kernelFunc({\n        inputs: {\n          a: imagInfo,\n          b: sizeInfoCopy\n        },\n        backend: cpuBackend\n      });\n      const divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;\n      const divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;\n      cpuBackend.disposeIntermediateTensorInfo(realInfo);\n      cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n      cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n      cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n      return {\n        real: divRealVals,\n        imag: divImagVals\n      };\n    }\n\n    return result;\n  } else {\n    const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n    const rawOutput = fourierTransformByMatmul(data, inputSize, inverse);\n    return backend_util.splitRealAndImagArrays(rawOutput);\n  }\n}\n\nfunction isExponentOf2(size) {\n  return (size & size - 1) === 0;\n} // FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\n\n\nfunction fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {\n  if (size === 1) {\n    return {\n      real: realVals,\n      imag: imagVals\n    };\n  }\n\n  const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n  const half = size / 2;\n  const evenComplex = backend_util.complexWithEvenIndex(data);\n  const evenRealVals = evenComplex.real;\n  const evenImagVals = evenComplex.imag;\n  const evenShape = [evenRealVals.length];\n  const evenRealInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n  const evenImagInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n  const evenTensorInfo = complex({\n    inputs: {\n      real: evenRealInfo,\n      imag: evenImagInfo\n    },\n    backend: cpuBackend\n  });\n  const oddComplex = backend_util.complexWithOddIndex(data);\n  const oddRealVals = oddComplex.real;\n  const oddImagVals = oddComplex.imag;\n  const oddShape = [oddRealVals.length];\n  const oddRealInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n  const oddImagInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n  const oddTensorInfo = complex({\n    inputs: {\n      real: oddRealInfo,\n      imag: oddImagInfo\n    },\n    backend: cpuBackend\n  }); // Recursive call for half part of original input.\n\n  const $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n  const $evenRealVals = $evenComplex.real;\n  const $evenImagVals = $evenComplex.imag;\n  const $evenShape = [$evenRealVals.length];\n  const $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n  const $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n  const $evenTensorInfo = complex({\n    inputs: {\n      real: $evenRealInfo,\n      imag: $evenImagInfo\n    },\n    backend: cpuBackend\n  });\n  const $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n  const $oddRealVals = $oddComplex.real;\n  const $oddImagVals = $oddComplex.imag;\n  const $oddShape = [$oddRealVals.length];\n  const $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n  const $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n  const $oddTensorInfo = complex({\n    inputs: {\n      real: $oddRealInfo,\n      imag: $oddImagInfo\n    },\n    backend: cpuBackend\n  });\n  const e = backend_util.exponents(size, inverse);\n  const eShape = [e.real.length];\n  const eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n  const eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n  const complexInfo = complex({\n    inputs: {\n      real: eRealInfo,\n      imag: eImagInfo\n    },\n    backend: cpuBackend\n  });\n  const exponentInfo = multiply({\n    inputs: {\n      a: complexInfo,\n      b: $oddTensorInfo\n    },\n    backend: cpuBackend\n  });\n  const addPart = add({\n    inputs: {\n      a: $evenTensorInfo,\n      b: exponentInfo\n    },\n    backend: cpuBackend\n  });\n  const subPart = sub({\n    inputs: {\n      a: $evenTensorInfo,\n      b: exponentInfo\n    },\n    backend: cpuBackend\n  });\n  const addPartReal = real({\n    inputs: {\n      input: addPart\n    },\n    backend: cpuBackend\n  });\n  const subPartReal = real({\n    inputs: {\n      input: subPart\n    },\n    backend: cpuBackend\n  });\n  const addPartImag = imag({\n    inputs: {\n      input: addPart\n    },\n    backend: cpuBackend\n  });\n  const subPartImag = imag({\n    inputs: {\n      input: subPart\n    },\n    backend: cpuBackend\n  });\n  const $real = concat({\n    inputs: [addPartReal, subPartReal],\n    backend: cpuBackend,\n    attrs: {\n      axis: 0\n    }\n  });\n  const $imag = concat({\n    inputs: [addPartImag, subPartImag],\n    backend: cpuBackend,\n    attrs: {\n      axis: 0\n    }\n  });\n  const $realVals = cpuBackend.data.get($real.dataId).values;\n  const $imagVals = cpuBackend.data.get($imag.dataId).values;\n  cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n  cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n  cpuBackend.disposeIntermediateTensorInfo(addPart);\n  cpuBackend.disposeIntermediateTensorInfo(subPart);\n  cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n  cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n  cpuBackend.disposeIntermediateTensorInfo($real);\n  cpuBackend.disposeIntermediateTensorInfo($imag);\n  return {\n    real: $realVals,\n    imag: $imagVals\n  };\n} // Calculate fourier transform by multplying sinusoid matrix.\n\n\nfunction fourierTransformByMatmul(data, size, inverse) {\n  const ret = new Float32Array(size * 2); // TODO: Use matmul instead once it supports complex64 type.\n\n  for (let r = 0; r < size; r++) {\n    let real = 0.0;\n    let imag = 0.0;\n\n    for (let c = 0; c < size; c++) {\n      const e = backend_util.exponent(r * c, size, inverse);\n      const term = backend_util.getComplexWithIndex(data, c);\n      real += term.real * e.real - term.imag * e.imag;\n      imag += term.real * e.imag + term.imag * e.real;\n    }\n\n    if (inverse) {\n      real /= size;\n      imag /= size;\n    }\n\n    backend_util.assignToTypedArray(ret, real, imag, r);\n  }\n\n  return ret;\n}","map":{"version":3,"mappings":"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","names":["backend_util","util","add","complex","concat","identity","imag","multiply","real","realDivConfig","slice","sub","fftBatch","input","inverse","cpuBackend","inputShape","shape","batch","innerDim","inputVals","data","get","dataId","real2D","complexTensorInfos","imag2D","resultShape","resultSize","sizeFromShape","resultReal","getTypedArrayFromDType","resultImag","b","r","inputs","x","backend","attrs","begin","size","i","fftImpl","res","mergeRealAndImagArrays","d","c","getComplexWithIndex","disposeIntermediateTensorInfo","$realInfo","makeTensorInfo","$imagInfo","result","inputSize","realVals","values","imagVals","isExponentOf2","fftRadix2","realInfo","imagInfo","sizeInfo","createScalarValue","sizeInfoCopy","divRealInfo","kernelFunc","a","divImagInfo","divRealVals","divImagVals","rawOutput","fourierTransformByMatmul","splitRealAndImagArrays","half","evenComplex","complexWithEvenIndex","evenRealVals","evenImagVals","evenShape","length","evenRealInfo","evenImagInfo","evenTensorInfo","oddComplex","complexWithOddIndex","oddRealVals","oddImagVals","oddShape","oddRealInfo","oddImagInfo","oddTensorInfo","$evenComplex","$evenRealVals","$evenImagVals","$evenShape","$evenRealInfo","$evenImagInfo","$evenTensorInfo","$oddComplex","$oddRealVals","$oddImagVals","$oddShape","$oddRealInfo","$oddImagInfo","$oddTensorInfo","e","exponents","eShape","eRealInfo","eImagInfo","complexInfo","exponentInfo","addPart","subPart","addPartReal","subPartReal","addPartImag","subPartImag","$real","axis","$imag","$realVals","$imagVals","ret","Float32Array","exponent","term","assignToTypedArray"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/utils/fft_utils.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Tensor, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {add} from '../kernels/Add';\nimport {complex} from '../kernels/Complex';\nimport {concat} from '../kernels/Concat';\nimport {identity} from '../kernels/Identity';\nimport {imag} from '../kernels/Imag';\nimport {multiply} from '../kernels/Multiply';\nimport {real} from '../kernels/Real';\nimport {realDivConfig} from '../kernels/RealDiv';\nimport {slice} from '../kernels/Slice';\nimport {sub} from '../kernels/Sub';\n\n/**\n * Calculate FFT of inner most elements of batch tensor.\n */\nexport function fftBatch(\n    input: TensorInfo, inverse: boolean,\n    cpuBackend: MathBackendCPU): TensorInfo {\n  const inputShape = input.shape;\n  const batch = inputShape[0];\n  const innerDim = inputShape[1];\n\n  const inputVals = cpuBackend.data.get(input.dataId);\n\n  const real2D = inputVals.complexTensorInfos.real;\n  const imag2D = inputVals.complexTensorInfos.imag;\n\n  // Collects real and imaginary values separately.\n  const resultShape = [batch, innerDim];\n  const resultSize = util.sizeFromShape(resultShape);\n  const resultReal = util.getTypedArrayFromDType('float32', resultSize);\n  const resultImag = util.getTypedArrayFromDType('float32', resultSize);\n\n  for (let b = 0; b < batch; b++) {\n    // TODO: Support slice ops for complex type.\n    const r = slice({\n      inputs: {x: real2D},\n      backend: cpuBackend,\n      attrs: {begin: [b, 0], size: [1, innerDim]}\n    });\n    const i = slice({\n      inputs: {x: imag2D},\n      backend: cpuBackend,\n      attrs: {begin: [b, 0], size: [1, innerDim]}\n    });\n\n    const input = complex({inputs: {real: r, imag: i}, backend: cpuBackend});\n\n    // Run FFT by batch element.\n    const {real, imag} = fftImpl(input, inverse, cpuBackend);\n    const res = backend_util.mergeRealAndImagArrays(real, imag);\n\n    for (let d = 0; d < innerDim; d++) {\n      const c = backend_util.getComplexWithIndex(res, d);\n      resultReal[b * innerDim + d] = c.real;\n      resultImag[b * innerDim + d] = c.imag;\n    }\n\n    cpuBackend.disposeIntermediateTensorInfo(r);\n    cpuBackend.disposeIntermediateTensorInfo(i);\n    cpuBackend.disposeIntermediateTensorInfo(input);\n  }\n\n  const $realInfo: TensorInfo =\n      cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n  const $imagInfo: TensorInfo =\n      cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n\n  const result = complex(\n      {inputs: {real: $realInfo, imag: $imagInfo}, backend: cpuBackend});\n\n  cpuBackend.disposeIntermediateTensorInfo($realInfo);\n  cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n\n  return result;\n}\n\nexport function fftImpl(\n    input: TensorInfo, inverse: boolean,\n    cpuBackend: MathBackendCPU): {real: Float32Array, imag: Float32Array} {\n  const inputSize = util.sizeFromShape(input.shape);\n\n  const inputVals = cpuBackend.data.get(input.dataId);\n\n  const realVals =\n      cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values as\n      Float32Array;\n\n  const imagVals =\n      cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values as\n      Float32Array;\n\n  if (isExponentOf2(inputSize)) {\n    const result =\n        fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n\n    const resultShape = [input.shape[0], input.shape[1]];\n\n    if (inverse) {\n      const realInfo: TensorInfo =\n          cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n      const imagInfo: TensorInfo =\n          cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n\n      const sizeInfo: TensorInfo = cpuBackend.makeTensorInfo(\n          [], 'float32',\n          util.createScalarValue(inputSize as {} as 'float32', 'float32'));\n      const sizeInfoCopy =\n          identity({inputs: {x: sizeInfo}, backend: cpuBackend});\n\n      const divRealInfo =\n          realDivConfig.kernelFunc(\n              {inputs: {a: realInfo, b: sizeInfo}, backend: cpuBackend}) as\n          TensorInfo;\n      const divImagInfo =\n          realDivConfig.kernelFunc(\n              {inputs: {a: imagInfo, b: sizeInfoCopy}, backend: cpuBackend}) as\n          TensorInfo;\n\n      const divRealVals =\n          cpuBackend.data.get(divRealInfo.dataId).values as Float32Array;\n      const divImagVals =\n          cpuBackend.data.get(divImagInfo.dataId).values as Float32Array;\n\n      cpuBackend.disposeIntermediateTensorInfo(realInfo);\n      cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n      cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n      cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n      cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n\n      return {real: divRealVals, imag: divImagVals};\n    }\n\n    return result;\n  } else {\n    const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n\n    const rawOutput =\n        fourierTransformByMatmul(data, inputSize, inverse) as Float32Array;\n\n    return backend_util.splitRealAndImagArrays(rawOutput);\n  }\n}\n\nfunction isExponentOf2(size: number): boolean {\n  return (size & size - 1) === 0;\n}\n\n// FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\nfunction fftRadix2(\n    realVals: Float32Array, imagVals: Float32Array, size: number,\n    inverse: boolean,\n    cpuBackend: MathBackendCPU): {real: Float32Array, imag: Float32Array} {\n  if (size === 1) {\n    return {real: realVals, imag: imagVals};\n  }\n\n  const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n\n  const half = size / 2;\n\n  const evenComplex = backend_util.complexWithEvenIndex(data);\n\n  const evenRealVals = evenComplex.real;\n  const evenImagVals = evenComplex.imag;\n\n  const evenShape = [evenRealVals.length];\n\n  const evenRealInfo =\n      cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n  const evenImagInfo =\n      cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n\n  const evenTensorInfo = complex(\n      {inputs: {real: evenRealInfo, imag: evenImagInfo}, backend: cpuBackend});\n\n  const oddComplex = backend_util.complexWithOddIndex(data);\n\n  const oddRealVals = oddComplex.real;\n  const oddImagVals = oddComplex.imag;\n\n  const oddShape = [oddRealVals.length];\n\n  const oddRealInfo =\n      cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n  const oddImagInfo =\n      cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n\n  const oddTensorInfo = complex(\n      {inputs: {real: oddRealInfo, imag: oddImagInfo}, backend: cpuBackend});\n\n  // Recursive call for half part of original input.\n  const $evenComplex =\n      fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n\n  const $evenRealVals = $evenComplex.real;\n  const $evenImagVals = $evenComplex.imag;\n\n  const $evenShape = [$evenRealVals.length];\n\n  const $evenRealInfo =\n      cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n  const $evenImagInfo =\n      cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n\n  const $evenTensorInfo = complex({\n    inputs: {real: $evenRealInfo, imag: $evenImagInfo},\n    backend: cpuBackend\n  });\n\n  const $oddComplex =\n      fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n\n  const $oddRealVals = $oddComplex.real;\n  const $oddImagVals = $oddComplex.imag;\n\n  const $oddShape = [$oddRealVals.length];\n\n  const $oddRealInfo =\n      cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n  const $oddImagInfo =\n      cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n\n  const $oddTensorInfo = complex(\n      {inputs: {real: $oddRealInfo, imag: $oddImagInfo}, backend: cpuBackend});\n\n  const e = backend_util.exponents(size, inverse);\n  const eShape = [e.real.length];\n\n  const eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n  const eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n\n  const complexInfo = complex(\n      {inputs: {real: eRealInfo, imag: eImagInfo}, backend: cpuBackend});\n\n  const exponentInfo =\n      multiply(\n          {inputs: {a: complexInfo, b: $oddTensorInfo}, backend: cpuBackend}) as\n      TensorInfo;\n\n  const addPart = add({\n                    inputs: {a: $evenTensorInfo, b: exponentInfo},\n                    backend: cpuBackend\n                  }) as TensorInfo;\n  const subPart = sub({\n                    inputs: {a: $evenTensorInfo, b: exponentInfo},\n                    backend: cpuBackend\n                  }) as TensorInfo;\n\n  const addPartReal = real({inputs: {input: addPart}, backend: cpuBackend});\n  const subPartReal = real({inputs: {input: subPart}, backend: cpuBackend});\n\n  const addPartImag = imag({inputs: {input: addPart}, backend: cpuBackend});\n  const subPartImag = imag({inputs: {input: subPart}, backend: cpuBackend});\n\n  const $real = concat({\n    inputs: [addPartReal as Tensor, subPartReal as Tensor],\n    backend: cpuBackend,\n    attrs: {axis: 0}\n  });\n  const $imag = concat({\n    inputs: [addPartImag as Tensor, subPartImag as Tensor],\n    backend: cpuBackend,\n    attrs: {axis: 0}\n  });\n\n  const $realVals = cpuBackend.data.get($real.dataId).values as Float32Array;\n  const $imagVals = cpuBackend.data.get($imag.dataId).values as Float32Array;\n\n  cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n  cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n  cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n  cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n  cpuBackend.disposeIntermediateTensorInfo(addPart);\n  cpuBackend.disposeIntermediateTensorInfo(subPart);\n  cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n  cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n  cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n  cpuBackend.disposeIntermediateTensorInfo($real);\n  cpuBackend.disposeIntermediateTensorInfo($imag);\n\n  return {real: $realVals, imag: $imagVals};\n}\n\n// Calculate fourier transform by multplying sinusoid matrix.\nfunction fourierTransformByMatmul(\n    data: TypedArray, size: number, inverse: boolean): TypedArray {\n  const ret = new Float32Array(size * 2);\n  // TODO: Use matmul instead once it supports complex64 type.\n  for (let r = 0; r < size; r++) {\n    let real = 0.0;\n    let imag = 0.0;\n    for (let c = 0; c < size; c++) {\n      const e = backend_util.exponent(r * c, size, inverse);\n      const term = backend_util.getComplexWithIndex(data as Float32Array, c);\n      real += term.real * e.real - term.imag * e.imag;\n      imag += term.real * e.imag + term.imag * e.real;\n    }\n    if (inverse) {\n      real /= size;\n      imag /= size;\n    }\n    backend_util.assignToTypedArray(ret, real, imag, r);\n  }\n  return ret;\n}\n"]},"metadata":{},"sourceType":"module"}