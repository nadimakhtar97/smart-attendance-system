{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseReshape } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\n\nfunction sparseReshape_(inputIndices, inputShape, newShape) {\n  const $inputIndices = convertToTensor(inputIndices, 'inputIndices', 'sparseReshape', 'int32');\n  const $inputShape = convertToTensor(inputShape, 'inputShape', 'sparseReshape', 'int32');\n  const $newShape = convertToTensor(newShape, 'newShape', 'sparseReshape', 'int32');\n\n  if ($inputIndices.rank !== 2) {\n    throw new Error(`Input indices should be Tensor2D but received shape\n        ${$inputIndices.shape}`);\n  }\n\n  if ($inputShape.rank !== 1) {\n    throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);\n  }\n\n  if ($newShape.rank !== 1) {\n    throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);\n  }\n\n  const inputs = {\n    inputIndices: $inputIndices,\n    inputShape: $inputShape,\n    newShape: $newShape\n  };\n  const result = ENGINE.runKernel(SparseReshape, inputs);\n  return {\n    outputIndices: result[0],\n    outputShape: result[1]\n  };\n}\n\nexport const sparseReshape = op({\n  sparseReshape_\n});","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,MAAR,QAAqB,cAArB;AACA,SAAQC,aAAR,QAAiD,oBAAjD;AAGA,SAAQC,eAAR,QAA8B,uBAA9B;AAEA,SAAQC,EAAR,QAAiB,cAAjB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,SAASC,cAAT,CACIC,YADJ,EACuCC,UADvC,EAEIC,QAFJ,EAEiC;AAC/B,QAAMC,aAAa,GACfN,eAAe,CAACG,YAAD,EAAe,cAAf,EAA+B,eAA/B,EAAgD,OAAhD,CADnB;AAEA,QAAMI,WAAW,GACbP,eAAe,CAACI,UAAD,EAAa,YAAb,EAA2B,eAA3B,EAA4C,OAA5C,CADnB;AAEA,QAAMI,SAAS,GACXR,eAAe,CAACK,QAAD,EAAW,UAAX,EAAuB,eAAvB,EAAwC,OAAxC,CADnB;;AAGA,MAAIC,aAAa,CAACG,IAAd,KAAuB,CAA3B,EAA8B;AAC5B,UAAM,IAAIC,KAAJ,CAAU;UACVJ,aAAa,CAACK,KAAK,EADnB,CAAN;AAED;;AACD,MAAIJ,WAAW,CAACE,IAAZ,KAAqB,CAAzB,EAA4B;AAC1B,UAAM,IAAIC,KAAJ,CAAU,qDACZH,WAAW,CAACI,KAAK,EADf,CAAN;AAED;;AACD,MAAIH,SAAS,CAACC,IAAV,KAAmB,CAAvB,EAA0B;AACxB,UAAM,IAAIC,KAAJ,CACF,mDAAmDF,SAAS,CAACG,KAAK,EADhE,CAAN;AAED;;AAED,QAAMC,MAAM,GAAwB;AAClCT,gBAAY,EAAEG,aADoB;AAElCF,cAAU,EAAEG,WAFsB;AAGlCF,YAAQ,EAAEG;AAHwB,GAApC;AAKA,QAAMK,MAAM,GAAaf,MAAM,CAACgB,SAAP,CAAiBf,aAAjB,EAAgCa,MAAhC,CAAzB;AACA,SAAO;AAACG,iBAAa,EAAEF,MAAM,CAAC,CAAD,CAAtB;AAA2BG,eAAW,EAAEH,MAAM,CAAC,CAAD;AAA9C,GAAP;AACD;;AAED,OAAO,MAAMI,aAAa,GAAGhB,EAAE,CAAC;AAACC;AAAD,CAAD,CAAxB","names":["ENGINE","SparseReshape","convertToTensor","op","sparseReshape_","inputIndices","inputShape","newShape","$inputIndices","$inputShape","$newShape","rank","Error","shape","inputs","result","runKernel","outputIndices","outputShape","sparseReshape"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/ops/sparse/sparse_reshape.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {SparseReshape, SparseReshapeInputs} from '../../kernel_names';\nimport {Tensor, Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {op} from '../operation';\n\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseReshape_(\n    inputIndices: Tensor2D|TensorLike, inputShape: Tensor1D|TensorLike,\n    newShape: Tensor1D|TensorLike): NamedTensorMap {\n  const $inputIndices =\n      convertToTensor(inputIndices, 'inputIndices', 'sparseReshape', 'int32');\n  const $inputShape =\n      convertToTensor(inputShape, 'inputShape', 'sparseReshape', 'int32');\n  const $newShape =\n      convertToTensor(newShape, 'newShape', 'sparseReshape', 'int32');\n\n  if ($inputIndices.rank !== 2) {\n    throw new Error(`Input indices should be Tensor2D but received shape\n        ${$inputIndices.shape}`);\n  }\n  if ($inputShape.rank !== 1) {\n    throw new Error(`Input shape should be Tensor1D but received shape ${\n        $inputShape.shape}`);\n  }\n  if ($newShape.rank !== 1) {\n    throw new Error(\n        `New shape should be Tensor1D but received shape ${$newShape.shape}`);\n  }\n\n  const inputs: SparseReshapeInputs = {\n    inputIndices: $inputIndices,\n    inputShape: $inputShape,\n    newShape: $newShape\n  };\n  const result: Tensor[] = ENGINE.runKernel(SparseReshape, inputs as {});\n  return {outputIndices: result[0], outputShape: result[1]};\n}\n\nexport const sparseReshape = op({sparseReshape_});\n"]},"metadata":{},"sourceType":"module"}