{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\n\nexport function computeDilation2DInfo(inputShape, filterShape, strides, pad) {\n  let dataFormat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'NHWC';\n  let dilations = arguments.length > 5 ? arguments[5] : undefined;\n  // `computerConv2DInfo` require filterShape to be in the dimension of:\n  // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n  // outDepth, it should have the same depth as the input.\n  // Input shape: [batch, height, width, inChannels]\n  const inputChannels = inputShape[3];\n  const $filterShape = [...filterShape, inputChannels];\n  const $dataFormat = convertConv2DDataFormat(dataFormat);\n  return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null\n  /* roundingMode */\n  , null\n  /* depthWise */\n  , $dataFormat);\n}\nexport function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode) {\n  let dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'channelsLast';\n  const [filterHeight, filterWidth] = parseTupleParam(filterSize);\n  let filterShape;\n\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);\n}\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\n\nexport function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode) {\n  let dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'NDHWC';\n  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);\n  let filterShape;\n  let $dataFormat;\n\n  if (dataFormat === 'NDHWC') {\n    $dataFormat = 'channelsLast';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n  } else if (dataFormat === 'NCDHW') {\n    $dataFormat = 'channelsFirst';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);\n}\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\n\nexport function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode) {\n  let depthwise = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  let dataFormat = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'channelsLast';\n  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];\n\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterHeight, filterWidth,, filterChannels] = filterShape;\n  const [strideHeight, strideWidth] = parseTupleParam(strides);\n  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);\n  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {\n    padInfo,\n    outHeight,\n    outWidth\n  } = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  let outShape;\n\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inHeight,\n    inWidth,\n    inChannels,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideHeight,\n    strideWidth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\n\nexport function computeConv3DInfo(inShape, filterShape, strides, dilations, pad) {\n  let depthwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let dataFormat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'channelsLast';\n  let roundingMode = arguments.length > 7 ? arguments[7] : undefined;\n  let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];\n\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterDepth, filterHeight, filterWidth,, filterChannels] = filterShape;\n  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);\n  const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);\n  const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);\n  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {\n    padInfo,\n    outDepth,\n    outHeight,\n    outWidth\n  } = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  let outShape;\n\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inDepth,\n    inHeight,\n    inWidth,\n    inChannels,\n    outDepth,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideDepth,\n    strideHeight,\n    strideWidth,\n    filterDepth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterDepth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationDepth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n\nfunction computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n\n  const inputRows = inShape[0];\n  const inputCols = inShape[1];\n  const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  return [outputRows, outputCols];\n}\n\nfunction computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n\n  const inputDepth = inShape[0];\n  const inputRows = inShape[1];\n  const inputCols = inShape[2];\n  const outputDepths = round((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  return [outputDepths, outputRows, outputCols, outChannels];\n}\n\nexport function computeDefaultPad(inputShape, fieldSize, stride) {\n  let dilation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\n\nfunction parseTupleParam(param) {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n\n  return param;\n}\n\nfunction parse3TupleParam(param) {\n  return typeof param === 'number' ? [param, param, param] : param;\n}\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\n\n\nfunction getEffectiveFilterSize(filterSize, dilation) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\n\nfunction getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {\n  let padInfo;\n  let outHeight;\n  let outWidth;\n\n  if (typeof pad === 'number') {\n    const padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      type: padType\n    };\n    const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n    const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n    padInfo = {\n      top,\n      bottom,\n      left,\n      right,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      type: 'VALID'\n    };\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else if (typeof pad === 'object') {\n    const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n    const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n    const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n    const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n    const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? 'VALID' : 'EXPLICIT';\n    padInfo = {\n      top,\n      bottom,\n      left,\n      right,\n      type: padType\n    };\n    outHeight = round((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);\n    outWidth = round((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n\n  return {\n    padInfo,\n    outHeight,\n    outWidth\n  };\n}\n\nfunction get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {\n  let padInfo;\n  let outDepth;\n  let outHeight;\n  let outWidth;\n\n  if (typeof pad === 'number') {\n    const padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      front: pad,\n      back: pad,\n      type: padType\n    };\n    const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad, roundingMode);\n    outDepth = outShape[0];\n    outHeight = outShape[1];\n    outWidth = outShape[2];\n  } else if (pad === 'same') {\n    outDepth = Math.ceil(inDepth / strideDepth);\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n    const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    const front = Math.floor(padAlongDepth / 2);\n    const back = padAlongDepth - front;\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n    padInfo = {\n      top,\n      bottom,\n      left,\n      right,\n      front,\n      back,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      front: 0,\n      back: 0,\n      type: 'VALID'\n    };\n    outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n\n  return {\n    padInfo,\n    outDepth,\n    outHeight,\n    outWidth\n  };\n}\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\n\n\nfunction round(value, roundingMode) {\n  if (!roundingMode) {\n    return Math.trunc(value);\n  }\n\n  switch (roundingMode) {\n    case 'round':\n      // used for Caffe Conv\n      return Math.round(value);\n\n    case 'ceil':\n      // used for Caffe Pool\n      return Math.ceil(value);\n\n    case 'floor':\n      return Math.floor(value);\n\n    default:\n      throw new Error(`Unknown roundingMode ${roundingMode}`);\n  }\n}\n\nexport function tupleValuesAreOne(param) {\n  const [dimA, dimB, dimC] = parseTupleParam(param);\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\nexport function eitherStridesOrDilationsAreOne(strides, dilations) {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\n\nexport function convertConv2DDataFormat(dataFormat) {\n  if (dataFormat === 'NHWC') {\n    return 'channelsLast';\n  } else if (dataFormat === 'NCHW') {\n    return 'channelsFirst';\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n}\n/**\n * Check validity of pad when using dimRoundingMode.\n * @param opDesc A string of op description\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid` output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @throws unknown padding parameter\n */\n\nexport function checkPadOnDimRoundingMode(opDesc, pad, dimRoundingMode) {\n  if (dimRoundingMode != null) {\n    if (typeof pad === 'string') {\n      throw Error(`Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'number') {\n      util.assert(util.isInt(pad), () => `Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'object') {\n      pad.forEach(p => {\n        p.forEach(v => {\n          util.assert(util.isInt(v), () => `Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);\n        });\n      });\n    } else {\n      throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad}`);\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["util","computeDilation2DInfo","inputShape","filterShape","strides","pad","dataFormat","dilations","inputChannels","$filterShape","$dataFormat","convertConv2DDataFormat","computeConv2DInfo","computePool2DInfo","inShape","filterSize","roundingMode","filterHeight","filterWidth","parseTupleParam","Error","computePool3DInfo","filterDepth","parse3TupleParam","computeConv3DInfo","depthwise","batchSize","inHeight","inWidth","inChannels","filterChannels","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","getEffectiveFilterSize","effectiveFilterWidth","padInfo","outHeight","outWidth","getPadAndOutInfo","outChannels","outShape","inDepth","strideDepth","dilationDepth","effectiveFilterDepth","outDepth","get3DPadAndOutInfo","computeOutputShape2D","fieldSize","stride","zeroPad","computeDefaultPad","inputRows","inputCols","outputRows","round","outputCols","computeOutputShape4D","inputDepth","outputDepths","dilation","effectiveFieldSize","Math","floor","param","length","padType","top","bottom","left","right","type","ceil","padAlongHeight","max","padAlongWidth","front","back","padAlongDepth","value","trunc","tupleValuesAreOne","dimA","dimB","dimC","eitherStridesOrDilationsAreOne","checkPadOnDimRoundingMode","opDesc","dimRoundingMode","assert","isInt","forEach","p","v"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/ops/conv_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as util from '../util';\n\ntype PadType = 'SAME'|'VALID'|'NUMBER'|'EXPLICIT';\n\n// For NHWC should be in the following form:\n//  [[0, 0], [pad_top,pad_bottom], [pad_left, pad_right], [0, 0]]\n// For NCHW should be in the following form:\n//  [[0, 0], [0, 0], [pad_top,pad_bottom], [pad_left, pad_right]]\n// Reference: https://www.tensorflow.org/api_docs/python/tf/nn/conv2d\nexport type ExplicitPadding =\n    [[number, number], [number, number], [number, number], [number, number]];\n\nexport type PadInfo = {\n  top: number,\n  left: number,\n  right: number,\n  bottom: number,\n  type: PadType\n};\n\nexport type PadInfo3D = {\n  top: number,\n  left: number,\n  right: number,\n  bottom: number,\n  front: number,\n  back: number,\n  type: PadType\n};\n\n/**\n * Information about the forward pass of a convolution/pooling operation.\n * It includes input and output shape, strides, filter size and padding\n * information.\n */\nexport type Conv2DInfo = {\n  batchSize: number,\n  inHeight: number,\n  inWidth: number,\n  inChannels: number,\n  outHeight: number,\n  outWidth: number,\n  outChannels: number,\n  dataFormat: 'channelsFirst'|'channelsLast',\n  strideHeight: number,\n  strideWidth: number,\n  dilationHeight: number,\n  dilationWidth: number,\n  filterHeight: number,\n  filterWidth: number,\n  effectiveFilterHeight: number,\n  effectiveFilterWidth: number,\n  padInfo: PadInfo,\n  inShape: [number, number, number, number],\n  outShape: [number, number, number, number],\n  filterShape: [number, number, number, number]\n};\n\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\nexport function computeDilation2DInfo(\n    inputShape: [number, number, number, number],\n    filterShape: [number, number, number], strides: number|[number, number],\n    pad: 'same'|'valid'|number, dataFormat: 'NHWC' = 'NHWC',\n    dilations: number|[number, number]) {\n  // `computerConv2DInfo` require filterShape to be in the dimension of:\n  // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n  // outDepth, it should have the same depth as the input.\n  // Input shape: [batch, height, width, inChannels]\n  const inputChannels = inputShape[3];\n  const $filterShape =\n      [...filterShape, inputChannels] as [number, number, number, number];\n  const $dataFormat = convertConv2DDataFormat(dataFormat);\n\n  return computeConv2DInfo(\n      inputShape, $filterShape, strides, dilations, pad,\n      null /* roundingMode */, null /* depthWise */, $dataFormat);\n}\n\nexport function computePool2DInfo(\n    inShape: [number, number, number, number],\n    filterSize: [number, number]|number, strides: number|[number, number],\n    dilations: number|[number, number],\n    pad: 'same'|'valid'|number|ExplicitPadding,\n    roundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast'): Conv2DInfo {\n  const [filterHeight, filterWidth] = parseTupleParam(filterSize);\n\n  let filterShape: [number, number, number, number];\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv2DInfo(\n      inShape, filterShape, strides, dilations, pad, roundingMode, false,\n      dataFormat);\n}\n\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\nexport function computePool3DInfo(\n    inShape: [number, number, number, number, number],\n    filterSize: number|[number, number, number],\n    strides: number|[number, number, number],\n    dilations: number|[number, number, number], pad: 'same'|'valid'|number,\n    roundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'NDHWC'|'NCDHW' = 'NDHWC'): Conv3DInfo {\n  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);\n\n  let filterShape: [number, number, number, number, number];\n  let $dataFormat: 'channelsFirst'|'channelsLast';\n  if (dataFormat === 'NDHWC') {\n    $dataFormat = 'channelsLast';\n    filterShape =\n        [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n  } else if (dataFormat === 'NCDHW') {\n    $dataFormat = 'channelsFirst';\n    filterShape =\n        [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv3DInfo(\n      inShape, filterShape, strides, dilations, pad, false, $dataFormat,\n      roundingMode);\n}\n\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\nexport function computeConv2DInfo(\n    inShape: [number, number, number, number],\n    filterShape: [number, number, number, number],\n    strides: number|[number, number], dilations: number|[number, number],\n    pad: 'same'|'valid'|number|ExplicitPadding,\n    roundingMode?: 'floor'|'round'|'ceil', depthwise = false,\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast'): Conv2DInfo {\n  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterHeight, filterWidth, , filterChannels] = filterShape;\n  const [strideHeight, strideWidth] = parseTupleParam(strides);\n  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);\n\n  const effectiveFilterHeight =\n      getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth =\n      getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {padInfo, outHeight, outWidth} = getPadAndOutInfo(\n      pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight,\n      effectiveFilterWidth, roundingMode, dataFormat);\n\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n\n  let outShape: [number, number, number, number];\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inHeight,\n    inWidth,\n    inChannels,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideHeight,\n    strideWidth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n\n/**\n * Information about the forward pass of a 3D convolution/pooling operation.\n * It includes input and output shape, strides, filter size and padding\n * information.\n */\nexport type Conv3DInfo = {\n  batchSize: number,\n  inDepth: number,\n  inHeight: number,\n  inWidth: number,\n  inChannels: number,\n  outDepth: number,\n  outHeight: number,\n  outWidth: number,\n  outChannels: number,\n  dataFormat: 'channelsFirst'|'channelsLast',\n  strideDepth: number,\n  strideHeight: number,\n  strideWidth: number,\n  dilationDepth: number,\n  dilationHeight: number,\n  dilationWidth: number,\n  filterDepth: number,\n  filterHeight: number,\n  filterWidth: number,\n  effectiveFilterDepth: number,\n  effectiveFilterHeight: number,\n  effectiveFilterWidth: number,\n  padInfo: PadInfo3D,\n  inShape: [number, number, number, number, number],\n  outShape: [number, number, number, number, number],\n  filterShape: [number, number, number, number, number]\n};\n\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\nexport function computeConv3DInfo(\n    inShape: [number, number, number, number, number],\n    filterShape: [number, number, number, number, number],\n    strides: number|[number, number, number],\n    dilations: number|[number, number, number], pad: 'same'|'valid'|number,\n    depthwise = false,\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast',\n    roundingMode?: 'floor'|'round'|'ceil'): Conv3DInfo {\n  let [batchSize, inDepth, inHeight, inWidth, inChannels] =\n      [-1, -1, -1, -1, -1];\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterDepth, filterHeight, filterWidth, , filterChannels] =\n      filterShape;\n  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);\n  const [dilationDepth, dilationHeight, dilationWidth] =\n      parse3TupleParam(dilations);\n\n  const effectiveFilterDepth =\n      getEffectiveFilterSize(filterDepth, dilationDepth);\n  const effectiveFilterHeight =\n      getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth =\n      getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {padInfo, outDepth, outHeight, outWidth} = get3DPadAndOutInfo(\n      pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth,\n      effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth,\n      roundingMode);\n\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n\n  let outShape: [number, number, number, number, number];\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inDepth,\n    inHeight,\n    inWidth,\n    inChannels,\n    outDepth,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideDepth,\n    strideHeight,\n    strideWidth,\n    filterDepth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterDepth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationDepth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n\nfunction computeOutputShape2D(\n    inShape: [number, number], fieldSize: number, stride: number,\n    zeroPad?: number, roundingMode?: 'floor'|'round'|'ceil'): [number, number] {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n  const inputRows = inShape[0];\n  const inputCols = inShape[1];\n\n  const outputRows =\n      round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols =\n      round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n\n  return [outputRows, outputCols];\n}\n\nfunction computeOutputShape4D(\n    inShape: [number, number, number, number], fieldSize: number,\n    outChannels: number, stride: number, zeroPad?: number,\n    roundingMode?: 'floor'|'round'|'ceil'): [number, number, number, number] {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n  const inputDepth = inShape[0];\n  const inputRows = inShape[1];\n  const inputCols = inShape[2];\n\n  const outputDepths =\n      round((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputRows =\n      round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols =\n      round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n\n  return [outputDepths, outputRows, outputCols, outChannels];\n}\n\nexport function computeDefaultPad(\n    inputShape: [number, number]|[number, number, number, number],\n    fieldSize: number, stride: number, dilation = 1): number {\n  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor(\n      (inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\n\nfunction parseTupleParam(param: number|number[]): [number, number, number] {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n  return param as [number, number, number];\n}\n\nfunction parse3TupleParam(param: number|[number, number, number]):\n    [number, number, number] {\n  return typeof param === 'number' ? [param, param, param] : param;\n}\n\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\nfunction getEffectiveFilterSize(filterSize: number, dilation: number) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\n\nfunction getPadAndOutInfo(\n    pad: 'same'|'valid'|number|ExplicitPadding, inHeight: number,\n    inWidth: number, strideHeight: number, strideWidth: number,\n    filterHeight: number, filterWidth: number,\n    roundingMode: 'floor'|'round'|'ceil',\n    dataFormat: 'channelsFirst'|\n    'channelsLast'): {padInfo: PadInfo, outHeight: number, outWidth: number} {\n  let padInfo: PadInfo;\n  let outHeight: number;\n  let outWidth: number;\n\n  if (typeof pad === 'number') {\n    const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n    padInfo = {top: pad, bottom: pad, left: pad, right: pad, type: padType};\n    const outShape = computeOutputShape2D(\n        [inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongHeight =\n        Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n    const padAlongWidth =\n        Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n    padInfo = {top, bottom, left, right, type: 'SAME'};\n  } else if (pad === 'valid') {\n    padInfo = {top: 0, bottom: 0, left: 0, right: 0, type: 'VALID'};\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else if (typeof pad === 'object') {\n    const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n    const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n    const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n    const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n    const padType = (top === 0 && bottom === 0 && left === 0 && right === 0) ?\n        'VALID' :\n        'EXPLICIT';\n    padInfo = {top, bottom, left, right, type: padType};\n    outHeight = round(\n        (inHeight - filterHeight + top + bottom) / strideHeight + 1,\n        roundingMode);\n    outWidth = round(\n        (inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n  return {padInfo, outHeight, outWidth};\n}\n\nfunction get3DPadAndOutInfo(\n    pad: 'same'|'valid'|number, inDepth: number, inHeight: number,\n    inWidth: number, strideDepth: number, strideHeight: number,\n    strideWidth: number, filterDepth: number, filterHeight: number,\n    filterWidth: number, roundingMode?: 'floor'|'round'|'ceil'): {\n  padInfo: PadInfo3D,\n  outDepth: number,\n  outHeight: number,\n  outWidth: number\n} {\n  let padInfo: PadInfo3D;\n  let outDepth: number;\n  let outHeight: number;\n  let outWidth: number;\n\n  if (typeof pad === 'number') {\n    const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      front: pad,\n      back: pad,\n      type: padType\n    };\n    const outShape = computeOutputShape4D(\n        [inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad,\n        roundingMode);\n    outDepth = outShape[0];\n    outHeight = outShape[1];\n    outWidth = outShape[2];\n  } else if (pad === 'same') {\n    outDepth = Math.ceil(inDepth / strideDepth);\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n    const padAlongHeight =\n        (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    const front = Math.floor(padAlongDepth / 2);\n    const back = padAlongDepth - front;\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n\n    padInfo = {top, bottom, left, right, front, back, type: 'SAME'};\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      front: 0,\n      back: 0,\n      type: 'VALID'\n    };\n    outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n  return {padInfo, outDepth, outHeight, outWidth};\n}\n\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction round(value: number, roundingMode?: 'floor'|'round'|'ceil') {\n  if (!roundingMode) {\n    return Math.trunc(value);\n  }\n  switch (roundingMode) {\n    case 'round':\n      // used for Caffe Conv\n      return Math.round(value);\n    case 'ceil':\n      // used for Caffe Pool\n      return Math.ceil(value);\n    case 'floor':\n      return Math.floor(value);\n    default:\n      throw new Error(`Unknown roundingMode ${roundingMode}`);\n  }\n}\n\nexport function tupleValuesAreOne(param: number|number[]): boolean {\n  const [dimA, dimB, dimC] = parseTupleParam(param);\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\n\nexport function eitherStridesOrDilationsAreOne(\n    strides: number|number[], dilations: number|number[]): boolean {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\nexport function convertConv2DDataFormat(dataFormat: 'NHWC'|'NCHW'):\n    'channelsLast'|'channelsFirst' {\n  if (dataFormat === 'NHWC') {\n    return 'channelsLast';\n  } else if (dataFormat === 'NCHW') {\n    return 'channelsFirst';\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n}\n\n/**\n * Check validity of pad when using dimRoundingMode.\n * @param opDesc A string of op description\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid` output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @throws unknown padding parameter\n */\nexport function checkPadOnDimRoundingMode(\n    opDesc: string, pad: 'valid'|'same'|number|ExplicitPadding,\n    dimRoundingMode?: 'floor'|'round'|'ceil') {\n  if (dimRoundingMode != null) {\n    if (typeof pad === 'string') {\n      throw Error(\n          `Error in ${opDesc}: pad must be an integer when using `  +\n          `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'number') {\n      util.assert(\n        util.isInt(pad),\n          () => `Error in ${opDesc}: pad must be an integer when using ` +\n              `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'object') {\n      (pad as ExplicitPadding).forEach(p => {p.forEach(v =>{\n        util.assert(\n          util.isInt(v),\n            () => `Error in ${opDesc}: pad must be an integer when using ` +\n                `dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);\n        });\n      });\n    } else {\n      throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad}`);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}