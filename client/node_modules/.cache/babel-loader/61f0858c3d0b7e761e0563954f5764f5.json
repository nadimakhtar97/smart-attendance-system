{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Einsum, util } from '@tensorflow/tfjs-core';\nimport { multiply } from './Multiply';\nimport { reshape } from './Reshape';\nimport { sum } from './Sum';\nimport { transpose } from './Transpose';\nexport function einsum(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    equation\n  } = attrs;\n  const tensors = inputs;\n  const {\n    allDims,\n    summedDims,\n    idDims\n  } = backend_util.decodeEinsumEquation(equation, tensors.length);\n  backend_util.checkEinsumDimSizes(allDims.length, idDims, tensors);\n  const {\n    path,\n    steps\n  } = backend_util.getEinsumComputePath(summedDims, idDims);\n  const nSteps = steps.length;\n  let out = null;\n  let numDimsRemaining = allDims.length;\n  const tensorsToDispose = [];\n\n  for (let i = 0; i < nSteps; ++i) {\n    for (const idTerm of steps[i]) {\n      const {\n        permutationIndices: perm,\n        expandDims: dimsToExpand\n      } = backend_util.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);\n      let x;\n\n      if (backend_util.isIdentityPermutation(perm)) {\n        x = tensors[idTerm];\n      } else {\n        x = transpose({\n          inputs: {\n            x: tensors[idTerm]\n          },\n          backend,\n          attrs: {\n            perm\n          }\n        });\n        tensorsToDispose.push(x);\n      }\n\n      const targetShape = x.shape.slice();\n\n      for (let k = 0; k < dimsToExpand.length; ++k) {\n        targetShape.splice(dimsToExpand[k], 0, 1);\n      }\n\n      if (!util.arraysEqual(x.shape, targetShape)) {\n        x = reshape({\n          inputs: {\n            x\n          },\n          backend,\n          attrs: {\n            shape: targetShape\n          }\n        });\n        tensorsToDispose.push(x);\n      }\n\n      if (out === null) {\n        out = x;\n      } else {\n        // tslint:disable-next-line: no-unnecessary-type-assertion\n        out = multiply({\n          inputs: {\n            a: x,\n            b: out\n          },\n          backend\n        });\n        tensorsToDispose.push(out);\n      }\n    }\n\n    if (i < nSteps - 1) {\n      if (path[i] >= 0) {\n        out = sum({\n          inputs: {\n            x: out\n          },\n          backend,\n          attrs: {\n            axis: path[i] - (allDims.length - numDimsRemaining),\n            keepDims: false\n          }\n        });\n        tensorsToDispose.push(out);\n      }\n\n      numDimsRemaining--;\n    }\n  } // Clean up intermediate tensors.\n\n\n  for (const tensorInfo of tensorsToDispose) {\n    if (tensorInfo === out) {\n      continue;\n    }\n\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n\n  return out;\n}\nexport const einsumConfig = {\n  kernelName: Einsum,\n  backendName: 'cpu',\n  kernelFunc: einsum\n};","map":{"version":3,"mappings":"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","names":["backend_util","Einsum","util","multiply","reshape","sum","transpose","einsum","args","inputs","backend","attrs","equation","tensors","allDims","summedDims","idDims","decodeEinsumEquation","length","checkEinsumDimSizes","path","steps","getEinsumComputePath","nSteps","out","numDimsRemaining","tensorsToDispose","i","idTerm","permutationIndices","perm","expandDims","dimsToExpand","getEinsumPermutation","x","isIdentityPermutation","push","targetShape","shape","slice","k","splice","arraysEqual","a","b","axis","keepDims","tensorInfo","disposeIntermediateTensorInfo","einsumConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/Einsum.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Einsum, EinsumAttrs, EinsumInputs, KernelConfig, KernelFunc, Tensor, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nimport {multiply} from './Multiply';\nimport {reshape} from './Reshape';\nimport {sum} from './Sum';\nimport {transpose} from './Transpose';\n\nexport function einsum(\n    args: {inputs: EinsumInputs, backend: MathBackendCPU, attrs: EinsumAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {equation} = attrs;\n  const tensors = inputs as Tensor[];\n\n  const {allDims, summedDims, idDims} =\n      backend_util.decodeEinsumEquation(equation, tensors.length);\n  backend_util.checkEinsumDimSizes(allDims.length, idDims, tensors);\n  const {path, steps} = backend_util.getEinsumComputePath(summedDims, idDims);\n\n  const nSteps = steps.length;\n  let out: TensorInfo|null = null;\n  let numDimsRemaining = allDims.length;\n  const tensorsToDispose: TensorInfo[] = [];\n  for (let i = 0; i < nSteps; ++i) {\n    for (const idTerm of steps[i]) {\n      const {permutationIndices: perm, expandDims: dimsToExpand} =\n          backend_util.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);\n      let x: TensorInfo;\n      if (backend_util.isIdentityPermutation(perm)) {\n        x = tensors[idTerm];\n      } else {\n        x = transpose({inputs: {x: tensors[idTerm]}, backend, attrs: {perm}});\n        tensorsToDispose.push(x);\n      }\n      const targetShape: number[] = x.shape.slice();\n      for (let k = 0; k < dimsToExpand.length; ++k) {\n        targetShape.splice(dimsToExpand[k], 0, 1);\n      }\n\n      if (!util.arraysEqual(x.shape, targetShape)) {\n        x = reshape({inputs: {x}, backend, attrs: {shape: targetShape}});\n        tensorsToDispose.push(x);\n      }\n      if (out === null) {\n        out = x;\n      } else {\n        // tslint:disable-next-line: no-unnecessary-type-assertion\n        out = multiply({inputs: {a: x, b: out}, backend}) as TensorInfo;\n        tensorsToDispose.push(out);\n      }\n    }\n    if (i < nSteps - 1) {\n      if (path[i] >= 0) {\n        out = sum({\n          inputs: {x: out},\n          backend,\n          attrs: {\n            axis: path[i] - (allDims.length - numDimsRemaining),\n            keepDims: false\n          }\n        });\n        tensorsToDispose.push(out);\n      }\n      numDimsRemaining--;\n    }\n  }\n\n  // Clean up intermediate tensors.\n  for (const tensorInfo of tensorsToDispose) {\n    if (tensorInfo === out) {\n      continue;\n    }\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n\n  return out;\n}\n\nexport const einsumConfig: KernelConfig = {\n  kernelName: Einsum,\n  backendName: 'cpu',\n  kernelFunc: einsum as {} as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module"}