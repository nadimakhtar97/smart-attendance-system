{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tidy, util } from '@tensorflow/tfjs-core'; // tslint:disable-next-line: no-imports-from-dist\n\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport const executeOp = (node, tensorMap, context) => {\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        const n = getParamValue('n', node, tensorMap, context);\n        const axis = getParamValue('axis', node, tensorMap, context);\n        let inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [tfOps.concat(inputs, axis)];\n      }\n\n    case 'Gather':\n      {\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [tfOps.gather(input, tfOps.cast(indices, 'int32'), 0)];\n      }\n\n    case 'GatherV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const batchDims = getParamValue('batchDims', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [tfOps.gather(input, tfOps.cast(indices, 'int32'), axis, batchDims)];\n      }\n\n    case 'Reverse':\n      {\n        const dims = getParamValue('dims', node, tensorMap, context);\n        const axis = [];\n\n        for (let i = 0; i < dims.length; i++) {\n          if (dims[i]) {\n            axis.push(i);\n          }\n        }\n\n        const input = getParamValue('x', node, tensorMap, context);\n        return [tfOps.reverse(input, axis)];\n      }\n\n    case 'ReverseV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        return [tfOps.reverse(input, axis)];\n      }\n\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        const begin = getParamValue('begin', node, tensorMap, context); // tslint:disable-next-line:no-any\n\n        const size = getParamValue('size', node, tensorMap, context);\n        return [tfOps.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n\n    case 'StridedSlice':\n      {\n        const begin = getParamValue('begin', node, tensorMap, context);\n        const end = getParamValue('end', node, tensorMap, context);\n        const strides = getParamValue('strides', node, tensorMap, context);\n        const beginMask = getParamValue('beginMask', node, tensorMap, context);\n        const endMask = getParamValue('endMask', node, tensorMap, context);\n        const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return [tfOps.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n\n    case 'Pack':\n      {\n        return tidy(() => {\n          const axis = getParamValue('axis', node, tensorMap, context);\n          const tensors = getParamValue('tensors', node, tensorMap, context); // Reshape the tensors to the first tensor's shape if they don't\n          // match.\n\n          const shape = tensors[0].shape;\n          const squeezedShape = tfOps.squeeze(tensors[0]).shape;\n          const mapped = tensors.map(tensor => {\n            const sameShape = util.arraysEqual(tensor.shape, shape);\n\n            if (!sameShape && !util.arraysEqual(tfOps.squeeze(tensor).shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n\n            return sameShape ? tensor : tfOps.reshape(tensor, shape);\n          });\n          return [tfOps.stack(mapped, axis)];\n        });\n      }\n\n    case 'Unpack':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const tensor = getParamValue('tensor', node, tensorMap, context);\n        return tfOps.unstack(tensor, axis);\n      }\n\n    case 'Tile':\n      {\n        const reps = getParamValue('reps', node, tensorMap, context);\n        return [tfOps.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n\n    case 'Split':\n    case 'SplitV':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return tfOps.split(tensor, numOrSizeSplits, axis);\n      }\n\n    case 'ScatterNd':\n      {\n        const indices = getParamValue('indices', node, tensorMap, context);\n        const values = getParamValue('values', node, tensorMap, context);\n        const shape = getParamValue('shape', node, tensorMap, context);\n        return [tfOps.scatterND(indices, values, shape)];\n      }\n\n    case 'GatherNd':\n      {\n        const x = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [tfOps.gatherND(x, indices)];\n      }\n\n    case 'SparseToDense':\n      {\n        const indices = getParamValue('sparseIndices', node, tensorMap, context);\n        const shape = getParamValue('outputShape', node, tensorMap, context);\n        const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [tfOps.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : tfOps.cast(defaultValue, sparseValues.dtype))];\n      }\n\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'slice_join';","map":{"version":3,"mappings":"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","names":["tidy","util","tfOps","getParamValue","executeOp","node","tensorMap","context","op","n","axis","inputs","slice","concat","input","indices","gather","cast","batchDims","dims","i","length","push","reverse","begin","size","end","strides","beginMask","endMask","ellipsisMask","newAxisMask","shrinkAxisMask","tensor","stridedSlice","tensors","shape","squeezedShape","squeeze","mapped","map","sameShape","arraysEqual","Error","reshape","stack","unstack","reps","tile","numOrSizeSplits","split","values","scatterND","x","gatherND","sparseValues","defaultValue","sparseToDense","dtype","TypeError","CATEGORY"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-converter/src/operations/executors/slice_join_executor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor, Tensor1D, tidy, util} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {getParamValue} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap,\n     context: ExecutionContext): Tensor[] => {\n      switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n          const n = getParamValue('n', node, tensorMap, context) as number;\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          let inputs =\n              getParamValue('tensors', node, tensorMap, context) as Tensor[];\n          inputs = inputs.slice(0, n);\n          return [tfOps.concat(inputs, axis)];\n        }\n        case 'Gather': {\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [tfOps.gather(input, tfOps.cast(indices, 'int32'), 0)];\n        }\n        case 'GatherV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const batchDims =\n              getParamValue('batchDims', node, tensorMap, context) as number;\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [tfOps.gather(\n              input, tfOps.cast(indices, 'int32'), axis, batchDims)];\n        }\n        case 'Reverse': {\n          const dims =\n              getParamValue('dims', node, tensorMap, context) as boolean[];\n          const axis = [];\n          for (let i = 0; i < dims.length; i++) {\n            if (dims[i]) {\n              axis.push(i);\n            }\n          }\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [tfOps.reverse(input, axis)];\n        }\n        case 'ReverseV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number[];\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [tfOps.reverse(input, axis)];\n        }\n        case 'Slice': {\n          // tslint:disable-next-line:no-any\n          const begin = getParamValue('begin', node, tensorMap, context) as any;\n          // tslint:disable-next-line:no-any\n          const size = getParamValue('size', node, tensorMap, context) as any;\n          return [tfOps.slice(\n              getParamValue('x', node, tensorMap, context) as Tensor, begin,\n              size)];\n        }\n        case 'StridedSlice': {\n          const begin =\n              getParamValue('begin', node, tensorMap, context) as number[];\n          const end =\n              getParamValue('end', node, tensorMap, context) as number[];\n          const strides =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const beginMask =\n              getParamValue('beginMask', node, tensorMap, context) as number;\n          const endMask =\n              getParamValue('endMask', node, tensorMap, context) as number;\n          const ellipsisMask =\n              getParamValue('ellipsisMask', node, tensorMap, context) as number;\n          const newAxisMask =\n              getParamValue('newAxisMask', node, tensorMap, context) as number;\n          const shrinkAxisMask =\n              getParamValue('shrinkAxisMask', node, tensorMap, context) as\n              number;\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return [tfOps.stridedSlice(\n              tensor, begin, end, strides, beginMask, endMask, ellipsisMask,\n              newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n          return tidy(() => {\n            const axis =\n                getParamValue('axis', node, tensorMap, context) as number;\n            const tensors =\n                getParamValue('tensors', node, tensorMap, context) as Tensor[];\n            // Reshape the tensors to the first tensor's shape if they don't\n            // match.\n            const shape = tensors[0].shape;\n            const squeezedShape = tfOps.squeeze(tensors[0]).shape;\n            const mapped = tensors.map(tensor => {\n              const sameShape = util.arraysEqual(tensor.shape, shape);\n              if (!sameShape &&\n                  !util.arraysEqual(\n                      tfOps.squeeze(tensor).shape, squeezedShape)) {\n                throw new Error('the input tensors shape does not match');\n              }\n              return sameShape ? tensor : tfOps.reshape(tensor, shape);\n            });\n            return [tfOps.stack(mapped, axis)];\n          });\n        }\n        case 'Unpack': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const tensor =\n              getParamValue('tensor', node, tensorMap, context) as Tensor;\n          return tfOps.unstack(tensor, axis);\n        }\n        case 'Tile': {\n          const reps =\n              getParamValue('reps', node, tensorMap, context) as number[];\n          return [tfOps.tile(\n              getParamValue('x', node, tensorMap, context) as Tensor, reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const numOrSizeSplits =\n              getParamValue('numOrSizeSplits', node, tensorMap, context) as\n                  number |\n              number[];\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return tfOps.split(tensor, numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          const values =\n              getParamValue('values', node, tensorMap, context) as Tensor;\n          const shape =\n              getParamValue('shape', node, tensorMap, context) as number[];\n          return [tfOps.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n          const x = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          return [tfOps.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n          const indices =\n              getParamValue('sparseIndices', node, tensorMap, context) as\n              Tensor;\n          const shape =\n              getParamValue('outputShape', node, tensorMap, context) as\n              number[];\n          const sparseValues =\n              getParamValue('sparseValues', node, tensorMap, context) as Tensor;\n          const defaultValue =\n              getParamValue('defaultValue', node, tensorMap, context) as Scalar;\n          return [tfOps.sparseToDense(\n              indices, sparseValues, shape,\n              sparseValues.dtype === defaultValue.dtype ?\n                  defaultValue :\n                  tfOps.cast(defaultValue, sparseValues.dtype))];\n        }\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'slice_join';\n"]},"metadata":{},"sourceType":"module"}