{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport * as tensorflow from '../data/compiled_api';\nimport { getRegisteredOp } from './custom_op/register';\nimport { getNodeNameAndIndex } from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as sparse from './op_list/sparse';\nimport * as spectral from './op_list/spectral';\nimport * as string from './op_list/string';\nimport * as transformation from './op_list/transformation';\nexport class OperationMapper {\n  // Singleton instance for the mapper\n  static get Instance() {\n    return this._instance || (this._instance = new this());\n  } // Loads the op mapping from the JSON file.\n\n\n  constructor() {\n    const ops = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, graph, hashTable, image, logical, matrices, normalization, reduction, sliceJoin, sparse, spectral, string, transformation];\n    const mappersJson = [].concat(...ops.map(op => op.json));\n    this.opMappers = mappersJson.reduce((map, mapper) => {\n      map[mapper.tfOpName] = mapper;\n      return map;\n    }, {});\n  } // Converts the model inference graph from Tensorflow GraphDef to local\n  // representation for TensorFlow.js API\n\n\n  transformGraph(graph) {\n    let signature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const tfNodes = graph.node;\n    const placeholders = [];\n    const weights = [];\n    const initNodes = [];\n    const nodes = tfNodes.reduce((map, node) => {\n      map[node.name] = this.mapNode(node);\n\n      if (node.op.startsWith('Placeholder')) {\n        placeholders.push(map[node.name]);\n      } else if (node.op === 'Const') {\n        weights.push(map[node.name]);\n      } else if (node.input == null || node.input.length === 0) {\n        initNodes.push(map[node.name]);\n      }\n\n      return map;\n    }, {});\n    let inputs = [];\n    const outputs = [];\n    let inputNodeNameToKey = {};\n    let outputNodeNameToKey = {};\n\n    if (signature != null) {\n      inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n      outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n    }\n\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName,, outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`; // update the input name to use the mapped output index directly.\n\n            node.inputNames[index] = inputName;\n          }\n        }\n\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    }); // if signature has not outputs set, add any node that does not have\n    // outputs.\n\n    if (Object.keys(outputNodeNameToKey).length === 0) {\n      allNodes.forEach(key => {\n        const node = nodes[key];\n\n        if (node.children.length === 0) {\n          outputs.push(node);\n        }\n      });\n    } else {\n      Object.keys(outputNodeNameToKey).forEach(name => {\n        const [nodeName] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n\n        if (node != null) {\n          node.signatureKey = outputNodeNameToKey[name];\n          outputs.push(node);\n        }\n      });\n    }\n\n    if (Object.keys(inputNodeNameToKey).length > 0) {\n      Object.keys(inputNodeNameToKey).forEach(name => {\n        const [nodeName] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n\n        if (node) {\n          node.signatureKey = inputNodeNameToKey[name];\n          inputs.push(node);\n        }\n      });\n    } else {\n      inputs = placeholders;\n    }\n\n    let functions = {};\n\n    if (graph.library != null && graph.library.function != null) {\n      functions = graph.library.function.reduce((functions, func) => {\n        functions[func.signature.name] = this.mapFunction(func);\n        return functions;\n      }, {});\n    }\n\n    const result = {\n      nodes,\n      inputs,\n      outputs,\n      weights,\n      placeholders,\n      signature,\n      functions\n    };\n\n    if (initNodes.length > 0) {\n      result.initNodes = initNodes;\n    }\n\n    return result;\n  }\n\n  mapSignatureEntries(entries) {\n    return Object.keys(entries || {}).reduce((prev, curr) => {\n      prev[entries[curr].name] = curr;\n      return prev;\n    }, {});\n  }\n\n  mapNode(node) {\n    // Unsupported ops will cause an error at run-time (not parse time), since\n    // they may not be used by the actual execution subgraph.\n    const mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};\n\n    if (node.attr == null) {\n      node.attr = {};\n    }\n\n    const newNode = {\n      name: node.name,\n      op: node.op,\n      category: mapper.category,\n      inputNames: (node.input || []).map(input => input.startsWith('^') ? input.substr(1) : input),\n      inputs: [],\n      children: [],\n      inputParams: {},\n      attrParams: {},\n      rawAttrs: node.attr,\n      outputs: mapper.outputs\n    };\n\n    if (mapper.inputs != null) {\n      newNode.inputParams = mapper.inputs.reduce((map, param) => {\n        map[param.name] = {\n          type: param.type,\n          inputIndexStart: param.start,\n          inputIndexEnd: param.end\n        };\n        return map;\n      }, {});\n    }\n\n    if (mapper.attrs != null) {\n      newNode.attrParams = mapper.attrs.reduce((map, param) => {\n        const type = param.type;\n        let value = undefined;\n\n        switch (param.type) {\n          case 'string':\n            value = getStringParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'string[]':\n            value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'number':\n            value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'number[]':\n            value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'bool':\n            value = getBoolParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'bool[]':\n            value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'shape':\n            value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'shape[]':\n            value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'dtype':\n            value = getDtypeParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'dtype[]':\n            value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'func':\n            value = getFuncParam(node.attr, param.tfName, param.defaultValue);\n\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n\n            break;\n\n          case 'tensor':\n          case 'tensors':\n            break;\n\n          default:\n            throw new Error(`Unsupported param type: ${param.type} for op: ${node.op}`);\n        }\n\n        map[param.name] = {\n          value,\n          type\n        };\n        return map;\n      }, {});\n    }\n\n    return newNode;\n  } // map the TFunctionDef to TFJS graph object\n\n\n  mapFunction(functionDef) {\n    const tfNodes = functionDef.nodeDef;\n    const placeholders = [];\n    const weights = [];\n    let nodes = {};\n\n    if (tfNodes != null) {\n      nodes = tfNodes.reduce((map, node) => {\n        map[node.name] = this.mapNode(node);\n\n        if (node.op === 'Const') {\n          weights.push(map[node.name]);\n        }\n\n        return map;\n      }, {});\n    }\n\n    const inputs = [];\n    const outputs = [];\n    functionDef.signature.inputArg.forEach(arg => {\n      const [nodeName] = getNodeNameAndIndex(arg.name);\n      const node = {\n        name: nodeName,\n        op: 'Placeholder',\n        inputs: [],\n        inputNames: [],\n        category: 'graph',\n        inputParams: {},\n        attrParams: {\n          dtype: {\n            value: parseDtypeParam(arg.type),\n            type: 'dtype'\n          }\n        },\n        children: []\n      };\n      node.signatureKey = arg.name;\n      inputs.push(node);\n      nodes[nodeName] = node;\n    });\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName,, outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`; // update the input name to use the mapped output index directly.\n\n            node.inputNames[index] = inputName;\n          }\n        }\n\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    });\n    const returnNodeMap = functionDef.ret;\n    functionDef.signature.outputArg.forEach(output => {\n      const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);\n      const node = nodes[nodeName];\n\n      if (node != null) {\n        node.defaultOutput = index;\n        outputs.push(node);\n      }\n    });\n    const signature = this.mapArgsToSignature(functionDef);\n    return {\n      nodes,\n      inputs,\n      outputs,\n      weights,\n      placeholders,\n      signature\n    };\n  }\n\n  mapArgsToSignature(functionDef) {\n    return {\n      methodName: functionDef.signature.name,\n      inputs: functionDef.signature.inputArg.reduce((map, arg) => {\n        map[arg.name] = this.mapArgToTensorInfo(arg);\n        return map;\n      }, {}),\n      outputs: functionDef.signature.outputArg.reduce((map, arg) => {\n        map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);\n        return map;\n      }, {})\n    };\n  }\n\n  mapArgToTensorInfo(arg, nameMap) {\n    let name = arg.name;\n\n    if (nameMap != null) {\n      name = nameMap[name];\n    }\n\n    return {\n      name,\n      dtype: arg.type\n    };\n  }\n\n}\nexport function decodeBase64(text) {\n  const global = env().global;\n\n  if (typeof global.atob !== 'undefined') {\n    return global.atob(text);\n  } else if (typeof Buffer !== 'undefined') {\n    return new Buffer(text, 'base64').toString();\n  } else {\n    throw new Error('Unable to decode base64 in this environment. ' + 'Missing built-in atob() or Buffer()');\n  }\n}\nexport function parseStringParam(s, keepCase) {\n  const value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n  return keepCase ? value : value.toLowerCase();\n}\nexport function getStringParam(attrs, name, def) {\n  let keepCase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const param = attrs[name];\n\n  if (param != null) {\n    return parseStringParam(param.s, keepCase);\n  }\n\n  return def;\n}\nexport function getBoolParam(attrs, name, def) {\n  const param = attrs[name];\n  return param ? param.b : def;\n}\nexport function getNumberParam(attrs, name, def) {\n  const param = attrs[name] || {};\n  const value = param['i'] != null ? param['i'] : param['f'] != null ? param['f'] : def;\n  return typeof value === 'number' ? value : parseInt(value, 10);\n}\nexport function parseDtypeParam(value) {\n  if (typeof value === 'string') {\n    // tslint:disable-next-line:no-any\n    value = tensorflow.DataType[value];\n  }\n\n  switch (value) {\n    case tensorflow.DataType.DT_FLOAT:\n    case tensorflow.DataType.DT_HALF:\n      return 'float32';\n\n    case tensorflow.DataType.DT_INT32:\n    case tensorflow.DataType.DT_INT64:\n    case tensorflow.DataType.DT_INT8:\n    case tensorflow.DataType.DT_UINT8:\n      return 'int32';\n\n    case tensorflow.DataType.DT_BOOL:\n      return 'bool';\n\n    case tensorflow.DataType.DT_DOUBLE:\n      return 'float32';\n\n    case tensorflow.DataType.DT_STRING:\n      return 'string';\n\n    default:\n      // Unknown dtype error will happen at runtime (instead of parse time),\n      // since these nodes might not be used by the actual subgraph execution.\n      return null;\n  }\n}\nexport function getFuncParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.func) {\n    return param.func.name;\n  }\n\n  return def;\n}\nexport function getDtypeParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.type) {\n    return parseDtypeParam(param.type);\n  }\n\n  return def;\n}\nexport function getDtypeArrayParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.list && param.list.type) {\n    return param.list.type.map(v => parseDtypeParam(v));\n  }\n\n  return def;\n}\nexport function parseTensorShapeParam(shape) {\n  if (shape.unknownRank) {\n    return undefined;\n  }\n\n  if (shape.dim != null) {\n    return shape.dim.map(dim => typeof dim.size === 'number' ? dim.size : parseInt(dim.size, 10));\n  }\n\n  return [];\n}\nexport function getTensorShapeParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.shape) {\n    return parseTensorShapeParam(param.shape);\n  }\n\n  return def;\n}\nexport function getNumericArrayParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param) {\n    return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map(v => typeof v === 'number' ? v : parseInt(v, 10));\n  }\n\n  return def;\n}\nexport function getStringArrayParam(attrs, name, def) {\n  let keepCase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const param = attrs[name];\n\n  if (param && param.list && param.list.s) {\n    return param.list.s.map(v => {\n      return parseStringParam(v, keepCase);\n    });\n  }\n\n  return def;\n}\nexport function getTensorShapeArrayParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.list && param.list.shape) {\n    return param.list.shape.map(v => {\n      return parseTensorShapeParam(v);\n    });\n  }\n\n  return def;\n}\nexport function getBoolArrayParam(attrs, name, def) {\n  const param = attrs[name];\n\n  if (param && param.list && param.list.b) {\n    return param.list.b;\n  }\n\n  return def;\n}","map":{"version":3,"mappings":"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","names":["env","tensorflow","getRegisteredOp","getNodeNameAndIndex","arithmetic","basicMath","control","convolution","creation","dynamic","evaluation","graph","hashTable","image","logical","matrices","normalization","reduction","sliceJoin","sparse","spectral","string","transformation","OperationMapper","Instance","_instance","constructor","ops","mappersJson","concat","map","op","json","opMappers","reduce","mapper","tfOpName","transformGraph","signature","tfNodes","node","placeholders","weights","initNodes","nodes","name","mapNode","startsWith","push","input","length","inputs","outputs","inputNodeNameToKey","outputNodeNameToKey","mapSignatureEntries","allNodes","Object","keys","forEach","key","inputNames","index","nodeName","outputName","inputNode","outputIndex","indexOf","inputName","children","signatureKey","functions","library","function","func","mapFunction","result","entries","prev","curr","attr","newNode","category","substr","inputParams","attrParams","rawAttrs","param","type","inputIndexStart","start","inputIndexEnd","end","attrs","value","undefined","getStringParam","tfName","defaultValue","tfDeprecatedName","getStringArrayParam","getNumberParam","getNumericArrayParam","getBoolParam","getBoolArrayParam","getTensorShapeParam","getTensorShapeArrayParam","getDtypeParam","getDtypeArrayParam","getFuncParam","Error","functionDef","nodeDef","inputArg","arg","dtype","parseDtypeParam","returnNodeMap","ret","outputArg","output","defaultOutput","mapArgsToSignature","methodName","mapArgToTensorInfo","nameMap","decodeBase64","text","global","atob","Buffer","toString","parseStringParam","s","keepCase","Array","isArray","String","fromCharCode","apply","toLowerCase","def","b","parseInt","DataType","DT_FLOAT","DT_HALF","DT_INT32","DT_INT64","DT_INT8","DT_UINT8","DT_BOOL","DT_DOUBLE","DT_STRING","list","v","parseTensorShapeParam","shape","unknownRank","dim","size","f","i"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-converter/src/operations/operation_mapper.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, env} from '@tensorflow/tfjs-core';\n\nimport * as tensorflow from '../data/compiled_api';\n\nimport {getRegisteredOp} from './custom_op/register';\nimport {getNodeNameAndIndex} from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as sparse from './op_list/sparse';\nimport * as spectral from './op_list/spectral';\nimport * as string from './op_list/string';\nimport * as transformation from './op_list/transformation';\nimport {Graph, InputParamValue, Node, OpMapper, ParamValue} from './types';\n\nexport class OperationMapper {\n  private static _instance: OperationMapper;\n\n  private opMappers: {[key: string]: OpMapper};\n\n  // Singleton instance for the mapper\n  public static get Instance() {\n    return this._instance || (this._instance = new this());\n  }\n\n  // Loads the op mapping from the JSON file.\n  private constructor() {\n    const ops = [\n      arithmetic, basicMath, control, convolution, creation, dynamic,\n      evaluation, graph, hashTable, image, logical, matrices, normalization,\n      reduction, sliceJoin, sparse, spectral, string, transformation\n    ];\n    const mappersJson: OpMapper[] = [].concat(...ops.map(op => op.json));\n\n    this.opMappers = mappersJson.reduce<{[key: string]: OpMapper}>(\n        (map, mapper: OpMapper) => {\n          map[mapper.tfOpName] = mapper;\n          return map;\n        },\n        {});\n  }\n\n  // Converts the model inference graph from Tensorflow GraphDef to local\n  // representation for TensorFlow.js API\n  transformGraph(\n      graph: tensorflow.IGraphDef,\n      signature: tensorflow.ISignatureDef = {}): Graph {\n    const tfNodes = graph.node;\n    const placeholders: Node[] = [];\n    const weights: Node[] = [];\n    const initNodes: Node[] = [];\n    const nodes = tfNodes.reduce<{[key: string]: Node}>((map, node) => {\n      map[node.name] = this.mapNode(node);\n      if (node.op.startsWith('Placeholder')) {\n        placeholders.push(map[node.name]);\n      } else if (node.op === 'Const') {\n        weights.push(map[node.name]);\n      } else if (node.input == null || node.input.length === 0) {\n        initNodes.push(map[node.name]);\n      }\n      return map;\n    }, {});\n\n    let inputs: Node[] = [];\n    const outputs: Node[] = [];\n    let inputNodeNameToKey: {[key: string]: string} = {};\n    let outputNodeNameToKey: {[key: string]: string} = {};\n    if (signature != null) {\n      inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n      outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n    }\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName, , outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`;\n            // update the input name to use the mapped output index directly.\n            node.inputNames[index] = inputName;\n          }\n        }\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    });\n\n    // if signature has not outputs set, add any node that does not have\n    // outputs.\n    if (Object.keys(outputNodeNameToKey).length === 0) {\n      allNodes.forEach(key => {\n        const node = nodes[key];\n        if (node.children.length === 0) {\n          outputs.push(node);\n        }\n      });\n    } else {\n      Object.keys(outputNodeNameToKey).forEach(name => {\n        const [nodeName, ] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n        if (node != null) {\n          node.signatureKey = outputNodeNameToKey[name];\n          outputs.push(node);\n        }\n      });\n    }\n\n    if (Object.keys(inputNodeNameToKey).length > 0) {\n      Object.keys(inputNodeNameToKey).forEach(name => {\n        const [nodeName, ] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n        if (node) {\n          node.signatureKey = inputNodeNameToKey[name];\n          inputs.push(node);\n        }\n      });\n    } else {\n      inputs = placeholders;\n    }\n\n    let functions = {};\n    if (graph.library != null && graph.library.function != null) {\n      functions = graph.library.function.reduce((functions, func) => {\n        functions[func.signature.name] = this.mapFunction(func);\n        return functions;\n      }, {} as {[key: string]: Graph});\n    }\n\n    const result: Graph =\n        {nodes, inputs, outputs, weights, placeholders, signature, functions};\n\n    if (initNodes.length > 0) {\n      result.initNodes = initNodes;\n    }\n\n    return result;\n  }\n\n  private mapSignatureEntries(entries: {[k: string]: tensorflow.ITensorInfo}) {\n    return Object.keys(entries || {})\n        .reduce<{[key: string]: string}>((prev, curr) => {\n          prev[entries[curr].name] = curr;\n          return prev;\n        }, {});\n  }\n\n  private mapNode(node: tensorflow.INodeDef): Node {\n    // Unsupported ops will cause an error at run-time (not parse time), since\n    // they may not be used by the actual execution subgraph.\n    const mapper =\n        getRegisteredOp(node.op) || this.opMappers[node.op] || {} as OpMapper;\n    if (node.attr == null) {\n      node.attr = {};\n    }\n\n    const newNode: Node = {\n      name: node.name,\n      op: node.op,\n      category: mapper.category,\n      inputNames:\n          (node.input ||\n           []).map(input => input.startsWith('^') ? input.substr(1) : input),\n      inputs: [],\n      children: [],\n      inputParams: {},\n      attrParams: {},\n      rawAttrs: node.attr,\n      outputs: mapper.outputs\n    };\n\n    if (mapper.inputs != null) {\n      newNode.inputParams =\n          mapper.inputs.reduce<{[key: string]: InputParamValue}>(\n              (map, param) => {\n                map[param.name] = {\n                  type: param.type,\n                  inputIndexStart: param.start,\n                  inputIndexEnd: param.end\n                };\n                return map;\n              },\n              {});\n    }\n    if (mapper.attrs != null) {\n      newNode.attrParams =\n          mapper.attrs.reduce<{[key: string]: ParamValue}>((map, param) => {\n            const type = param.type;\n            let value = undefined;\n            switch (param.type) {\n              case 'string':\n                value = getStringParam(\n                    node.attr, param.tfName, param.defaultValue as string);\n\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getStringParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as string);\n                }\n                break;\n              case 'string[]':\n                value = getStringArrayParam(\n                    node.attr, param.tfName, param.defaultValue as string[]);\n\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getStringArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as string[]);\n                }\n                break;\n              case 'number':\n                value = getNumberParam(\n                    node.attr, param.tfName,\n                    (param.defaultValue || 0) as number);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getNumberParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number);\n                }\n                break;\n              case 'number[]':\n                value = getNumericArrayParam(\n                    node.attr, param.tfName, param.defaultValue as number[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getNumericArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number[]);\n                }\n                break;\n              case 'bool':\n                value = getBoolParam(\n                    node.attr, param.tfName, param.defaultValue as boolean);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getBoolParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as boolean);\n                }\n                break;\n              case 'bool[]':\n                value = getBoolArrayParam(\n                    node.attr, param.tfName, param.defaultValue as boolean[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getBoolArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as boolean[]);\n                }\n                break;\n              case 'shape':\n                value = getTensorShapeParam(\n                    node.attr, param.tfName, param.defaultValue as number[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getTensorShapeParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number[]);\n                }\n                break;\n              case 'shape[]':\n                value = getTensorShapeArrayParam(\n                    node.attr, param.tfName, param.defaultValue as number[][]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getTensorShapeArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number[][]);\n                }\n                break;\n              case 'dtype':\n                value = getDtypeParam(\n                    node.attr, param.tfName, param.defaultValue as DataType);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getDtypeParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as DataType);\n                }\n                break;\n              case 'dtype[]':\n                value = getDtypeArrayParam(\n                    node.attr, param.tfName, param.defaultValue as DataType[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getDtypeArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as DataType[]);\n                }\n                break;\n              case 'func':\n                value = getFuncParam(\n                    node.attr, param.tfName, param.defaultValue as string);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getFuncParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as string);\n                }\n                break;\n              case 'tensor':\n              case 'tensors':\n                break;\n              default:\n                throw new Error(\n                    `Unsupported param type: ${param.type} for op: ${node.op}`);\n            }\n            map[param.name] = {value, type};\n            return map;\n          }, {});\n    }\n    return newNode;\n  }\n\n  // map the TFunctionDef to TFJS graph object\n  private mapFunction(functionDef: tensorflow.IFunctionDef): Graph {\n    const tfNodes = functionDef.nodeDef;\n    const placeholders: Node[] = [];\n    const weights: Node[] = [];\n    let nodes: {[key: string]: Node} = {};\n    if (tfNodes != null) {\n      nodes = tfNodes.reduce<{[key: string]: Node}>((map, node) => {\n        map[node.name] = this.mapNode(node);\n        if (node.op === 'Const') {\n          weights.push(map[node.name]);\n        }\n        return map;\n      }, {});\n    }\n    const inputs: Node[] = [];\n    const outputs: Node[] = [];\n\n    functionDef.signature.inputArg.forEach(arg => {\n      const [nodeName, ] = getNodeNameAndIndex(arg.name);\n      const node: Node = {\n        name: nodeName,\n        op: 'Placeholder',\n        inputs: [],\n        inputNames: [],\n        category: 'graph',\n        inputParams: {},\n        attrParams: {dtype: {value: parseDtypeParam(arg.type), type: 'dtype'}},\n        children: []\n      };\n      node.signatureKey = arg.name;\n      inputs.push(node);\n      nodes[nodeName] = node;\n    });\n\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName, , outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`;\n            // update the input name to use the mapped output index directly.\n            node.inputNames[index] = inputName;\n          }\n        }\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    });\n\n    const returnNodeMap = functionDef.ret;\n\n    functionDef.signature.outputArg.forEach(output => {\n      const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);\n      const node = nodes[nodeName];\n      if (node != null) {\n        node.defaultOutput = index;\n        outputs.push(node);\n      }\n    });\n\n    const signature = this.mapArgsToSignature(functionDef);\n    return {nodes, inputs, outputs, weights, placeholders, signature};\n  }\n\n  private mapArgsToSignature(functionDef: tensorflow.IFunctionDef):\n      tensorflow.ISignatureDef {\n    return {\n      methodName: functionDef.signature.name,\n      inputs: functionDef.signature.inputArg.reduce(\n          (map, arg) => {\n            map[arg.name] = this.mapArgToTensorInfo(arg);\n            return map;\n          },\n          {} as {[key: string]: tensorflow.ITensorInfo}),\n      outputs: functionDef.signature.outputArg.reduce(\n          (map, arg) => {\n            map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);\n            return map;\n          },\n          {} as {[key: string]: tensorflow.ITensorInfo}),\n    };\n  }\n\n  private mapArgToTensorInfo(\n      arg: tensorflow.OpDef.IArgDef,\n      nameMap?: {[key: string]: string}): tensorflow.ITensorInfo {\n    let name = arg.name;\n    if (nameMap != null) {\n      name = nameMap[name];\n    }\n    return {name, dtype: arg.type};\n  }\n}\n\nexport function decodeBase64(text: string): string {\n  const global = env().global;\n  if (typeof global.atob !== 'undefined') {\n    return global.atob(text);\n  } else if (typeof Buffer !== 'undefined') {\n    return new Buffer(text, 'base64').toString();\n  } else {\n    throw new Error(\n        'Unable to decode base64 in this environment. ' +\n        'Missing built-in atob() or Buffer()');\n  }\n}\n\nexport function parseStringParam(s: []|string, keepCase: boolean): string {\n  const value =\n      Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n  return keepCase ? value : value.toLowerCase();\n}\n\nexport function getStringParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string, def: string,\n    keepCase = false): string {\n  const param = attrs[name];\n  if (param != null) {\n    return parseStringParam(param.s, keepCase);\n  }\n  return def;\n}\n\nexport function getBoolParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: boolean): boolean {\n  const param = attrs[name];\n  return param ? param.b : def;\n}\n\nexport function getNumberParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: number): number {\n  const param = attrs[name] || {};\n  const value =\n      param['i'] != null ? param['i'] : (param['f'] != null ? param['f'] : def);\n  return (typeof value === 'number') ? value : parseInt(value, 10);\n}\n\nexport function parseDtypeParam(value: string|tensorflow.DataType): DataType {\n  if (typeof (value) === 'string') {\n    // tslint:disable-next-line:no-any\n    value = tensorflow.DataType[value as any];\n  }\n  switch (value) {\n    case tensorflow.DataType.DT_FLOAT:\n    case tensorflow.DataType.DT_HALF:\n      return 'float32';\n    case tensorflow.DataType.DT_INT32:\n    case tensorflow.DataType.DT_INT64:\n    case tensorflow.DataType.DT_INT8:\n    case tensorflow.DataType.DT_UINT8:\n      return 'int32';\n    case tensorflow.DataType.DT_BOOL:\n      return 'bool';\n    case tensorflow.DataType.DT_DOUBLE:\n      return 'float32';\n    case tensorflow.DataType.DT_STRING:\n      return 'string';\n    default:\n      // Unknown dtype error will happen at runtime (instead of parse time),\n      // since these nodes might not be used by the actual subgraph execution.\n      return null;\n  }\n}\n\nexport function getFuncParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: string): string {\n  const param = attrs[name];\n  if (param && param.func) {\n    return param.func.name;\n  }\n  return def;\n}\n\nexport function getDtypeParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: DataType): DataType {\n  const param = attrs[name];\n  if (param && param.type) {\n    return parseDtypeParam(param.type);\n  }\n  return def;\n}\n\nexport function getDtypeArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: DataType[]): DataType[] {\n  const param = attrs[name];\n  if (param && param.list && param.list.type) {\n    return param.list.type.map(v => parseDtypeParam(v));\n  }\n  return def;\n}\n\nexport function parseTensorShapeParam(shape: tensorflow.ITensorShape): number[]|\n    undefined {\n  if (shape.unknownRank) {\n    return undefined;\n  }\n  if (shape.dim != null) {\n    return shape.dim.map(\n        dim =>\n            (typeof dim.size === 'number') ? dim.size : parseInt(dim.size, 10));\n  }\n  return [];\n}\n\nexport function getTensorShapeParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def?: number[]): number[]|undefined {\n  const param = attrs[name];\n  if (param && param.shape) {\n    return parseTensorShapeParam(param.shape);\n  }\n  return def;\n}\n\nexport function getNumericArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: number[]): number[] {\n  const param = attrs[name];\n  if (param) {\n    return ((param.list.f && param.list.f.length ? param.list.f :\n                                                   param.list.i) ||\n            [])\n        .map(v => (typeof v === 'number') ? v : parseInt(v, 10));\n  }\n  return def;\n}\n\nexport function getStringArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string, def: string[],\n    keepCase = false): string[] {\n  const param = attrs[name];\n  if (param && param.list && param.list.s) {\n    return param.list.s.map((v) => {\n      return parseStringParam(v, keepCase);\n    });\n  }\n  return def;\n}\n\nexport function getTensorShapeArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: number[][]): number[][] {\n  const param = attrs[name];\n  if (param && param.list && param.list.shape) {\n    return param.list.shape.map((v) => {\n      return parseTensorShapeParam(v);\n    });\n  }\n  return def;\n}\n\nexport function getBoolArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: boolean[]): boolean[] {\n  const param = attrs[name];\n  if (param && param.list && param.list.b) {\n    return param.list.b;\n  }\n  return def;\n}\n"]},"metadata":{},"sourceType":"module"}