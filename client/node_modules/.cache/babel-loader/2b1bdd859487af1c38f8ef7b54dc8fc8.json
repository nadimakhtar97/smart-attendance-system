{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport class GPGPUContext {\n  constructor(gl) {\n    this.outputTexture = null;\n    this.program = null;\n    this.disposed = false;\n    this.vertexAttrsAreBound = false;\n    this.itemsToPoll = [];\n    const glVersion = env().getNumber('WEBGL_VERSION');\n\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    } // WebGL 2.0 enables texture floats without an extension.\n\n\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n      this.textureFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support half float textures, yet the ' + 'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support color renderable half floats, yet ' + 'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n    this.textureConfig = tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  get debug() {\n    return env().getBool('DEBUG');\n  }\n\n  dispose() {\n    if (this.disposed) {\n      return;\n    }\n\n    if (this.program != null) {\n      console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' + ' This is probably a resource leak, delete the program with ' + 'GPGPUContext.deleteProgram before disposing.');\n    }\n\n    if (this.outputTexture != null) {\n      console.warn('Disposing a GPGPUContext that still has a bound output matrix ' + 'texture.  This is probably a resource leak, delete the output ' + 'matrix texture with GPGPUContext.deleteMatrixTexture before ' + 'disposing.');\n    }\n\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, () => gl.finish());\n    webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n\n  createFloat32MatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  createFloat16MatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  createUnsignedBytesMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  uploadPixelDataToTexture(texture, pixels) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n  }\n\n  uploadDenseMatrixToTexture(texture, width, height, data) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n  }\n\n  createFloat16PackedMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  createPackedMatrixTexture(rows, columns) {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n  }\n\n  deleteMatrixTexture(texture) {\n    this.throwIfDisposed();\n\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      this.outputTexture = null;\n    }\n\n    webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n  }\n\n  downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n    return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));\n  }\n\n  downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n  }\n\n  downloadFloat32MatrixFromBuffer(buffer, size) {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n\n  createBufferFromTexture(texture, rows, columns) {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  createAndWaitForFence() {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  createFence(gl) {\n    let query;\n    let isFencePassed;\n\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl;\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;\n      };\n\n      query = sync;\n    } else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n\n      isFencePassed = () => this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n\n    return {\n      query,\n      isFencePassed\n    };\n  }\n\n  downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n    return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));\n  }\n\n  createProgram(fragmentShader) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n\n    if (this.vertexShader == null) {\n      this.vertexShader = gpgpu_util.createVertexShader(gl);\n    }\n\n    const program = webgl_util.createProgram(gl);\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, this.vertexShader));\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, program);\n\n    if (this.debug) {\n      webgl_util.validateProgram(gl, program);\n    }\n\n    if (!this.vertexAttrsAreBound) {\n      this.setProgram(program);\n      this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n    }\n\n    return program;\n  }\n\n  deleteProgram(program) {\n    this.throwIfDisposed();\n\n    if (program === this.program) {\n      this.program = null;\n    }\n\n    if (program != null) {\n      webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n    }\n  }\n\n  setProgram(program) {\n    this.throwIfDisposed();\n    this.program = program;\n\n    if (this.program != null && this.debug) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n\n    webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n  }\n\n  getUniformLocation(program, uniformName) {\n    let shouldThrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    this.throwIfDisposed();\n\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n    }\n  }\n\n  getAttributeLocation(program, attribute) {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));\n  }\n\n  getUniformLocationNoThrow(program, uniformName) {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n\n  setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n  }\n\n  setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n\n  setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n    this.throwIfDisposed();\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n\n  setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n    this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n  }\n\n  setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n\n  debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n\n    webgl_util.validateFramebuffer(this.gl);\n  }\n\n  executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n\n    if (this.debug) {\n      this.debugValidate();\n    }\n\n    webgl_util.callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n\n  blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n  }\n\n  getQueryTimerExtension() {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension = webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ? 'EXT_disjoint_timer_query_webgl2' : 'EXT_disjoint_timer_query');\n    }\n\n    return this.disjointQueryTimerExtension;\n  }\n\n  getQueryTimerExtensionWebGL2() {\n    return this.getQueryTimerExtension();\n  }\n\n  getQueryTimerExtensionWebGL1() {\n    return this.getQueryTimerExtension();\n  }\n\n  beginQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT();\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n\n  async waitForQueryAndGetTime(query) {\n    await util.repeatedTry(() => this.disposed || // while testing contexts are created / disposed\n    // in rapid succession, so without this check we\n    // may poll for the query timer indefinitely\n    this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n    return this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n  }\n\n  getQueryTime(query, queryTimerVersion) {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl;\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT); // Return milliseconds.\n\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n      const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT); // Return milliseconds.\n\n      return timeElapsedNanos / 1000000;\n    }\n  }\n\n  isQueryAvailable(query, queryTimerVersion) {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n      const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    }\n  }\n\n  pollFence(fenceContext) {\n    return new Promise(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  pollItems() {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n\n    for (let i = 0; i <= index; ++i) {\n      const {\n        resolveFn\n      } = this.itemsToPoll[i];\n      resolveFn();\n    }\n\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  addItemToPoll(isDoneFn, resolveFn) {\n    this.itemsToPoll.push({\n      isDoneFn,\n      resolveFn\n    });\n\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    } // Start a new loop that polls.\n\n\n    util.repeatedTry(() => {\n      this.pollItems(); // End the loop if no more items to poll.\n\n      return this.itemsToPoll.length === 0;\n    });\n  }\n\n  bindTextureToFrameBuffer(texture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n\n  unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n    }\n  }\n\n  downloadMatrixDriver(texture, downloadAndDecode) {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n  }\n\n  setOutputMatrixWriteRegionDriver(x, y, width, height) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));\n  }\n\n  throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n\n  throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n\n}\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\n\nexport function linearSearchLastTrue(arr) {\n  let i = 0;\n\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n\n    if (!isDone) {\n      break;\n    }\n  }\n\n  return i - 1;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,GAAR,EAAoCC,IAApC,QAA+C,uBAA/C;AAEA,SAAQC,eAAR,EAAyBC,eAAzB,QAA+C,eAA/C;AACA,OAAO,KAAKC,UAAZ,MAA4B,cAA5B;AACA,OAAO,KAAKC,QAAZ,MAA0B,YAA1B;AAGA,OAAO,KAAKC,UAAZ,MAA4B,cAA5B;AAOA,OAAM,MAAOC,YAAP,CAAmB;AAkBvBC,cAAYC,EAAZ,EAAsC;AAPtC,yBAAmC,IAAnC;AACA,mBAA6B,IAA7B;AACQ,oBAAW,KAAX;AAoOA,+BAAsB,KAAtB;AAuPA,uBAA0B,EAA1B;AArdN,UAAMC,SAAS,GAAGV,GAAG,GAAGW,SAAN,CAAgB,eAAhB,CAAlB;;AACA,QAAIF,EAAE,IAAI,IAAV,EAAgB;AACd,WAAKA,EAAL,GAAUA,EAAV;AACAN,qBAAe,CAACO,SAAD,EAAYD,EAAZ,CAAf;AACD,KAHD,MAGO;AACL,WAAKA,EAAL,GAAUP,eAAe,CAACQ,SAAD,CAAzB;AACD,KAPmC,CAQpC;;;AACA,QAAIE,kBAAkB,GAAG,0BAAzB;AACA,UAAMC,uBAAuB,GAAG,6BAAhC;;AACA,QAAIb,GAAG,GAAGW,SAAN,CAAgB,eAAhB,MAAqC,CAAzC,EAA4C;AAC1C,YAAMG,aAAa,GAAG,mBAAtB;AACA,YAAMC,kBAAkB,GAAG,wBAA3B;AAEA,WAAKC,qBAAL,GACIV,UAAU,CAACW,mBAAX,CAA+B,KAAKR,EAApC,EAAwCK,aAAxC,CADJ;;AAEA,UAAIR,UAAU,CAACY,YAAX,CAAwB,KAAKT,EAA7B,EAAiCM,kBAAjC,CAAJ,EAA0D;AACxD,aAAKI,yBAAL,GACIb,UAAU,CAACW,mBAAX,CAA+B,KAAKR,EAApC,EAAwCM,kBAAxC,CADJ;AAED,OAHD,MAGO,IAAIf,GAAG,GAAGoB,GAAN,CAAU,0BAAV,CAAJ,EAA2C;AAChD,cAAM,IAAIC,KAAJ,CACF,8DACA,2DAFE,CAAN;AAGD;;AAED,WAAKC,yBAAL,GAAiC,KAAKb,EAAL,CAAQc,YAAR,CAAqBX,kBAArB,CAAjC;;AACA,UAAIN,UAAU,CAACY,YAAX,CAAwB,KAAKT,EAA7B,EAAiCI,uBAAjC,CAAJ,EAA+D;AAC7D,aAAKW,6BAAL,GACIlB,UAAU,CAACW,mBAAX,CAA+B,KAAKR,EAApC,EAAwCI,uBAAxC,CADJ;AAED,OAHD,MAGO,IAAIb,GAAG,GAAGoB,GAAN,CAAU,0BAAV,CAAJ,EAA2C;AAChD,cAAM,IAAIC,KAAJ,CACF,mEACA,+DAFE,CAAN;AAGD;AACF,KAxBD,MAwBO;AACLT,wBAAkB,GAAG,wBAArB;;AACA,UAAIN,UAAU,CAACY,YAAX,CAAwB,KAAKT,EAA7B,EAAiCG,kBAAjC,CAAJ,EAA0D;AACxD,aAAKU,yBAAL,GACI,KAAKb,EAAL,CAAQc,YAAR,CAAqBX,kBAArB,CADJ;AAED,OAHD,MAGO,IAAIN,UAAU,CAACY,YAAX,CAAwB,KAAKT,EAA7B,EAAiCI,uBAAjC,CAAJ,EAA+D;AACpE,aAAKW,6BAAL,GACI,KAAKf,EAAL,CAAQc,YAAR,CAAqBV,uBAArB,CADJ;AAED,OAHM,MAGA;AACL,cAAM,IAAIQ,KAAJ,CAAU,qDAAV,CAAN;AACD;AACF;;AAED,SAAKI,YAAL,GAAoBrB,UAAU,CAACsB,kBAAX,CAA8B,KAAKjB,EAAnC,CAApB;AACA,SAAKkB,WAAL,GAAmBvB,UAAU,CAACwB,iBAAX,CAA6B,KAAKnB,EAAlC,CAAnB;AACA,SAAKoB,WAAL,GAAmBvB,UAAU,CAACwB,iBAAX,CAA6B,KAAKrB,EAAlC,CAAnB;AAEA,SAAKsB,aAAL,GACI1B,QAAQ,CAAC2B,gBAAT,CAA0B,KAAKvB,EAA/B,EAAmC,KAAKU,yBAAxC,CADJ;AAED;;AAEgB,MAALc,KAAK;AACf,WAAOjC,GAAG,GAAGkC,OAAN,CAAc,OAAd,CAAP;AACD;;AAEMC,SAAO;AACZ,QAAI,KAAKC,QAAT,EAAmB;AACjB;AACD;;AACD,QAAI,KAAKC,OAAL,IAAgB,IAApB,EAA0B;AACxBC,aAAO,CAACC,IAAR,CACI,kEACA,6DADA,GAEA,8CAHJ;AAID;;AACD,QAAI,KAAKC,aAAL,IAAsB,IAA1B,EAAgC;AAC9BF,aAAO,CAACC,IAAR,CACI,mEACA,gEADA,GAEA,8DAFA,GAGA,YAJJ;AAKD;;AACD,UAAM9B,EAAE,GAAG,KAAKA,EAAhB;AACAH,cAAU,CAACmC,YAAX,CAAwBhC,EAAxB,EAA4B,MAAMA,EAAE,CAACiC,MAAH,EAAlC;AACApC,cAAU,CAACmC,YAAX,CAAwBhC,EAAxB,EAA4B,MAAMA,EAAE,CAACkC,eAAH,CAAmBlC,EAAE,CAACmC,WAAtB,EAAmC,IAAnC,CAAlC;AACAtC,cAAU,CAACmC,YAAX,CAAwBhC,EAAxB,EAA4B,MAAMA,EAAE,CAACoC,iBAAH,CAAqB,KAAKhB,WAA1B,CAAlC;AACAvB,cAAU,CAACmC,YAAX,CAAwBhC,EAAxB,EAA4B,MAAMA,EAAE,CAACqC,UAAH,CAAcrC,EAAE,CAACsC,YAAjB,EAA+B,IAA/B,CAAlC;AACAzC,cAAU,CAACmC,YAAX,CACIhC,EADJ,EACQ,MAAMA,EAAE,CAACqC,UAAH,CAAcrC,EAAE,CAACuC,oBAAjB,EAAuC,IAAvC,CADd;AAEA1C,cAAU,CAACmC,YAAX,CAAwBhC,EAAxB,EAA4B,MAAMA,EAAE,CAACwC,YAAH,CAAgB,KAAKtB,WAArB,CAAlC;AACA,SAAKS,QAAL,GAAgB,IAAhB;AACD;;AAEMc,4BAA0B,CAACC,IAAD,EAAeC,OAAf,EAA8B;AAC7D,SAAKC,eAAL;AACA,WAAOjD,UAAU,CAAC8C,0BAAX,CACH,KAAKzC,EADF,EACM0C,IADN,EACYC,OADZ,EACqB,KAAKrB,aAD1B,CAAP;AAED;;AAEMuB,4BAA0B,CAACH,IAAD,EAAeC,OAAf,EAA8B;AAC7D,SAAKC,eAAL;AACA,WAAOjD,UAAU,CAACkD,0BAAX,CACH,KAAK7C,EADF,EACM0C,IADN,EACYC,OADZ,EACqB,KAAKrB,aAD1B,CAAP;AAED;;AAEMwB,kCAAgC,CAACJ,IAAD,EAAeC,OAAf,EAA8B;AAEnE,SAAKC,eAAL;AACA,WAAOjD,UAAU,CAACmD,gCAAX,CACH,KAAK9C,EADF,EACM0C,IADN,EACYC,OADZ,EACqB,KAAKrB,aAD1B,CAAP;AAED;;AAEMyB,0BAAwB,CAC3BC,OAD2B,EAE3BC,MAF2B,EAGhB;AACb,SAAKL,eAAL;AACAjD,cAAU,CAACoD,wBAAX,CAAoC,KAAK/C,EAAzC,EAA6CgD,OAA7C,EAAsDC,MAAtD;AACD;;AAEMC,4BAA0B,CAC7BF,OAD6B,EACNG,KADM,EACSC,MADT,EACyBC,IADzB,EACyC;AACxE,SAAKT,eAAL;AACAjD,cAAU,CAACuD,0BAAX,CACI,KAAKlD,EADT,EACagD,OADb,EACsBG,KADtB,EAC6BC,MAD7B,EACqCC,IADrC,EAC2C,KAAK/B,aADhD;AAED;;AAEMgC,kCAAgC,CAACZ,IAAD,EAAeC,OAAf,EAA8B;AAEnE,SAAKC,eAAL;AACA,WAAOjD,UAAU,CAAC2D,gCAAX,CACH,KAAKtD,EADF,EACM0C,IADN,EACYC,OADZ,EACqB,KAAKrB,aAD1B,CAAP;AAED;;AAEMiC,2BAAyB,CAACb,IAAD,EAAeC,OAAf,EAA8B;AAC5D,SAAKC,eAAL;AACA,WAAOjD,UAAU,CAAC4D,yBAAX,CACH,KAAKvD,EADF,EACM0C,IADN,EACYC,OADZ,EACqB,KAAKrB,aAD1B,CAAP;AAED;;AAEMkC,qBAAmB,CAACR,OAAD,EAAsB;AAC9C,SAAKJ,eAAL;;AACA,QAAI,KAAKb,aAAL,KAAuBiB,OAA3B,EAAoC;AAClCnD,gBAAU,CAAC4D,iCAAX,CAA6C,KAAKzD,EAAlD,EAAsD,KAAKoB,WAA3D;AACA,WAAKW,aAAL,GAAqB,IAArB;AACD;;AACDlC,cAAU,CAACmC,YAAX,CAAwB,KAAKhC,EAA7B,EAAiC,MAAM,KAAKA,EAAL,CAAQ0D,aAAR,CAAsBV,OAAtB,CAAvC;AACD;;AAEMW,iDAA+C,CAClDX,OADkD,EAC3BN,IAD2B,EACbC,OADa,EACE;AACtD,WAAO,KAAKiB,oBAAL,CACHZ,OADG,EAEH,MAAMrD,UAAU,CAACgE,+CAAX,CACF,KAAK3D,EADH,EACO0C,IADP,EACaC,OADb,EACsB,KAAKrB,aAD3B,CAFH,CAAP;AAID;;AAEMuC,gCAA8B,CACjCC,MADiC,EACZC,KADY,EACGrB,IADH,EACiBC,OADjB,EAEjCqB,YAFiC,EAEXC,YAFW,EAES;AAC5C,WAAOtE,UAAU,CAACkE,8BAAX,CACH,KAAK7D,EADF,EACM8D,MADN,EACcC,KADd,EACqBrB,IADrB,EAC2BC,OAD3B,EACoCqB,YADpC,EACkDC,YADlD,EAEH,KAAK3C,aAFF,CAAP;AAGD;;AAEM4C,iCAA+B,CAACJ,MAAD,EAAsBK,IAAtB,EAAkC;AAEtE,WAAOxE,UAAU,CAACuE,+BAAX,CAA2C,KAAKlE,EAAhD,EAAoD8D,MAApD,EAA4DK,IAA5D,CAAP;AACD;;AAEMC,yBAAuB,CAC1BpB,OAD0B,EACHN,IADG,EACWC,OADX,EAC0B;AACtD,SAAK0B,wBAAL,CAA8BrB,OAA9B;AACA,UAAMsB,MAAM,GAAG3E,UAAU,CAAC4E,6BAAX,CACX,KAAKvE,EADM,EACwB0C,IADxB,EAC8BC,OAD9B,EACuC,KAAKrB,aAD5C,CAAf;AAEA,SAAKkD,0BAAL;AACA,WAAOF,MAAP;AACD;;AAEMG,uBAAqB;AAC1B,UAAMC,YAAY,GAAG,KAAKC,WAAL,CAAiB,KAAK3E,EAAtB,CAArB;AACA,WAAO,KAAK4E,SAAL,CAAeF,YAAf,CAAP;AACD;;AAEOC,aAAW,CAAC3E,EAAD,EAA0B;AAC3C,QAAI6E,KAAJ;AACA,QAAIC,aAAJ;;AAEA,QAAIvF,GAAG,GAAGkC,OAAN,CAAc,yBAAd,CAAJ,EAA8C;AAC5C,YAAMsD,GAAG,GAAG/E,EAAZ;AAEA,YAAMgF,IAAI,GAAGD,GAAG,CAACE,SAAJ,CAAcF,GAAG,CAACG,0BAAlB,EAA8C,CAA9C,CAAb;AACAlF,QAAE,CAACmF,KAAH;;AAEAL,mBAAa,GAAG,MAAK;AACnB,cAAMM,MAAM,GAAGL,GAAG,CAACM,cAAJ,CAAmBL,IAAnB,EAAyB,CAAzB,EAA4B,CAA5B,CAAf;AACA,eAAOI,MAAM,KAAKL,GAAG,CAACO,gBAAf,IACHF,MAAM,KAAKL,GAAG,CAACQ,mBADnB;AAED,OAJD;;AAMAV,WAAK,GAAGG,IAAR;AACD,KAbD,MAaO,IACHzF,GAAG,GAAGW,SAAN,CAAgB,8CAAhB,IAAkE,CAD/D,EACkE;AACvE2E,WAAK,GAAG,KAAKW,UAAL,EAAR;AACA,WAAKC,QAAL;;AACAX,mBAAa,GAAG,MAAM,KAAKY,gBAAL,CAClBb,KADkB,EAElBtF,GAAG,GAAGW,SAAN,CAAgB,8CAAhB,CAFkB,CAAtB;AAGD,KAPM,MAOA;AACL;AACA;AACA;AACA;AACA4E,mBAAa,GAAG,MAAM,IAAtB;AACD;;AAED,WAAO;AAACD,WAAD;AAAQC;AAAR,KAAP;AACD;;AAEMa,iCAA+B,CAClC3C,OADkC,EACXgB,YADW,EAElCC,YAFkC,EAEd;AACtB,WAAO,KAAKL,oBAAL,CACHZ,OADG,EAEH,MAAMrD,UAAU,CAACiG,qCAAX,CACF,KAAK5F,EADH,EACOgE,YADP,EACqBC,YADrB,CAFH,CAAP;AAID;;AAIM4B,eAAa,CAACC,cAAD,EAA4B;AAC9C,SAAKlD,eAAL;AACA,UAAM5C,EAAE,GAAG,KAAKA,EAAhB;;AACA,QAAI,KAAK+F,YAAL,IAAqB,IAAzB,EAA+B;AAC7B,WAAKA,YAAL,GAAoBpG,UAAU,CAACqG,kBAAX,CAA8BhG,EAA9B,CAApB;AACD;;AACD,UAAM4B,OAAO,GAAiB/B,UAAU,CAACgG,aAAX,CAAyB7F,EAAzB,CAA9B;AACAH,cAAU,CAACmC,YAAX,CACIhC,EADJ,EACQ,MAAMA,EAAE,CAACiG,YAAH,CAAgBrE,OAAhB,EAAyB,KAAKmE,YAA9B,CADd;AAEAlG,cAAU,CAACmC,YAAX,CAAwBhC,EAAxB,EAA4B,MAAMA,EAAE,CAACiG,YAAH,CAAgBrE,OAAhB,EAAyBkE,cAAzB,CAAlC;AACAjG,cAAU,CAACqG,WAAX,CAAuBlG,EAAvB,EAA2B4B,OAA3B;;AACA,QAAI,KAAKJ,KAAT,EAAgB;AACd3B,gBAAU,CAACsG,eAAX,CAA2BnG,EAA3B,EAA+B4B,OAA/B;AACD;;AACD,QAAI,CAAC,KAAKwE,mBAAV,EAA+B;AAC7B,WAAKC,UAAL,CAAgBzE,OAAhB;AACA,WAAKwE,mBAAL,GAA2BzG,UAAU,CAAC2G,iCAAX,CACvBtG,EADuB,EACnB,KAAK4B,OADc,EACL,KAAKZ,YADA,CAA3B;AAED;;AACD,WAAOY,OAAP;AACD;;AAEM2E,eAAa,CAAC3E,OAAD,EAAsB;AACxC,SAAKgB,eAAL;;AACA,QAAIhB,OAAO,KAAK,KAAKA,OAArB,EAA8B;AAC5B,WAAKA,OAAL,GAAe,IAAf;AACD;;AACD,QAAIA,OAAO,IAAI,IAAf,EAAqB;AACnB/B,gBAAU,CAACmC,YAAX,CAAwB,KAAKhC,EAA7B,EAAiC,MAAM,KAAKA,EAAL,CAAQuG,aAAR,CAAsB3E,OAAtB,CAAvC;AACD;AACF;;AAEMyE,YAAU,CAACzE,OAAD,EAA2B;AAC1C,SAAKgB,eAAL;AACA,SAAKhB,OAAL,GAAeA,OAAf;;AACA,QAAK,KAAKA,OAAL,IAAgB,IAAjB,IAA0B,KAAKJ,KAAnC,EAA0C;AACxC3B,gBAAU,CAACsG,eAAX,CAA2B,KAAKnG,EAAhC,EAAoC,KAAK4B,OAAzC;AACD;;AACD/B,cAAU,CAACmC,YAAX,CAAwB,KAAKhC,EAA7B,EAAiC,MAAM,KAAKA,EAAL,CAAQwG,UAAR,CAAmB5E,OAAnB,CAAvC;AACD;;AAEM6E,oBAAkB,CACrB7E,OADqB,EACE8E,WADF,EAEH;AAAA,QAAlBC,WAAkB,uEAAJ,IAAI;AACpB,SAAK/D,eAAL;;AACA,QAAI+D,WAAJ,EAAiB;AACf,aAAO9G,UAAU,CAAC+G,gCAAX,CACH,KAAK5G,EADF,EACM4B,OADN,EACe8E,WADf,CAAP;AAED,KAHD,MAGO;AACL,aAAO7G,UAAU,CAACgH,yBAAX,CACH,KAAK7G,EADF,EACM4B,OADN,EACe8E,WADf,CAAP;AAED;AACF;;AAEMI,sBAAoB,CAAClF,OAAD,EAAwBmF,SAAxB,EAAyC;AAElE,SAAKnE,eAAL;AACA,WAAO/C,UAAU,CAACmC,YAAX,CACH,KAAKhC,EADF,EACM,MAAM,KAAKA,EAAL,CAAQgH,iBAAR,CAA0BpF,OAA1B,EAAmCmF,SAAnC,CADZ,CAAP;AAED;;AAEME,2BAAyB,CAACrF,OAAD,EAAwB8E,WAAxB,EAA2C;AAEzE,SAAK9D,eAAL;AACA,WAAO,KAAK5C,EAAL,CAAQyG,kBAAR,CAA2B7E,OAA3B,EAAoC8E,WAApC,CAAP;AACD;;AAEMQ,uBAAqB,CACxBC,kBADwB,EACUC,eADV,EAExBC,WAFwB,EAEL;AACrB,SAAKzE,eAAL;AACA,SAAK0E,gBAAL;AACAzH,cAAU,CAAC0H,kCAAX,CACI,KAAKvH,EADT,EACamH,kBADb,EACiCC,eADjC,EACkDC,WADlD;AAED;;AAEMG,wBAAsB,CACzBC,mBADyB,EACU/E,IADV,EACwBC,OADxB,EACuC;AAClE,SAAK+E,4BAAL,CAAkCD,mBAAlC,EAAuD9E,OAAvD,EAAgED,IAAhE;AACD;;AAEMiF,8BAA4B,CAC/BC,yBAD+B,EACUlF,IADV,EACwBC,OADxB,EACuC;AACxE,SAAKC,eAAL;AACA,UAAM,CAACO,KAAD,EAAQC,MAAR,IACFxD,QAAQ,CAACiI,sCAAT,CAAgDnF,IAAhD,EAAsDC,OAAtD,CADJ;AAEA,SAAK+E,4BAAL,CAAkCE,yBAAlC,EAA6DzE,KAA7D,EAAoEC,MAApE;AACD;;AAEM0E,4BAA0B,CAC7BC,QAD6B,EACXC,OADW,EACMC,WADN,EAE7BC,UAF6B,EAEX;AACpB,SAAKC,gCAAL,CACIF,WADJ,EACiBF,QADjB,EAC2BG,UAD3B,EACuCF,OADvC;AAED;;AAEMI,kCAAgC,CACnCL,QADmC,EACjBC,OADiB,EACAC,WADA,EAEnCC,UAFmC,EAEjB;AACpB,UAAM,IAAItH,KAAJ,CAAU,mDAAV,CAAN;AACD;;AAEMyH,eAAa;AAClB,QAAI,KAAKzG,OAAL,IAAgB,IAApB,EAA0B;AACxB/B,gBAAU,CAACsG,eAAX,CAA2B,KAAKnG,EAAhC,EAAoC,KAAK4B,OAAzC;AACD;;AACD/B,cAAU,CAACyI,mBAAX,CAA+B,KAAKtI,EAApC;AACD;;AAEMuI,gBAAc;AACnB,SAAK3F,eAAL;AACA,SAAK0E,gBAAL;AACA,UAAMtH,EAAE,GAAG,KAAKA,EAAhB;;AACA,QAAI,KAAKwB,KAAT,EAAgB;AACd,WAAK6G,aAAL;AACD;;AACDxI,cAAU,CAACmC,YAAX,CACIhC,EADJ,EACQ,MAAMA,EAAE,CAACwI,YAAH,CAAgBxI,EAAE,CAACyI,SAAnB,EAA8B,CAA9B,EAAiCzI,EAAE,CAAC0I,cAApC,EAAoD,CAApD,CADd;AAED;;AAEMC,gCAA8B;AACnC,SAAK/F,eAAL;AACA/C,cAAU,CAACmC,YAAX,CAAwB,KAAKhC,EAA7B,EAAiC,MAAM,KAAKA,EAAL,CAAQiC,MAAR,EAAvC;AACD;;AAEO2G,wBAAsB;AAE5B,QAAI,KAAKC,2BAAL,IAAoC,IAAxC,EAA8C;AAC5C,WAAKA,2BAAL,GACIhJ,UAAU,CAACW,mBAAX,CACI,KAAKR,EADT,EAEIT,GAAG,GAAGW,SAAN,CACI,8CADJ,MACwD,CADxD,GAEI,iCAFJ,GAGI,0BALR,CADJ;AASD;;AACD,WAAO,KAAK2I,2BAAZ;AACD;;AAEOC,8BAA4B;AAClC,WAAO,KAAKF,sBAAL,EAAP;AACD;;AAEOG,8BAA4B;AAClC,WAAO,KAAKH,sBAAL,EAAP;AACD;;AAEDpD,YAAU;AACR,QAAIjG,GAAG,GAAGW,SAAN,CAAgB,8CAAhB,MAAoE,CAAxE,EAA2E;AACzE,YAAM6E,GAAG,GAAG,KAAK/E,EAAjB;AACA,YAAMgJ,GAAG,GAAG,KAAKF,4BAAL,EAAZ;AAEA,YAAMjE,KAAK,GAAGE,GAAG,CAACkE,WAAJ,EAAd;AACAlE,SAAG,CAACS,UAAJ,CAAewD,GAAG,CAACE,gBAAnB,EAAqCrE,KAArC;AACA,aAAOA,KAAP;AACD;;AACD,UAAMmE,GAAG,GAAG,KAAKD,4BAAL,EAAZ;AACA,UAAMlE,KAAK,GAAGmE,GAAG,CAACG,cAAJ,EAAd;AACAH,OAAG,CAACI,aAAJ,CAAkBJ,GAAG,CAACE,gBAAtB,EAAwCrE,KAAxC;AACA,WAAOA,KAAP;AACD;;AAEDY,UAAQ;AACN,QAAIlG,GAAG,GAAGW,SAAN,CAAgB,8CAAhB,MAAoE,CAAxE,EAA2E;AACzE,YAAM6E,GAAG,GAAG,KAAK/E,EAAjB;AACA,YAAMgJ,GAAG,GAAG,KAAKF,4BAAL,EAAZ;AACA/D,SAAG,CAACU,QAAJ,CAAauD,GAAG,CAACE,gBAAjB;AACA;AACD;;AACD,UAAMF,GAAG,GAAG,KAAKD,4BAAL,EAAZ;AACAC,OAAG,CAACK,WAAJ,CAAgBL,GAAG,CAACE,gBAApB;AACD;;AAEkC,QAAtBI,sBAAsB,CAACzE,KAAD,EAAkB;AACnD,UAAMrF,IAAI,CAAC+J,WAAL,CACF,MAAM,KAAK5H,QAAL,IAAkB;AACA;AACA;AACpB,SAAK+D,gBAAL,CACIb,KADJ,EAEItF,GAAG,GAAGW,SAAN,CACI,8CADJ,CAFJ,CAJF,CAAN;AAQA,WAAO,KAAKsJ,YAAL,CACH3E,KADG,EACItF,GAAG,GAAGW,SAAN,CAAgB,8CAAhB,CADJ,CAAP;AAED;;AAEOsJ,cAAY,CAAC3E,KAAD,EAAoB4E,iBAApB,EAA6C;AAC/D,QAAIA,iBAAiB,KAAK,CAA1B,EAA6B;AAC3B,aAAO,IAAP;AACD;;AAED,QAAIA,iBAAiB,KAAK,CAA1B,EAA6B;AAC3B,YAAM1E,GAAG,GAAG,KAAK/E,EAAjB;AAEA,YAAM0J,gBAAgB,GAAG3E,GAAG,CAAC4E,iBAAJ,CAAsB9E,KAAtB,EAA6BE,GAAG,CAAC6E,YAAjC,CAAzB,CAH2B,CAI3B;;AACA,aAAOF,gBAAgB,GAAG,OAA1B;AACD,KAND,MAMO;AACL,YAAMV,GAAG,GAAG,KAAKD,4BAAL,EAAZ;AAEA,YAAMW,gBAAgB,GAClBV,GAAG,CAACa,iBAAJ,CAAsBhF,KAAtB,EAA6BmE,GAAG,CAACc,gBAAjC,CADJ,CAHK,CAKL;;AACA,aAAOJ,gBAAgB,GAAG,OAA1B;AACD;AACF;;AAEOhE,kBAAgB,CAACb,KAAD,EAAoB4E,iBAApB,EAA6C;AAEnE,QAAIA,iBAAiB,KAAK,CAA1B,EAA6B;AAC3B,aAAO,IAAP;AACD;;AAED,QAAIA,iBAAiB,KAAK,CAA1B,EAA6B;AAC3B,YAAM1E,GAAG,GAAG,KAAK/E,EAAjB;AACA,YAAMgJ,GAAG,GAAG,KAAKF,4BAAL,EAAZ;AAEA,YAAMiB,SAAS,GACXhF,GAAG,CAAC4E,iBAAJ,CAAsB9E,KAAtB,EAA6BE,GAAG,CAACiF,sBAAjC,CADJ;;AAEA,UAAI,KAAKC,QAAL,IAAiB,IAArB,EAA2B;AACzB,aAAKA,QAAL,GAAgB,KAAKjK,EAAL,CAAQkK,YAAR,CAAqBlB,GAAG,CAACmB,gBAAzB,CAAhB;AACD;;AAED,aAAOJ,SAAS,IAAI,CAAC,KAAKE,QAA1B;AACD,KAXD,MAWO;AACL,YAAMjB,GAAG,GAAG,KAAKD,4BAAL,EAAZ;AAEA,YAAMgB,SAAS,GACXf,GAAG,CAACa,iBAAJ,CAAsBhF,KAAtB,EAA6BmE,GAAG,CAACoB,0BAAjC,CADJ;;AAEA,UAAI,KAAKH,QAAL,IAAiB,IAArB,EAA2B;AACzB,aAAKA,QAAL,GAAgB,KAAKjK,EAAL,CAAQkK,YAAR,CAAqBlB,GAAG,CAACmB,gBAAzB,CAAhB;AACD;;AAED,aAAOJ,SAAS,IAAI,CAAC,KAAKE,QAA1B;AACD;AACF;;AAEDrF,WAAS,CAACF,YAAD,EAA2B;AAClC,WAAO,IAAI2F,OAAJ,CAAkBC,OAAO,IAAG;AACjC,WAAKC,aAAL,CAAmB,MAAM7F,YAAY,CAACI,aAAb,EAAzB,EAAuD,MAAMwF,OAAO,EAApE;AACD,KAFM,CAAP;AAGD;;AAIDE,WAAS;AACP;AACA,UAAMC,KAAK,GAAGC,oBAAoB,CAAC,KAAKC,WAAL,CAAiBC,GAAjB,CAAqBC,CAAC,IAAIA,CAAC,CAACC,QAA5B,CAAD,CAAlC;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIN,KAArB,EAA4B,EAAEM,CAA9B,EAAiC;AAC/B,YAAM;AAACC;AAAD,UAAc,KAAKL,WAAL,CAAiBI,CAAjB,CAApB;AACAC,eAAS;AACV;;AACD,SAAKL,WAAL,GAAmB,KAAKA,WAAL,CAAiBM,KAAjB,CAAuBR,KAAK,GAAG,CAA/B,CAAnB;AACD;;AAEOF,eAAa,CAACO,QAAD,EAA0BE,SAA1B,EAA+C;AAClE,SAAKL,WAAL,CAAiBO,IAAjB,CAAsB;AAACJ,cAAD;AAAWE;AAAX,KAAtB;;AACA,QAAI,KAAKL,WAAL,CAAiBQ,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B;AACA;AACD,KALiE,CAMlE;;;AACA3L,QAAI,CAAC+J,WAAL,CAAiB,MAAK;AACpB,WAAKiB,SAAL,GADoB,CAEpB;;AACA,aAAO,KAAKG,WAAL,CAAiBQ,MAAjB,KAA4B,CAAnC;AACD,KAJD;AAKD;;AAEO9G,0BAAwB,CAACrB,OAAD,EAAsB;AACpD,SAAKJ,eAAL;AACA/C,cAAU,CAACuL,6BAAX,CACI,KAAKpL,EADT,EACagD,OADb,EACsB,KAAK5B,WAD3B;;AAEA,QAAI,KAAKI,KAAT,EAAgB;AACd3B,gBAAU,CAACyI,mBAAX,CAA+B,KAAKtI,EAApC;AACD;AACF;;AAEOwE,4BAA0B;AAChC,QAAI,KAAKzC,aAAL,IAAsB,IAA1B,EAAgC;AAC9BlC,gBAAU,CAACuL,6BAAX,CACI,KAAKpL,EADT,EACa,KAAK+B,aADlB,EACiC,KAAKX,WADtC;;AAEA,UAAI,KAAKI,KAAT,EAAgB;AACd3B,kBAAU,CAACyI,mBAAX,CAA+B,KAAKtI,EAApC;AACD;AACF,KAND,MAMO;AACLH,gBAAU,CAAC4D,iCAAX,CAA6C,KAAKzD,EAAlD,EAAsD,KAAKoB,WAA3D;AACD;AACF;;AAEOwC,sBAAoB,CACxBZ,OADwB,EAExBqI,iBAFwB,EAEa;AACvC,SAAKhH,wBAAL,CAA8BrB,OAA9B;AACA,UAAMsB,MAAM,GAAG+G,iBAAiB,EAAhC;AACA,SAAK7G,0BAAL;AAEA,WAAOF,MAAP;AACD;;AAEOoD,8BAA4B,CAChC4D,8BADgC,EACcnI,KADd,EAEhCC,MAFgC,EAElB;AAChB,SAAKR,eAAL;AACA,UAAM5C,EAAE,GAAG,KAAKA,EAAhB;AACAH,cAAU,CAACuL,6BAAX,CACIpL,EADJ,EACQsL,8BADR,EACwC,KAAKlK,WAD7C;;AAEA,QAAI,KAAKI,KAAT,EAAgB;AACd3B,gBAAU,CAACyI,mBAAX,CAA+BtI,EAA/B;AACD;;AACD,SAAK+B,aAAL,GAAqBuJ,8BAArB;AACAzL,cAAU,CAACmC,YAAX,CAAwBhC,EAAxB,EAA4B,MAAMA,EAAE,CAACuL,QAAH,CAAY,CAAZ,EAAe,CAAf,EAAkBpI,KAAlB,EAAyBC,MAAzB,CAAlC;AACAvD,cAAU,CAACmC,YAAX,CAAwBhC,EAAxB,EAA4B,MAAMA,EAAE,CAACwL,OAAH,CAAW,CAAX,EAAc,CAAd,EAAiBrI,KAAjB,EAAwBC,MAAxB,CAAlC;AACD;;AAEO+E,kCAAgC,CACpC0C,CADoC,EACzBY,CADyB,EACdtI,KADc,EACCC,MADD,EACe;AACrD,SAAKR,eAAL;AACA/C,cAAU,CAACmC,YAAX,CACI,KAAKhC,EADT,EACa,MAAM,KAAKA,EAAL,CAAQwL,OAAR,CAAgBX,CAAhB,EAAmBY,CAAnB,EAAsBtI,KAAtB,EAA6BC,MAA7B,CADnB;AAED;;AAEOR,iBAAe;AACrB,QAAI,KAAKjB,QAAT,EAAmB;AACjB,YAAM,IAAIf,KAAJ,CAAU,yCAAV,CAAN;AACD;AACF;;AAEO0G,kBAAgB;AACtB,QAAI,KAAK1F,OAAL,IAAgB,IAApB,EAA0B;AACxB,YAAM,IAAIhB,KAAJ,CAAU,kCAAV,CAAN;AACD;AACF;;AAjkBsB;AAykBzB;;;;;;;AAMA,OAAM,SAAU8J,oBAAV,CAA+BgB,GAA/B,EAAwD;AAC5D,MAAIX,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGW,GAAG,CAACP,MAAf,EAAuB,EAAEJ,CAAzB,EAA4B;AAC1B,UAAMY,MAAM,GAAGD,GAAG,CAACX,CAAD,CAAH,EAAf;;AACA,QAAI,CAACY,MAAL,EAAa;AACX;AACD;AACF;;AACD,SAAOZ,CAAC,GAAG,CAAX;AACD","names":["env","util","getWebGLContext","setWebGLContext","gpgpu_util","tex_util","webgl_util","GPGPUContext","constructor","gl","glVersion","getNumber","COLOR_BUFFER_FLOAT","COLOR_BUFFER_HALF_FLOAT","TEXTURE_FLOAT","TEXTURE_HALF_FLOAT","textureFloatExtension","getExtensionOrThrow","hasExtension","textureHalfFloatExtension","get","Error","colorBufferFloatExtension","getExtension","colorBufferHalfFloatExtension","vertexBuffer","createVertexBuffer","indexBuffer","createIndexBuffer","framebuffer","createFramebuffer","textureConfig","getTextureConfig","debug","getBool","dispose","disposed","program","console","warn","outputTexture","callAndCheck","finish","bindFramebuffer","FRAMEBUFFER","deleteFramebuffer","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","deleteBuffer","createFloat32MatrixTexture","rows","columns","throwIfDisposed","createFloat16MatrixTexture","createUnsignedBytesMatrixTexture","uploadPixelDataToTexture","texture","pixels","uploadDenseMatrixToTexture","width","height","data","createFloat16PackedMatrixTexture","createPackedMatrixTexture","deleteMatrixTexture","unbindColorTextureFromFramebuffer","deleteTexture","downloadByteEncodedFloatMatrixFromOutputTexture","downloadMatrixDriver","downloadPackedMatrixFromBuffer","buffer","batch","physicalRows","physicalCols","downloadFloat32MatrixFromBuffer","size","createBufferFromTexture","bindTextureToFrameBuffer","result","createBufferFromOutputTexture","unbindTextureToFrameBuffer","createAndWaitForFence","fenceContext","createFence","pollFence","query","isFencePassed","gl2","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","status","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","beginQuery","endQuery","isQueryAvailable","downloadMatrixFromPackedTexture","downloadMatrixFromPackedOutputTexture","createProgram","fragmentShader","vertexShader","createVertexShader","attachShader","linkProgram","validateProgram","vertexAttrsAreBound","setProgram","bindVertexProgramAttributeStreams","deleteProgram","useProgram","getUniformLocation","uniformName","shouldThrow","getProgramUniformLocationOrThrow","getProgramUniformLocation","getAttributeLocation","attribute","getAttribLocation","getUniformLocationNoThrow","setInputMatrixTexture","inputMatrixTexture","uniformLocation","textureUnit","throwIfNoProgram","bindTextureToProgramUniformSampler","setOutputMatrixTexture","outputMatrixTexture","setOutputMatrixTextureDriver","setOutputPackedMatrixTexture","outputPackedMatrixTexture","getPackedMatrixTextureShapeWidthHeight","setOutputMatrixWriteRegion","startRow","numRows","startColumn","numColumns","setOutputMatrixWriteRegionDriver","setOutputPackedMatrixWriteRegion","debugValidate","validateFramebuffer","executeProgram","drawElements","TRIANGLES","UNSIGNED_SHORT","blockUntilAllProgramsCompleted","getQueryTimerExtension","disjointQueryTimerExtension","getQueryTimerExtensionWebGL2","getQueryTimerExtensionWebGL1","ext","createQuery","TIME_ELAPSED_EXT","createQueryEXT","beginQueryEXT","endQueryEXT","waitForQueryAndGetTime","repeatedTry","getQueryTime","queryTimerVersion","timeElapsedNanos","getQueryParameter","QUERY_RESULT","getQueryObjectEXT","QUERY_RESULT_EXT","available","QUERY_RESULT_AVAILABLE","disjoint","getParameter","GPU_DISJOINT_EXT","QUERY_RESULT_AVAILABLE_EXT","Promise","resolve","addItemToPoll","pollItems","index","linearSearchLastTrue","itemsToPoll","map","x","isDoneFn","i","resolveFn","slice","push","length","bindColorTextureToFramebuffer","downloadAndDecode","outputMatrixTextureMaybePacked","viewport","scissor","y","arr","isDone"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-webgl/src/gpgpu_context.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, PixelData, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext, setWebGLContext} from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport {Texture, TextureConfig} from './tex_util';\nimport {WebGL1DisjointQueryTimerExtension, WebGL2DisjointQueryTimerExtension} from './webgl_types';\nimport * as webgl_util from './webgl_util';\n\nexport interface FenceContext {\n  query: WebGLQuery|WebGLSync;\n  isFencePassed(): boolean;\n}\n\nexport class GPGPUContext {\n  gl: WebGLRenderingContext;\n  textureFloatExtension: {};\n  textureHalfFloatExtension: {};\n  colorBufferFloatExtension: {};\n  colorBufferHalfFloatExtension: {};\n  disjointQueryTimerExtension: WebGL2DisjointQueryTimerExtension|\n      WebGL1DisjointQueryTimerExtension;\n  vertexBuffer: WebGLBuffer;\n  indexBuffer: WebGLBuffer;\n  framebuffer: WebGLFramebuffer;\n  outputTexture: WebGLTexture|null = null;\n  program: WebGLProgram|null = null;\n  private disposed = false;\n  private disjoint: boolean;\n  private vertexShader: WebGLShader;\n  textureConfig: TextureConfig;\n\n  constructor(gl?: WebGLRenderingContext) {\n    const glVersion = env().getNumber('WEBGL_VERSION');\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    }\n    // WebGL 2.0 enables texture floats without an extension.\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n\n      this.textureFloatExtension =\n          webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support half float textures, yet the ' +\n            'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support color renderable half floats, yet ' +\n            'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n\n    this.textureConfig =\n        tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  private get debug(): boolean {\n    return env().getBool('DEBUG');\n  }\n\n  public dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.program != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n          ' This is probably a resource leak, delete the program with ' +\n          'GPGPUContext.deleteProgram before disposing.');\n    }\n    if (this.outputTexture != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound output matrix ' +\n          'texture.  This is probably a resource leak, delete the output ' +\n          'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n          'disposing.');\n    }\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, () => gl.finish());\n    webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(\n        gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n\n  public createFloat32MatrixTexture(rows: number, columns: number): Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createFloat16MatrixTexture(rows: number, columns: number): Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createUnsignedBytesMatrixTexture(rows: number, columns: number):\n      Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public uploadPixelDataToTexture(\n      texture: WebGLTexture,\n      pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n      ImageBitmap) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n  }\n\n  public uploadDenseMatrixToTexture(\n      texture: WebGLTexture, width: number, height: number, data: TypedArray) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(\n        this.gl, texture, width, height, data, this.textureConfig);\n  }\n\n  public createFloat16PackedMatrixTexture(rows: number, columns: number):\n      Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createPackedMatrixTexture(rows: number, columns: number): Texture {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public deleteMatrixTexture(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      this.outputTexture = null;\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n  }\n\n  public downloadByteEncodedFloatMatrixFromOutputTexture(\n      texture: WebGLTexture, rows: number, columns: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(\n            this.gl, rows, columns, this.textureConfig));\n  }\n\n  public downloadPackedMatrixFromBuffer(\n      buffer: WebGLBuffer, batch: number, rows: number, columns: number,\n      physicalRows: number, physicalCols: number): Float32Array {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(\n        this.gl, buffer, batch, rows, columns, physicalRows, physicalCols,\n        this.textureConfig);\n  }\n\n  public downloadFloat32MatrixFromBuffer(buffer: WebGLBuffer, size: number):\n      Float32Array {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n\n  public createBufferFromTexture(\n      texture: WebGLTexture, rows: number, columns: number): WebGLBuffer {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(\n        this.gl as WebGL2RenderingContext, rows, columns, this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  public createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let query: WebGLQuery|WebGLSync;\n    let isFencePassed: () => boolean;\n\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl as WebGL2RenderingContext;\n\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED ||\n            status === gl2.CONDITION_SATISFIED;\n      };\n\n      query = sync;\n    } else if (\n        env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n      isFencePassed = () => this.isQueryAvailable(\n          query,\n          env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n\n    return {query, isFencePassed};\n  }\n\n  public downloadMatrixFromPackedTexture(\n      texture: WebGLTexture, physicalRows: number,\n      physicalCols: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadMatrixFromPackedOutputTexture(\n            this.gl, physicalRows, physicalCols));\n  }\n\n  private vertexAttrsAreBound = false;\n\n  public createProgram(fragmentShader: WebGLShader): WebGLProgram {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    if (this.vertexShader == null) {\n      this.vertexShader = gpgpu_util.createVertexShader(gl);\n    }\n    const program: WebGLProgram = webgl_util.createProgram(gl);\n    webgl_util.callAndCheck(\n        gl, () => gl.attachShader(program, this.vertexShader));\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, program);\n    if (this.debug) {\n      webgl_util.validateProgram(gl, program);\n    }\n    if (!this.vertexAttrsAreBound) {\n      this.setProgram(program);\n      this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(\n          gl, this.program, this.vertexBuffer);\n    }\n    return program;\n  }\n\n  public deleteProgram(program: WebGLProgram) {\n    this.throwIfDisposed();\n    if (program === this.program) {\n      this.program = null;\n    }\n    if (program != null) {\n      webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n    }\n  }\n\n  public setProgram(program: WebGLProgram|null) {\n    this.throwIfDisposed();\n    this.program = program;\n    if ((this.program != null) && this.debug) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n  }\n\n  public getUniformLocation(\n      program: WebGLProgram, uniformName: string,\n      shouldThrow = true): WebGLUniformLocation {\n    this.throwIfDisposed();\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(\n          this.gl, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(\n          this.gl, program, uniformName);\n    }\n  }\n\n  public getAttributeLocation(program: WebGLProgram, attribute: string):\n      number {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(\n        this.gl, () => this.gl.getAttribLocation(program, attribute));\n  }\n\n  public getUniformLocationNoThrow(program: WebGLProgram, uniformName: string):\n      WebGLUniformLocation {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n\n  public setInputMatrixTexture(\n      inputMatrixTexture: WebGLTexture, uniformLocation: WebGLUniformLocation,\n      textureUnit: number) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(\n        this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n  }\n\n  public setOutputMatrixTexture(\n      outputMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n\n  public setOutputPackedMatrixTexture(\n      outputPackedMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.throwIfDisposed();\n    const [width, height] =\n        tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n\n  public setOutputMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    this.setOutputMatrixWriteRegionDriver(\n        startColumn, startRow, numColumns, numRows);\n  }\n\n  public setOutputPackedMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n\n  public debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.validateFramebuffer(this.gl);\n  }\n\n  public executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n    if (this.debug) {\n      this.debugValidate();\n    }\n    webgl_util.callAndCheck(\n        gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n\n  public blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n  }\n\n  private getQueryTimerExtension(): WebGL1DisjointQueryTimerExtension\n      |WebGL2DisjointQueryTimerExtension {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension =\n          webgl_util.getExtensionOrThrow(\n              this.gl,\n              env().getNumber(\n                  'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                  'EXT_disjoint_timer_query_webgl2' :\n                  'EXT_disjoint_timer_query') as\n              WebGL1DisjointQueryTimerExtension |\n          WebGL2DisjointQueryTimerExtension;\n    }\n    return this.disjointQueryTimerExtension;\n  }\n\n  private getQueryTimerExtensionWebGL2(): WebGL2DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension();\n  }\n\n  private getQueryTimerExtensionWebGL1(): WebGL1DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension() as WebGL1DisjointQueryTimerExtension;\n  }\n\n  beginQuery(): WebGLQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT() as WebGLQuery;\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n\n  public async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await util.repeatedTry(\n        () => this.disposed ||  // while testing contexts are created / disposed\n                                // in rapid succession, so without this check we\n                                // may poll for the query timer indefinitely\n            this.isQueryAvailable(\n                query,\n                env().getNumber(\n                    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n    return this.getQueryTime(\n        query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n  }\n\n  private getQueryTime(query: WebGLQuery, queryTimerVersion: number): number {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const timeElapsedNanos =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    }\n  }\n\n  private isQueryAvailable(query: WebGLQuery, queryTimerVersion: number):\n      boolean {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const available =\n          gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const available =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    }\n  }\n\n  pollFence(fenceContext: FenceContext) {\n    return new Promise<void>(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const {resolveFn} = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({isDoneFn, resolveFn});\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    util.repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    });\n  }\n\n  private bindTextureToFrameBuffer(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(\n        this.gl, texture, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n\n  private unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(\n          this.gl, this.outputTexture, this.framebuffer);\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n    }\n  }\n\n  private downloadMatrixDriver(\n      texture: WebGLTexture,\n      downloadAndDecode: () => Float32Array): Float32Array {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n\n    return result;\n  }\n\n  private setOutputMatrixTextureDriver(\n      outputMatrixTextureMaybePacked: WebGLTexture, width: number,\n      height: number) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(\n        gl, outputMatrixTextureMaybePacked, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n  }\n\n  private setOutputMatrixWriteRegionDriver(\n      x: number, y: number, width: number, height: number) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(\n        this.gl, () => this.gl.scissor(x, y, width, height));\n  }\n\n  private throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n\n  private throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean,\n  resolveFn: () => void\n};\n\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n"]},"metadata":{},"sourceType":"module"}