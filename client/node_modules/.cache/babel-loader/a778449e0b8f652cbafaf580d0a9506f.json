{"ast":null,"code":"import { computeStrides, sizeFromShape } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\n\nexport function prepareAndValidate(tensor, indices) {\n  const tensorRank = tensor.shape.length;\n  const indicesRank = indices.shape.length;\n\n  if (tensorRank < 1) {\n    throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' + ` but the rank was ${tensorRank}.`);\n  }\n\n  if (indicesRank < 1) {\n    throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' + ` but the rank was ${indicesRank}.`);\n  }\n\n  if (indices.dtype !== 'int32') {\n    throw new Error('tf.gatherND() expects the indices to be int32 type,' + ` but the dtype was ${indices.dtype}.`);\n  }\n\n  if (indices.shape[indicesRank - 1] > tensorRank) {\n    throw new Error('index innermost dimension length must be <= tensor rank; saw: ' + `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n  }\n\n  if (sizeFromShape(tensor.shape) === 0) {\n    throw new Error('Requested more than 0 entries, but input is empty.' + ` Input shape: ${tensor.shape}.`);\n  }\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1]; // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n\n  let nResult = 1;\n\n  for (let i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  const inputShape = tensor.shape;\n  const resultShape = indicesShape.slice();\n  resultShape.pop();\n  let sliceSize = 1;\n\n  for (let i = sliceRank; i < tensorRank; ++i) {\n    sliceSize *= inputShape[i];\n    resultShape.push(inputShape[i]);\n  }\n\n  const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize), 1].slice(0, sliceRank);\n  return [resultShape, nResult, sliceSize, strides];\n}","map":{"version":3,"mappings":"AAiBA,SAAQA,cAAR,EAAwBC,aAAxB,QAA4C,SAA5C;AAEA;;;;;;;;;AAQA,OAAM,SAAUC,kBAAV,CAA6BC,MAA7B,EAAiDC,OAAjD,EAAoE;AAExE,QAAMC,UAAU,GAAGF,MAAM,CAACG,KAAP,CAAaC,MAAhC;AACA,QAAMC,WAAW,GAAGJ,OAAO,CAACE,KAAR,CAAcC,MAAlC;;AACA,MAAIF,UAAU,GAAG,CAAjB,EAAoB;AAClB,UAAM,IAAII,KAAJ,CACF,4DACA,qBAAqBJ,UAAU,GAF7B,CAAN;AAGD;;AACD,MAAIG,WAAW,GAAG,CAAlB,EAAqB;AACnB,UAAM,IAAIC,KAAJ,CACF,8DACA,qBAAqBD,WAAW,GAF9B,CAAN;AAGD;;AACD,MAAIJ,OAAO,CAACM,KAAR,KAAkB,OAAtB,EAA+B;AAC7B,UAAM,IAAID,KAAJ,CACF,wDACA,sBAAsBL,OAAO,CAACM,KAAK,GAFjC,CAAN;AAGD;;AACD,MAAIN,OAAO,CAACE,KAAR,CAAcE,WAAW,GAAG,CAA5B,IAAiCH,UAArC,EAAiD;AAC/C,UAAM,IAAII,KAAJ,CACF,mEACA,GAAGL,OAAO,CAACE,KAAR,CAAcE,WAAW,GAAG,CAA5B,CAA8B,QAAQH,UAAU,EAFjD,CAAN;AAGD;;AAED,MAAIJ,aAAa,CAACE,MAAM,CAACG,KAAR,CAAb,KAAgC,CAApC,EAAuC;AACrC,UAAM,IAAIG,KAAJ,CACF,uDACA,iBAAiBN,MAAM,CAACG,KAAK,GAF3B,CAAN;AAGD;;AAED,QAAMK,YAAY,GAAGP,OAAO,CAACE,KAA7B;AACA,QAAMM,SAAS,GAAGD,YAAY,CAACA,YAAY,CAACJ,MAAb,GAAsB,CAAvB,CAA9B,CAhCwE,CAkCxE;AACA;;AACA,MAAIM,OAAO,GAAG,CAAd;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,YAAY,CAACJ,MAAb,GAAsB,CAA1C,EAA6C,EAAEO,CAA/C,EAAkD;AAChDD,WAAO,IAAIF,YAAY,CAACG,CAAD,CAAvB;AACD;;AAED,QAAMC,UAAU,GAAGZ,MAAM,CAACG,KAA1B;AAEA,QAAMU,WAAW,GAAGL,YAAY,CAACM,KAAb,EAApB;AACAD,aAAW,CAACE,GAAZ;AAEA,MAAIC,SAAS,GAAG,CAAhB;;AACA,OAAK,IAAIL,CAAC,GAAGF,SAAb,EAAwBE,CAAC,GAAGT,UAA5B,EAAwC,EAAES,CAA1C,EAA6C;AAC3CK,aAAS,IAAIJ,UAAU,CAACD,CAAD,CAAvB;AACAE,eAAW,CAACI,IAAZ,CAAiBL,UAAU,CAACD,CAAD,CAA3B;AACD;;AAED,QAAMO,OAAO,GACT,CAAC,GAAGrB,cAAc,CAACG,MAAM,CAACG,KAAR,CAAd,CAA6BgB,GAA7B,CAAiCC,MAAM,IAAIA,MAAM,GAAGJ,SAApD,CAAJ,EACC,CADD,EACIF,KADJ,CACU,CADV,EACaL,SADb,CADJ;AAIA,SAAO,CAACI,WAAD,EAAcH,OAAd,EAAuBM,SAAvB,EAAkCE,OAAlC,CAAP;AACD","names":["computeStrides","sizeFromShape","prepareAndValidate","tensor","indices","tensorRank","shape","length","indicesRank","Error","dtype","indicesShape","sliceRank","nResult","i","inputShape","resultShape","slice","pop","sliceSize","push","strides","map","stride"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/ops/gather_nd_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {TensorInfo} from '../kernel_registry';\nimport {computeStrides, sizeFromShape} from '../util';\n\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor: TensorInfo, indices: TensorInfo):\n    [number[], number, number, number[]] {\n  const tensorRank = tensor.shape.length;\n  const indicesRank = indices.shape.length;\n  if (tensorRank < 1) {\n    throw new Error(\n        'tf.gatherND() expects the input to be rank 1 or higher,' +\n        ` but the rank was ${tensorRank}.`);\n  }\n  if (indicesRank < 1) {\n    throw new Error(\n        'tf.gatherND() expects the indices to be rank 1 or higher,' +\n        ` but the rank was ${indicesRank}.`);\n  }\n  if (indices.dtype !== 'int32') {\n    throw new Error(\n        'tf.gatherND() expects the indices to be int32 type,' +\n        ` but the dtype was ${indices.dtype}.`);\n  }\n  if (indices.shape[indicesRank - 1] > tensorRank) {\n    throw new Error(\n        'index innermost dimension length must be <= tensor rank; saw: ' +\n        `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n  }\n\n  if (sizeFromShape(tensor.shape) === 0) {\n    throw new Error(\n        'Requested more than 0 entries, but input is empty.' +\n        ` Input shape: ${tensor.shape}.`);\n  }\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1];\n\n  // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n  let nResult = 1;\n  for (let i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  const inputShape = tensor.shape;\n\n  const resultShape = indicesShape.slice();\n  resultShape.pop();\n\n  let sliceSize = 1;\n  for (let i = sliceRank; i < tensorRank; ++i) {\n    sliceSize *= inputShape[i];\n    resultShape.push(inputShape[i]);\n  }\n\n  const strides =\n      [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n       1].slice(0, sliceRank);\n\n  return [resultShape, nResult, sliceSize, strides];\n}\n"]},"metadata":{},"sourceType":"module"}