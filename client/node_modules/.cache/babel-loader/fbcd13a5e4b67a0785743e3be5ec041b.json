{"ast":null,"code":"import { getCoordsDataType } from './shader_compiler';\nexport class CumSumProgram {\n  constructor(shape, exclusive, reverse) {\n    this.variableNames = ['x'];\n    this.customUniforms = [{\n      name: 'index',\n      type: 'float'\n    }];\n    this.outputShape = shape;\n    const rank = shape.length;\n    const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n    const length = shape[shape.length - 1];\n    let condition = '';\n    let idxString = ''; // When exclusive is set, the cumsum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n\n    if (exclusive) {\n      condition = reverse ? `end != ${length - 1}` : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n      idxString = reverse ? 'end + pow2' : 'end - pow2';\n    }\n\n    this.userCode = `\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n  }\n\n}\n\nfunction getCoords(rank, name) {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.x, ${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.x, ${name}.y, ${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n\nfunction getFinalCoord(rank, name) {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}","map":{"version":3,"mappings":"AAiBA,SAAQA,iBAAR,QAA6C,mBAA7C;AAEA,OAAM,MAAOC,aAAP,CAAoB;AAMxBC,cAAYC,KAAZ,EAA6BC,SAA7B,EAAiDC,OAAjD,EAAiE;AALjE,yBAAgB,CAAC,GAAD,CAAhB;AAGA,0BAAiB,CAAC;AAACC,UAAI,EAAE,OAAP;AAAgBC,UAAI,EAAE;AAAtB,KAAD,CAAjB;AAGE,SAAKC,WAAL,GAAmBL,KAAnB;AACA,UAAMM,IAAI,GAAGN,KAAK,CAACO,MAAnB;AACA,UAAMC,GAAG,GAAGP,SAAS,GAAG,KAAH,GAAW,QAAQQ,SAAS,CAACH,IAAD,EAAO,QAAP,CAAgB,GAAjE;AACA,UAAMC,MAAM,GAAGP,KAAK,CAACA,KAAK,CAACO,MAAN,GAAe,CAAhB,CAApB;AACA,QAAIG,SAAS,GAAG,EAAhB;AACA,QAAIC,SAAS,GAAG,EAAhB,CAN+D,CAO/D;AACA;AACA;;AACA,QAAIV,SAAJ,EAAe;AACbS,eAAS,GAAGR,OAAO,GAAG,UAAUK,MAAM,GAAG,CAAC,EAAvB,GAA4B,UAA/C;AACAI,eAAS,GAAGT,OAAO,GAAG,SAAH,GAAe,SAAlC;AACD,KAHD,MAGO;AACLQ,eAAS,GAAGR,OAAO,GAAG,gBAAgBK,MAAM,EAAzB,GAA8B,aAAjD;AACAI,eAAS,GAAIT,OAAO,GAAG,YAAH,GAAkB,YAAtC;AACD;;AAED,SAAKU,QAAL,GAAgB;;UAEVf,iBAAiB,CAACS,IAAD,CAAM;oBACbO,aAAa,CAACP,IAAD,EAAO,QAAP,CAAgB;sBAC3BE,GAAG;;cAEXE,SAAS;sBACDC,SAAS;YACnBE,aAAa,CAACP,IAAD,EAAO,QAAP,CAAgB;wBACjBG,SAAS,CAACH,IAAD,EAAO,QAAP,CAAgB;;;;KAT7C;AAcD;;AAtCuB;;AAyC1B,SAASG,SAAT,CAAmBH,IAAnB,EAAiCH,IAAjC,EAA6C;AAC3C,MAAIG,IAAI,KAAK,CAAb,EAAgB;AACd,WAAO,GAAGH,IAAI,EAAd;AACD,GAFD,MAEO,IAAIG,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAGH,IAAI,OAAOA,IAAI,IAAzB;AACD,GAFM,MAEA,IAAIG,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAGH,IAAI,OAAOA,IAAI,OAAOA,IAAI,IAApC;AACD,GAFM,MAEA,IAAIG,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAGH,IAAI,OAAOA,IAAI,OAAOA,IAAI,OAAOA,IAAI,IAA/C;AACD,GAFM,MAEA;AACL,UAAMW,KAAK,CAAC,2BAA2BR,IAAI,uBAAhC,CAAX;AACD;AACF;;AAED,SAASO,aAAT,CAAuBP,IAAvB,EAAqCH,IAArC,EAAiD;AAC/C,MAAIG,IAAI,KAAK,CAAb,EAAgB;AACd,WAAO,GAAGH,IAAI,EAAd;AACD,GAFD,MAEO,IAAIG,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAGH,IAAI,IAAd;AACD,GAFM,MAEA,IAAIG,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAGH,IAAI,IAAd;AACD,GAFM,MAEA,IAAIG,IAAI,KAAK,CAAb,EAAgB;AACrB,WAAO,GAAGH,IAAI,IAAd;AACD,GAFM,MAEA;AACL,UAAMW,KAAK,CAAC,2BAA2BR,IAAI,uBAAhC,CAAX;AACD;AACF","names":["getCoordsDataType","CumSumProgram","constructor","shape","exclusive","reverse","name","type","outputShape","rank","length","val","getCoords","condition","idxString","userCode","getFinalCoord","Error"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-webgl/src/cumsum_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType, UniformType} from './shader_compiler';\n\nexport class CumSumProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n  customUniforms = [{name: 'index', type: 'float' as UniformType}];\n\n  constructor(shape: number[], exclusive: boolean, reverse: boolean) {\n    this.outputShape = shape;\n    const rank = shape.length;\n    const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n    const length = shape[shape.length - 1];\n    let condition = '';\n    let idxString = '';\n    // When exclusive is set, the cumsum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n    if (exclusive) {\n      condition = reverse ? `end != ${length - 1}` : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n      idxString = (reverse ? 'end + pow2' : 'end - pow2');\n    }\n\n    this.userCode = `\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n  }\n}\n\nfunction getCoords(rank: number, name: string): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.x, ${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.x, ${name}.y, ${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n\nfunction getFinalCoord(rank: number, name: string): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}