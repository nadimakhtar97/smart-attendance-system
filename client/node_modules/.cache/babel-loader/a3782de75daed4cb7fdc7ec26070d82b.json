{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function scatterImpl(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {\n  const flattenShape = [outputSize / sliceSize, sliceSize];\n  const indicesData = indices.values;\n  const updatesData = updates.values;\n\n  if (outputSize === 0) {\n    return buffer(shape, updates.dtype);\n  }\n\n  const outBuf = buffer(flattenShape, updates.dtype);\n  outBuf.values.fill(defaultValue);\n\n  for (let i = 0; i < numUpdates; i++) {\n    const index = [];\n    let flattenIndex = 0;\n\n    for (let j = 0; j < sliceRank; j++) {\n      const dim = indicesData[i * sliceRank + j];\n      index.push(dim);\n      flattenIndex += dim * strides[j];\n    }\n\n    if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {\n      throw new Error(`Invalid indices: ${index} does not index into ${shape}`);\n    }\n\n    for (let k = 0; k < sliceSize; k++) {\n      if (sumDupeIndices) {\n        outBuf.values[flattenIndex * sliceSize + k] += updatesData[i * sliceSize + k];\n      } else {\n        outBuf.values[flattenIndex * sliceSize + k] = updates.rank === 0 ? updatesData[0] : updatesData[i * sliceSize + k];\n      }\n    }\n  }\n\n  return outBuf;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA,SAAQA,MAAR,QAA+D,uBAA/D;AAEA,OAAM,SAAUC,WAAV,CACFC,OADE,EACwBC,OADxB,EACkDC,KADlD,EAEFC,UAFE,EAEkBC,SAFlB,EAEqCC,UAFrC,EAGFC,SAHE,EAGiBC,OAHjB,EAGoCC,YAHpC,EAIFC,cAJE,EAIqB;AACzB,QAAMC,YAAY,GAAG,CAACP,UAAU,GAAGC,SAAd,EAAyBA,SAAzB,CAArB;AAEA,QAAMO,WAAW,GAAGX,OAAO,CAACY,MAA5B;AACA,QAAMC,WAAW,GAAGZ,OAAO,CAACW,MAA5B;;AAEA,MAAIT,UAAU,KAAK,CAAnB,EAAsB;AACpB,WAAOL,MAAM,CAACI,KAAD,EAAuBD,OAAO,CAACa,KAA/B,CAAb;AACD;;AAED,QAAMC,MAAM,GAAGjB,MAAM,CAACY,YAAD,EAAeT,OAAO,CAACa,KAAvB,CAArB;AACCC,QAAM,CAACH,MAAP,CAA6BI,IAA7B,CAAkCR,YAAlC;;AAED,OAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,UAApB,EAAgCY,CAAC,EAAjC,EAAqC;AACnC,UAAMC,KAAK,GAAG,EAAd;AACA,QAAIC,YAAY,GAAG,CAAnB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,SAApB,EAA+Bc,CAAC,EAAhC,EAAoC;AAClC,YAAMC,GAAG,GAAGV,WAAW,CAACM,CAAC,GAAGX,SAAJ,GAAgBc,CAAjB,CAAvB;AACAF,WAAK,CAACI,IAAN,CAAWD,GAAX;AACAF,kBAAY,IAAIE,GAAG,GAAGd,OAAO,CAACa,CAAD,CAA7B;AACD;;AAED,QAAID,YAAY,GAAG,CAAf,IAAoBA,YAAY,IAAIhB,UAAU,GAAGC,SAArD,EAAgE;AAC9D,YAAM,IAAImB,KAAJ,CAAU,oBAAoBL,KAAK,wBAAwBhB,KAAK,EAAhE,CAAN;AACD;;AAED,SAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpB,SAApB,EAA+BoB,CAAC,EAAhC,EAAoC;AAClC,UAAIf,cAAJ,EAAoB;AAClBM,cAAM,CAACH,MAAP,CAAcO,YAAY,GAAGf,SAAf,GAA2BoB,CAAzC,KACIX,WAAW,CAACI,CAAC,GAAGb,SAAJ,GAAgBoB,CAAjB,CADf;AAED,OAHD,MAGO;AACLT,cAAM,CAACH,MAAP,CAAcO,YAAY,GAAGf,SAAf,GAA2BoB,CAAzC,IAA8CvB,OAAO,CAACwB,IAAR,KAAiB,CAAjB,GAC1CZ,WAAW,CAAC,CAAD,CAD+B,GAE1CA,WAAW,CAACI,CAAC,GAAGb,SAAJ,GAAgBoB,CAAjB,CAFf;AAGD;AACF;AACF;;AAED,SAAOT,MAAP;AACD","names":["buffer","scatterImpl","indices","updates","shape","outputSize","sliceSize","numUpdates","sliceRank","strides","defaultValue","sumDupeIndices","flattenShape","indicesData","values","updatesData","dtype","outBuf","fill","i","index","flattenIndex","j","dim","push","Error","k","rank"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/Scatter_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {buffer, Rank, ShapeMap, TensorBuffer, TypedArray} from '@tensorflow/tfjs-core';\n\nexport function scatterImpl<R extends Rank>(\n    indices: TensorBuffer<R>, updates: TensorBuffer<R>, shape: number[],\n    outputSize: number, sliceSize: number, numUpdates: number,\n    sliceRank: number, strides: number[], defaultValue: number,\n    sumDupeIndices: boolean): TensorBuffer<R> {\n  const flattenShape = [outputSize / sliceSize, sliceSize];\n\n  const indicesData = indices.values as TypedArray;\n  const updatesData = updates.values as TypedArray;\n\n  if (outputSize === 0) {\n    return buffer(shape as ShapeMap[R], updates.dtype);\n  }\n\n  const outBuf = buffer(flattenShape, updates.dtype);\n  (outBuf.values as TypedArray).fill(defaultValue);\n\n  for (let i = 0; i < numUpdates; i++) {\n    const index = [];\n    let flattenIndex = 0;\n    for (let j = 0; j < sliceRank; j++) {\n      const dim = indicesData[i * sliceRank + j];\n      index.push(dim);\n      flattenIndex += dim * strides[j];\n    }\n\n    if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {\n      throw new Error(`Invalid indices: ${index} does not index into ${shape}`);\n    }\n\n    for (let k = 0; k < sliceSize; k++) {\n      if (sumDupeIndices) {\n        outBuf.values[flattenIndex * sliceSize + k] +=\n            updatesData[i * sliceSize + k];\n      } else {\n        outBuf.values[flattenIndex * sliceSize + k] = updates.rank === 0 ?\n            updatesData[0] :\n            updatesData[i * sliceSize + k];\n      }\n    }\n  }\n\n  return outBuf as TensorBuffer<R>;\n}\n"]},"metadata":{},"sourceType":"module"}