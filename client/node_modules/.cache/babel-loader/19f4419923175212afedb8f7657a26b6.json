{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds) {\n  let isMean = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let defaultValue = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  const numIndices = indices.length; // Flatten the array to two dimensions\n\n  const inputFlat = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1]; // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n\n  const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n  const outputLength = outputShape.reduce((product, value) => product * value, 1); // Output array is initialized with the value 0 by default.\n\n  const output = util.getArrayFromDType(inputDType, outputLength); // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  let start = 0,\n      end = 1; // Index from which the output is not initialized.\n\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      } // We have a new segment here.  Verify that the segment ids are growing.\n\n\n      if (outIndex >= nextIndex) {\n        throw new Error(backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(outIndex, outputRows));\n    } // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n\n\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i, indices[i], inputFlat[0]));\n      }\n\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n\n    if (end > numIndices) {\n      break;\n    }\n  } // Fill the gap at the end with the default value.\n\n\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}","map":{"version":3,"mappings":"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","names":["backend_util","util","sparseSegmentReductionImpl","input","inputShape","inputDType","indices","segmentIds","isMean","defaultValue","numIndices","length","inputFlat","numCol","lastSegmentIdPlusOne","outputRows","Error","getSparseSegmentReductionNegativeSegmentIdsErrorMessage","outputShape","slice","outputLength","reduce","product","value","output","getArrayFromDType","fill","start","end","uninitializedIndex","outIndex","nextIndex","getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage","getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage","i","index","getSparseSegmentReductionIndicesOutOfRangeErrorMessage","j"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/SparseSegmentReduction_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseSegmentReductionImpl(\n    input: TypedArray, inputShape: number[], inputDType: DataType,\n    indices: TypedArray, segmentIds: TypedArray, isMean = false,\n    defaultValue = 0): [TypedArray, number[]] {\n  const numIndices = indices.length;\n\n  // Flatten the array to two dimensions\n  const inputFlat: number[] = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1];\n  // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n  const lastSegmentIdPlusOne =\n      numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(\n        backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n\n  const outputLength =\n      outputShape.reduce((product, value) => product * value, 1);\n  // Output array is initialized with the value 0 by default.\n  const output = util.getArrayFromDType(inputDType, outputLength) as TypedArray;\n\n  // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(\n        backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  let start = 0, end = 1;\n  // Index from which the output is not initialized.\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      }\n      // We have a new segment here.  Verify that the segment ids are growing.\n      if (outIndex >= nextIndex) {\n        throw new Error(backend_util\n            .getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(\n          backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(\n              outIndex, outputRows));\n    }\n\n    // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(\n            backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(\n                i, indices[i], inputFlat[0]));\n      }\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n    if (end > numIndices) {\n      break;\n    }\n  }\n\n  // Fill the gap at the end with the default value.\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}\n"]},"metadata":{},"sourceType":"module"}