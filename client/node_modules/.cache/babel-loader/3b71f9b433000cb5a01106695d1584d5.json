{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\n/**\n * Returns true if the axis specifies the inner most dimensions of the\n * array.\n */\n\nexport function axesAreInnerMostDims(axes, rank) {\n  for (let i = 0; i < axes.length; ++i) {\n    if (axes[axes.length - i - 1] !== rank - 1 - i) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function combineLocations(outputLoc, reduceLoc, axes) {\n  const rank = outputLoc.length + reduceLoc.length;\n  const loc = [];\n  let outIdx = 0;\n  let reduceIdx = 0;\n\n  for (let dim = 0; dim < rank; dim++) {\n    if (axes.indexOf(dim) === -1) {\n      loc.push(outputLoc[outIdx++]);\n    } else {\n      loc.push(reduceLoc[reduceIdx++]);\n    }\n  }\n\n  return loc;\n}\nexport function computeOutAndReduceShapes(aShape, axes) {\n  const outShape = [];\n  const rank = aShape.length;\n\n  for (let dim = 0; dim < rank; dim++) {\n    if (axes.indexOf(dim) === -1) {\n      outShape.push(aShape[dim]);\n    }\n  }\n\n  const reduceShape = axes.map(dim => aShape[dim]);\n  return [outShape, reduceShape];\n}\nexport function expandShapeToKeepDim(shape, axes) {\n  const reduceSubShape = axes.map(x => 1);\n  return combineLocations(shape, reduceSubShape, axes);\n}\nexport function assertAxesAreInnerMostDims(msg, axes, rank) {\n  util.assert(axesAreInnerMostDims(axes, rank), () => `${msg} supports only inner-most axes for now. ` + `Got axes ${axes} and rank-${rank} input.`);\n}\n/**\n * Returns the axes permutation to be used with `tf.transpose`, if such\n * permutation is necessary. Otherwise it returns null. This method is used by\n * operations that operate only on inner-most axes.\n */\n\nexport function getAxesPermutation(axes, rank) {\n  if (axesAreInnerMostDims(axes, rank)) {\n    return null;\n  }\n\n  const result = [];\n\n  for (let i = 0; i < rank; ++i) {\n    if (axes.indexOf(i) === -1) {\n      result.push(i);\n    }\n  }\n\n  axes.forEach(axis => result.push(axis));\n  return result;\n}\n/** Returns the axes permutation that undoes the original permutation. */\n\nexport function getUndoAxesPermutation(axes) {\n  return axes.map((axis, i) => [i, axis]).sort((a, b) => a[1] - b[1]).map(x => x[0]);\n}\nexport function getInnerMostAxes(numAxes, rank) {\n  const res = [];\n\n  for (let i = rank - numAxes; i < rank; ++i) {\n    res.push(i);\n  }\n\n  return res;\n}","map":{"version":3,"mappings":"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","names":["util","axesAreInnerMostDims","axes","rank","i","length","combineLocations","outputLoc","reduceLoc","loc","outIdx","reduceIdx","dim","indexOf","push","computeOutAndReduceShapes","aShape","outShape","reduceShape","map","expandShapeToKeepDim","shape","reduceSubShape","x","assertAxesAreInnerMostDims","msg","assert","getAxesPermutation","result","forEach","axis","getUndoAxesPermutation","sort","a","b","getInnerMostAxes","numAxes","res"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/ops/axis_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as util from '../util';\n\n/**\n * Returns true if the axis specifies the inner most dimensions of the\n * array.\n */\nexport function axesAreInnerMostDims(axes: number[], rank: number): boolean {\n  for (let i = 0; i < axes.length; ++i) {\n    if (axes[axes.length - i - 1] !== rank - 1 - i) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function combineLocations(\n    outputLoc: number[], reduceLoc: number[], axes: number[]): number[] {\n  const rank = outputLoc.length + reduceLoc.length;\n  const loc = [];\n  let outIdx = 0;\n  let reduceIdx = 0;\n  Â  for (let dim = 0; dim < rank; dim++) {\n    if (axes.indexOf(dim) === -1) {\n      loc.push(outputLoc[outIdx++]);\n    } else {\n      loc.push(reduceLoc[reduceIdx++]);\n    }\n  }\n  return loc;\n}\n\nexport function computeOutAndReduceShapes(\n    aShape: number[], axes: number[]): [number[], number[]] {\n  const outShape = [];\n  const rank = aShape.length;\n  for (let dim = 0; dim < rank; dim++) {\n    if (axes.indexOf(dim) === -1) {\n      outShape.push(aShape[dim]);\n    }\n  }\n  const reduceShape = axes.map(dim => aShape[dim]);\n  return [outShape, reduceShape];\n}\n\nexport function expandShapeToKeepDim(\n    shape: number[], axes: number[]): number[] {\n  const reduceSubShape = axes.map(x => 1);\n  return combineLocations(shape, reduceSubShape, axes);\n}\n\nexport function assertAxesAreInnerMostDims(\n    msg: string, axes: number[], rank: number): void {\n  util.assert(\n      axesAreInnerMostDims(axes, rank),\n      () => `${msg} supports only inner-most axes for now. ` +\n          `Got axes ${axes} and rank-${rank} input.`);\n}\n\n/**\n * Returns the axes permutation to be used with `tf.transpose`, if such\n * permutation is necessary. Otherwise it returns null. This method is used by\n * operations that operate only on inner-most axes.\n */\nexport function getAxesPermutation(axes: number[], rank: number): number[]|\n    null {\n  if (axesAreInnerMostDims(axes, rank)) {\n    return null;\n  }\n  const result: number[] = [];\n  for (let i = 0; i < rank; ++i) {\n    if (axes.indexOf(i) === -1) {\n      result.push(i);\n    }\n  }\n  axes.forEach(axis => result.push(axis));\n  return result;\n}\n\n/** Returns the axes permutation that undoes the original permutation. */\nexport function getUndoAxesPermutation(axes: number[]): number[] {\n  return axes.map((axis, i) => [i, axis])\n      .sort((a, b) => a[1] - b[1])\n      .map(x => x[0]);\n}\n\nexport function getInnerMostAxes(numAxes: number, rank: number): number[] {\n  const res: number[] = [];\n  for (let i = rank - numAxes; i < rank; ++i) {\n    res.push(i);\n  }\n  return res;\n}\n"]},"metadata":{},"sourceType":"module"}