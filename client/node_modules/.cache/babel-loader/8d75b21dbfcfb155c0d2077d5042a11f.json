{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util'; // Maximum number of values before we decide to show ellipsis.\n\nconst FORMAT_LIMIT_NUM_VALS = 20; // Number of first and last values to show when displaying a, b,...,y, z.\n\nconst FORMAT_NUM_FIRST_LAST_VALS = 3; // Number of significant digits to show.\n\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n  const strides = computeStrides(shape);\n  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  const rank = shape.length;\n  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  const lines = ['Tensor'];\n\n  if (verbose) {\n    lines.push(`  dtype: ${dtype}`);\n    lines.push(`  rank: ${rank}`);\n    lines.push(`  shape: [${shape}]`);\n    lines.push(`  values:`);\n  }\n\n  lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n  return lines.join('\\n');\n}\n\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n  const n = sizeFromShape(shape);\n  const numCols = strides[strides.length - 1];\n  const padPerCol = new Array(numCols).fill(0);\n  const rank = shape.length;\n  const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n\n  if (rank > 1) {\n    for (let row = 0; row < n / numCols; row++) {\n      const offset = row * numCols;\n\n      for (let j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n\n  return padPerCol;\n}\n\nfunction valToString(val, pad, dtype) {\n  let valStr;\n\n  if (Array.isArray(val)) {\n    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` + `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n  } else if (isString(val)) {\n    valStr = `'${val}'`;\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n\n  return rightPad(valStr, pad);\n}\n\nfunction boolNumToString(v) {\n  return v === 0 ? 'false' : 'true';\n}\n\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol) {\n  let isLast = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  const storagePerElement = dtype === 'complex64' ? 2 : 1;\n  const size = shape[0];\n  const rank = shape.length;\n\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      const complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0])];\n    }\n\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n      let firstVals = Array.from(vals.slice(0, firstValsSize));\n      let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n\n      return ['[' + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(', ') + ', ..., ' + lastVals.map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(', ') + ']'];\n    }\n\n    const displayVals = dtype === 'complex64' ? createComplexTuples(vals) : Array.from(vals);\n    return ['[' + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(', ') + ']'];\n  } // The array is rank 2 or more.\n\n\n  const subshape = shape.slice(1);\n  const substrides = strides.slice(1);\n  const stride = strides[0] * storagePerElement;\n  const lines = [];\n\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false\n      /* isLast */\n      ));\n    }\n\n    lines.push('...');\n\n    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1\n      /* isLast */\n      ));\n    }\n  } else {\n    for (let i = 0; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1\n      /* isLast */\n      ));\n    }\n  }\n\n  const sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + lines[0] + sep;\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    lines[i] = ' ' + lines[i] + sep;\n  }\n\n  let newLineSep = ',\\n';\n\n  for (let i = 2; i < rank; i++) {\n    newLineSep += '\\n';\n  }\n\n  lines[lines.length - 1] = ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\n\nfunction createComplexTuples(vals) {\n  const complexTuples = [];\n\n  for (let i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]]);\n  }\n\n  return complexTuples;\n}","map":{"version":3,"mappings":"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","names":["computeStrides","isString","rightPad","sizeFromShape","FORMAT_LIMIT_NUM_VALS","FORMAT_NUM_FIRST_LAST_VALS","FORMAT_NUM_SIG_DIGITS","tensorToString","vals","shape","dtype","verbose","strides","padPerCol","computeMaxSizePerColumn","rank","length","valsLines","subTensorToString","lines","push","map","l","join","n","numCols","Array","fill","valuesOrTuples","createComplexTuples","row","offset","j","Math","max","valToString","val","pad","valStr","isArray","parseFloat","toFixed","boolNumToString","toString","v","isLast","storagePerElement","size","complexTuple","firstValsSize","firstVals","from","slice","lastVals","x","i","displayVals","subshape","substrides","stride","start","end","sep","newLineSep","complexTuples"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/tensor_format.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray} from './types';\nimport {computeStrides, isString, rightPad, sizeFromShape} from './util';\n\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\n\nexport function tensorToString(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    verbose: boolean) {\n  const strides = computeStrides(shape);\n  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  const rank = shape.length;\n  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  const lines = ['Tensor'];\n  if (verbose) {\n    lines.push(`  dtype: ${dtype}`);\n    lines.push(`  rank: ${rank}`);\n    lines.push(`  shape: [${shape}]`);\n    lines.push(`  values:`);\n  }\n  lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n  return lines.join('\\n');\n}\n\nfunction computeMaxSizePerColumn(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    strides: number[]): number[] {\n  const n = sizeFromShape(shape);\n  const numCols = strides[strides.length - 1];\n  const padPerCol = new Array(numCols).fill(0);\n  const rank = shape.length;\n  const valuesOrTuples =\n      dtype === 'complex64' ? createComplexTuples(vals) : vals;\n\n  if (rank > 1) {\n    for (let row = 0; row < n / numCols; row++) {\n      const offset = row * numCols;\n      for (let j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(\n            padPerCol[j],\n            valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n  return padPerCol;\n}\n\nfunction valToString(\n    val: number|string|[number, number], pad: number, dtype: DataType) {\n  let valStr: string;\n  if (Array.isArray(val)) {\n    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n        `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n  } else if (isString(val)) {\n    valStr = `'${val}'`;\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n\n  return rightPad(valStr, pad);\n}\n\nfunction boolNumToString(v: number): string {\n  return v === 0 ? 'false' : 'true';\n}\n\nfunction subTensorToString(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    strides: number[], padPerCol: number[], isLast = true): string[] {\n  const storagePerElement = dtype === 'complex64' ? 2 : 1;\n\n  const size = shape[0];\n  const rank = shape.length;\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      const complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0] as number)];\n    }\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n\n      let firstVals = Array.from<number|string|[number, number]>(\n          vals.slice(0, firstValsSize));\n      let lastVals = Array.from<number|string|[number, number]>(vals.slice(\n          (size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement,\n          size * storagePerElement));\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n      return [\n        '[' +\n        firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n            .join(', ') +\n        ', ..., ' +\n        lastVals\n            .map(\n                (x, i) => valToString(\n                    x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n            .join(', ') +\n        ']'\n      ];\n    }\n    const displayVals: Array<number|string|[number, number]> =\n        dtype === 'complex64' ? createComplexTuples(vals) :\n                                Array.from<number|string>(vals);\n\n    return [\n      '[' +\n      displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n          .join(', ') +\n      ']'\n    ];\n  }\n\n  // The array is rank 2 or more.\n  const subshape = shape.slice(1);\n  const substrides = strides.slice(1);\n  const stride = strides[0] * storagePerElement;\n  const lines: string[] = [];\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          false /* isLast */));\n    }\n    lines.push('...');\n    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          i === size - 1 /* isLast */));\n    }\n  } else {\n    for (let i = 0; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          i === size - 1 /* isLast */));\n    }\n  }\n  const sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + lines[0] + sep;\n  for (let i = 1; i < lines.length - 1; i++) {\n    lines[i] = ' ' + lines[i] + sep;\n  }\n  let newLineSep = ',\\n';\n  for (let i = 2; i < rank; i++) {\n    newLineSep += '\\n';\n  }\n  lines[lines.length - 1] =\n      ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\n\nfunction createComplexTuples(vals: Array<{}>|\n                             TypedArray): Array<[number, number]> {\n  const complexTuples: Array<[number, number]> = [];\n  for (let i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]] as [number, number]);\n  }\n  return complexTuples;\n}\n"]},"metadata":{},"sourceType":"module"}