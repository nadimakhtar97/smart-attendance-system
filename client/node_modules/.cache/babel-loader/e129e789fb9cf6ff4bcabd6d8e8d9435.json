{"ast":null,"code":"/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  constructor() {\n    let weightMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let tensorArrayMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tensorListMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let functionMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.weightMap = weightMap;\n    this.tensorArrayMap = tensorArrayMap;\n    this.tensorListMap = tensorListMap;\n    this.functionMap = functionMap;\n    this.rootContext = {\n      id: 0,\n      frameName: '',\n      iterationId: 0\n    };\n    this.contexts = [this.rootContext];\n    this.lastId = 0;\n    this.generateCurrentContextIds();\n  }\n\n  newFrame(id, frameName) {\n    return {\n      id,\n      frameName,\n      iterationId: 0\n    };\n  }\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n\n\n  set currentContext(contexts) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext() {\n    return this.contexts;\n  }\n  /**\n   * Returns the current context in string format.\n   */\n\n\n  get currentContextId() {\n    return this._currentContextIds[0];\n  }\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n\n\n  get currentContextIds() {\n    return this._currentContextIds;\n  }\n\n  generateCurrentContextIds() {\n    const names = [];\n\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  contextIdforContexts(contexts) {\n    return contexts ? contexts.map(context => context.id === 0 && context.iterationId === 0 ? '' : `${context.frameName}-${context.iterationId}`).join('/') : '';\n  }\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n\n\n  enterFrame(frameId) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n\n\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n\n\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n\n      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name) {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id) {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id) {\n    return this.tensorListMap[id];\n  }\n\n  dispose(keepIds) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ExecutionContext","constructor","weightMap","tensorArrayMap","tensorListMap","functionMap","id","frameName","iterationId","rootContext","generateCurrentContextIds","newFrame","currentContext","contexts","currentContextId","_currentContextIds","currentContextIds","names","i","length","slice","push","contextIdforContexts","map","context","join","enterFrame","frameId","lastId","unshift","exitFrame","splice","shift","Error","nextIteration","Object","assign","getWeight","name","addTensorArray","tensorArray","getTensorArray","addTensorList","tensorList","getTensorList","dispose","keepIds","key","clearAndClose"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-converter/src/executor/execution_context.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap, TensorArrayMap, TensorListMap} from '../data/types';\n\nimport {TensorArray} from './tensor_array';\nimport {TensorList} from './tensor_list';\nimport {FunctionExecutor} from './types';\n\nexport interface ExecutionContextInfo {\n  id: number;           // the unique id of the context info\n  frameName: string;    // The frame name of the loop, this comes from\n                        // the TensorFlow NodeDef.\n  iterationId: number;  // The iteration id of the loop\n}\n\n/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nexport class ExecutionContext {\n  private rootContext = {id: 0, frameName: '', iterationId: 0};\n  private contexts: ExecutionContextInfo[] = [this.rootContext];\n  private lastId = 0;\n  private _currentContextIds: string[];\n\n  constructor(\n      readonly weightMap: NamedTensorsMap = {},\n      readonly tensorArrayMap: TensorArrayMap = {},\n      readonly tensorListMap: TensorListMap = {},\n      readonly functionMap: {[key: string]: FunctionExecutor} = {}) {\n    this.generateCurrentContextIds();\n  }\n\n  private newFrame(id: number, frameName: string) {\n    return {id, frameName, iterationId: 0};\n  }\n\n  /**\n   * Set the current context\n   * @param contexts: ExecutionContextInfo[] the current path of execution\n   * frames\n   */\n  set currentContext(contexts: ExecutionContextInfo[]) {\n    if (this.contexts !== contexts) {\n      this.contexts = contexts;\n      this.generateCurrentContextIds();\n    }\n  }\n\n  get currentContext(): ExecutionContextInfo[] {\n    return this.contexts;\n  }\n\n  /**\n   * Returns the current context in string format.\n   */\n  get currentContextId(): string {\n    return this._currentContextIds[0];\n  }\n\n  /**\n   * Returns the current context and all parent contexts in string format.\n   * This allow access to the nodes in the current and parent frames.\n   */\n  get currentContextIds(): string[] {\n    return this._currentContextIds;\n  }\n\n  private generateCurrentContextIds() {\n    const names = [];\n    for (let i = 0; i < this.contexts.length - 1; i++) {\n      const contexts = this.contexts.slice(0, this.contexts.length - i);\n      names.push(this.contextIdforContexts(contexts));\n    }\n    names.push('');\n    this._currentContextIds = names;\n  }\n\n  private contextIdforContexts(contexts: ExecutionContextInfo[]) {\n    return contexts ?\n        contexts\n            .map(\n                context => (context.id === 0 && context.iterationId === 0) ?\n                    '' :\n                    `${context.frameName}-${context.iterationId}`)\n            .join('/') :\n        '';\n  }\n\n  /**\n   * Enter a new frame, a new context is pushed on the current context list.\n   * @param frameId new frame id\n   */\n  enterFrame(frameId: string) {\n    if (this.contexts) {\n      this.lastId++;\n      this.contexts = this.contexts.slice();\n      this.contexts.push(this.newFrame(this.lastId, frameId));\n      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n    }\n  }\n\n  /**\n   * Exit the current frame, the last context is removed from the current\n   * context list.\n   */\n  exitFrame() {\n    if (this.contexts && this.contexts.length > 1) {\n      this.contexts = this.contexts.slice();\n      this.contexts.splice(-1);\n      this.currentContextIds.shift();\n    } else {\n      throw new Error('Cannot exit frame, the context is empty');\n    }\n  }\n\n  /**\n   * Enter the next iteration of a loop, the iteration id of last context is\n   * increased.\n   */\n  nextIteration() {\n    if (this.contexts && this.contexts.length > 0) {\n      this.contexts = this.contexts.slice();\n      this.lastId++;\n      const context =\n          Object.assign({}, this.contexts[this.contexts.length - 1]);\n      context.iterationId += 1;\n      context.id = this.lastId;\n      this.contexts.splice(-1, 1, context);\n      this._currentContextIds.splice(\n          0, 1, this.contextIdforContexts(this.contexts));\n    } else {\n      throw new Error('Cannot increase frame iteration, the context is empty');\n    }\n  }\n\n  getWeight(name: string): Tensor[] {\n    return this.weightMap[name];\n  }\n\n  addTensorArray(tensorArray: TensorArray) {\n    this.tensorArrayMap[tensorArray.id] = tensorArray;\n  }\n\n  getTensorArray(id: number): TensorArray {\n    return this.tensorArrayMap[id];\n  }\n\n  addTensorList(tensorList: TensorList) {\n    this.tensorListMap[tensorList.id] = tensorList;\n  }\n\n  getTensorList(id: number): TensorList {\n    return this.tensorListMap[id];\n  }\n\n  dispose(keepIds: Set<number>) {\n    for (const key in this.tensorArrayMap) {\n      this.tensorArrayMap[key].clearAndClose(keepIds);\n    }\n\n    for (const key in this.tensorListMap) {\n      this.tensorListMap[key].clearAndClose(keepIds);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}