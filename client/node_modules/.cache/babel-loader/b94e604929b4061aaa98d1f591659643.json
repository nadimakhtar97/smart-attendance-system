{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Transform, util } from '@tensorflow/tfjs-core';\nexport function transform(args) {\n  const {\n    inputs,\n    attrs,\n    backend\n  } = args;\n  const {\n    image,\n    transforms\n  } = inputs;\n  const {\n    interpolation,\n    fillMode,\n    fillValue,\n    outputShape\n  } = attrs;\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];\n  const outShape = [batch, outHeight, outWidth, numChannels];\n  const strides = util.computeStrides(image.shape);\n  const batchStride = strides[0];\n  const rowStride = strides[1];\n  const colStride = strides[2];\n  const outVals = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(outShape));\n  outVals.fill(fillValue);\n  const imageVals = backend.data.get(image.dataId).values;\n  const transformVals = backend.data.get(transforms.dataId).values; // Ref TF implementation:\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n\n  for (let b = 0; b < batch; ++b) {\n    const transform = transforms.shape[0] === 1 ? transformVals : transformVals.subarray(b * 8, b * 8 + 8);\n\n    for (let outY = 0; outY < outHeight; ++outY) {\n      for (let outX = 0; outX < outWidth; ++outX) {\n        for (let channel = 0; channel < numChannels; ++channel) {\n          let val;\n          const projection = transform[6] * outX + transform[7] * outY + 1;\n\n          if (projection === 0) {\n            // Return the fill value for infinite coordinates,\n            // which are outside the input image\n            continue;\n          }\n\n          const inX = (transform[0] * outX + transform[1] * outY + transform[2]) / projection;\n          const inY = (transform[3] * outX + transform[4] * outY + transform[5]) / projection;\n          const x = mapCoord(inX, imageWidth, fillMode);\n          const y = mapCoord(inY, imageHeight, fillMode);\n\n          switch (interpolation) {\n            case 'nearest':\n              val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);\n              break;\n\n            case 'bilinear':\n              val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);\n              break;\n\n            default:\n              throw new Error(`Error in Transform: Expect 'nearest' or ` + `'bilinear', but got ${interpolation}`);\n          }\n\n          const ind = b * batchStride + outY * rowStride + outX * colStride + channel;\n          outVals[ind] = val;\n        }\n      }\n    }\n\n    return backend.makeTensorInfo(outShape, image.dtype, outVals);\n  }\n\n  const dataId = backend.write(outVals, outShape, image.dtype);\n  return {\n    dataId,\n    shape: image.shape,\n    dtype: image.dtype\n  };\n}\nexport const transformConfig = {\n  kernelName: Transform,\n  backendName: 'cpu',\n  kernelFunc: transform\n};\n\nfunction mapCoord(outCoord, len, mode) {\n  switch (mode) {\n    case 'reflect':\n      return mapCoordReflect(outCoord, len);\n\n    case 'wrap':\n      return mapCoordWrap(outCoord, len);\n\n    case 'nearest':\n      return mapCoordNearest(outCoord, len);\n\n    case 'constant':\n    default:\n      return mapCoordConstant(outCoord, len);\n  }\n}\n\nfunction mapCoordReflect(outCoord, len) {\n  // Reflect [abcd] to [dcba|abcd|dcba].\n  let inCoord = outCoord;\n\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n\n      if (inCoord < sz2) {\n        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n      }\n\n      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n      inCoord -= sz2 * Math.trunc(inCoord / sz2);\n\n      if (inCoord >= len) {\n        inCoord = sz2 - inCoord - 1;\n      }\n    }\n  } // clamp is necessary because when outCoord = 3.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n\n\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordWrap(outCoord, len) {\n  // Wrap [abcd] to [abcd|abcd|abcd].\n  let inCoord = outCoord;\n\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord -= len * Math.trunc(inCoord / sz);\n    }\n  } // clamp is necessary because when outCoord = -0.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n\n\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordConstant(outCoord, len) {\n  return outCoord;\n}\n\nfunction mapCoordNearest(outCoord, len) {\n  return util.clamp(0, outCoord, len - 1);\n}\n\nfunction readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const ind = batch * batchStride + y * rowStride + x * colStride + channel;\n\n  if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n    return imageVals[ind];\n  } else {\n    return fillValue;\n  }\n}\n\nfunction nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const $y = Math.round(y);\n  const $x = Math.round(x);\n  return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);\n}\n\nfunction bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const yFloor = Math.floor(y);\n  const xFloor = Math.floor(x);\n  const yCeil = yFloor + 1;\n  const xCeil = xFloor + 1; // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n  //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n\n  const valueYFloor = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue); // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n  //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n\n  const valueYCeil = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue); // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n  //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n\n  return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}","map":{"version":3,"mappings":"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","names":["Transform","util","transform","args","inputs","attrs","backend","image","transforms","interpolation","fillMode","fillValue","outputShape","batch","imageHeight","imageWidth","numChannels","shape","outHeight","outWidth","outShape","strides","computeStrides","batchStride","rowStride","colStride","outVals","getTypedArrayFromDType","dtype","sizeFromShape","fill","imageVals","data","get","dataId","values","transformVals","b","subarray","outY","outX","channel","val","projection","inX","inY","x","mapCoord","y","nearestInterpolation","bilinearInterpolation","Error","ind","makeTensorInfo","write","transformConfig","kernelName","backendName","kernelFunc","outCoord","len","mode","mapCoordReflect","mapCoordWrap","mapCoordNearest","mapCoordConstant","inCoord","sz2","Math","trunc","clamp","sz","readWithFillValue","$y","round","$x","yFloor","floor","xFloor","yCeil","xCeil","valueYFloor","valueYCeil"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/Transform.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, NumericDataType, TensorInfo, Transform, TransformAttrs, TransformInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function transform(args: {\n  inputs: TransformInputs,\n  attrs: TransformAttrs,\n  backend: MathBackendCPU\n}): TensorInfo {\n  const {inputs, attrs, backend} = args;\n  const {image, transforms} = inputs;\n  const {interpolation, fillMode, fillValue, outputShape} = attrs;\n\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const [outHeight, outWidth] =\n      outputShape != null ? outputShape : [imageHeight, imageWidth];\n  const outShape = [batch, outHeight, outWidth, numChannels];\n\n  const strides = util.computeStrides(image.shape);\n  const batchStride = strides[0];\n  const rowStride = strides[1];\n  const colStride = strides[2];\n\n  const outVals = util.getTypedArrayFromDType(\n      image.dtype as NumericDataType, util.sizeFromShape(outShape));\n\n  outVals.fill(fillValue);\n\n  const imageVals = backend.data.get(image.dataId).values as TypedArray;\n  const transformVals =\n      backend.data.get(transforms.dataId).values as TypedArray;\n\n  // Ref TF implementation:\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n  for (let b = 0; b < batch; ++b) {\n    const transform = transforms.shape[0] === 1 ?\n        transformVals :\n        transformVals.subarray(b * 8, b * 8 + 8);\n\n    for (let outY = 0; outY < outHeight; ++outY) {\n      for (let outX = 0; outX < outWidth; ++outX) {\n        for (let channel = 0; channel < numChannels; ++channel) {\n          let val;\n\n          const projection = transform[6] * outX + transform[7] * outY + 1;\n\n          if (projection === 0) {\n            // Return the fill value for infinite coordinates,\n            // which are outside the input image\n            continue;\n          }\n\n          const inX =\n              (transform[0] * outX + transform[1] * outY + transform[2]) /\n              projection;\n          const inY =\n              (transform[3] * outX + transform[4] * outY + transform[5]) /\n              projection;\n\n          const x = mapCoord(inX, imageWidth, fillMode);\n          const y = mapCoord(inY, imageHeight, fillMode);\n\n          switch (interpolation) {\n            case 'nearest':\n              val = nearestInterpolation(\n                  imageVals, imageHeight, imageWidth, batchStride, rowStride,\n                  colStride, b, y, x, channel, fillValue);\n              break;\n            case 'bilinear':\n              val = bilinearInterpolation(\n                  imageVals, imageHeight, imageWidth, batchStride, rowStride,\n                  colStride, b, y, x, channel, fillValue);\n              break;\n            default:\n              throw new Error(\n                  `Error in Transform: Expect 'nearest' or ` +\n                  `'bilinear', but got ${interpolation}`);\n          }\n\n          const ind =\n              b * batchStride + outY * rowStride + outX * colStride + channel;\n\n          outVals[ind] = val;\n        }\n      }\n    }\n\n    return backend.makeTensorInfo(outShape, image.dtype, outVals);\n  }\n\n  const dataId = backend.write(outVals, outShape, image.dtype);\n  return {dataId, shape: image.shape, dtype: image.dtype};\n}\n\nexport const transformConfig: KernelConfig = {\n  kernelName: Transform,\n  backendName: 'cpu',\n  kernelFunc: transform as {} as KernelFunc\n};\n\nfunction mapCoord(\n    outCoord: number, len: number,\n    mode: 'constant'|'reflect'|'wrap'|'nearest') {\n  switch (mode) {\n    case 'reflect':\n      return mapCoordReflect(outCoord, len);\n    case 'wrap':\n      return mapCoordWrap(outCoord, len);\n    case 'nearest':\n      return mapCoordNearest(outCoord, len);\n    case 'constant':\n    default:\n      return mapCoordConstant(outCoord, len);\n  }\n}\n\nfunction mapCoordReflect(outCoord: number, len: number): number {\n  // Reflect [abcd] to [dcba|abcd|dcba].\n  let inCoord = outCoord;\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n      if (inCoord < sz2) {\n        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n      }\n      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n      inCoord -= sz2 * Math.trunc(inCoord / sz2);\n      if (inCoord >= len) {\n        inCoord = sz2 - inCoord - 1;\n      }\n    }\n  }\n  // clamp is necessary because when outCoord = 3.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordWrap(outCoord: number, len: number): number {\n  // Wrap [abcd] to [abcd|abcd|abcd].\n  let inCoord = outCoord;\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord -= len * Math.trunc(inCoord / sz);\n    }\n  }\n  // clamp is necessary because when outCoord = -0.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordConstant(outCoord: number, len: number): number {\n  return outCoord;\n}\n\nfunction mapCoordNearest(outCoord: number, len: number): number {\n  return util.clamp(0, outCoord, len - 1);\n}\n\nfunction readWithFillValue(\n    imageVals: TypedArray, imageHeight: number, imageWidth: number,\n    batchStride: number, rowStride: number, colStride: number, batch: number,\n    y: number, x: number, channel: number, fillValue: number): number {\n  const ind = batch * batchStride + y * rowStride + x * colStride + channel;\n  if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n    return imageVals[ind];\n  } else {\n    return fillValue;\n  }\n}\n\nfunction nearestInterpolation(\n    imageVals: TypedArray, imageHeight: number, imageWidth: number,\n    batchStride: number, rowStride: number, colStride: number, batch: number,\n    y: number, x: number, channel: number, fillValue: number): number {\n  const $y = Math.round(y);\n  const $x = Math.round(x);\n\n  return readWithFillValue(\n      imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride,\n      batch, $y, $x, channel, fillValue);\n}\n\nfunction bilinearInterpolation(\n    imageVals: TypedArray, imageHeight: number, imageWidth: number,\n    batchStride: number, rowStride: number, colStride: number, batch: number,\n    y: number, x: number, channel: number, fillValue: number) {\n  const yFloor = Math.floor(y);\n  const xFloor = Math.floor(x);\n  const yCeil = yFloor + 1;\n  const xCeil = xFloor + 1;\n  // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n  //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n  const valueYFloor =\n      (xCeil - x) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yFloor, xFloor, channel, fillValue) +\n      (x - xFloor) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yFloor, xCeil, channel, fillValue);\n  // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n  //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n  const valueYCeil =\n      (xCeil - x) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yCeil, xFloor, channel, fillValue) +\n      (x - xFloor) *\n          readWithFillValue(\n              imageVals, imageHeight, imageWidth, batchStride, rowStride,\n              colStride, batch, yCeil, xCeil, channel, fillValue);\n  // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n  //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n  return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}\n"]},"metadata":{},"sourceType":"module"}