{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../../util';\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { split } from '../split';\nimport { zeros } from '../zeros';\nimport { zerosLike } from '../zeros_like';\nimport { fft } from './fft';\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\n\nfunction rfft_(input, fftLength) {\n  assert(input.dtype === 'float32', () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n  let innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  let adjustedInput;\n\n  if (fftLength != null && fftLength < innerDimensionSize) {\n    // Need to crop\n    const begin = input.shape.map(v => 0);\n    const size = input.shape.map(v => v);\n    size[input.shape.length - 1] = fftLength;\n    adjustedInput = slice(input, begin, size);\n    innerDimensionSize = fftLength;\n  } else if (fftLength != null && fftLength > innerDimensionSize) {\n    // Need to pad with zeros\n    const zerosShape = input.shape.map(v => v);\n    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n    adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n    innerDimensionSize = fftLength;\n  } else {\n    adjustedInput = input;\n  } // Complement the input with zero imaginary numbers.\n\n\n  const zerosInput = zerosLike(adjustedInput);\n  const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n  const ret = fft(complexInput); // Exclude complex conjugations. These conjugations are put symmetrically.\n\n  const half = Math.floor(innerDimensionSize / 2) + 1;\n  const realValues = real(ret);\n  const imagValues = imag(ret);\n  const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);\n  const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);\n  const outputShape = adjustedInput.shape.slice();\n  outputShape[adjustedInput.shape.length - 1] = half;\n  return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\n\nexport const rfft = op({\n  rfft_\n});","map":{"version":3,"mappings":"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","names":["assert","complex","concat","imag","op","real","reshape","slice","split","zeros","zerosLike","fft","rfft_","input","fftLength","dtype","innerDimensionSize","shape","length","batch","size","adjustedInput","begin","map","v","zerosShape","zerosInput","complexInput","ret","half","Math","floor","realValues","imagValues","realComplexConjugate","imagComplexConjugate","outputShape","rfft"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/ops/spectral/rfft.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../../tensor';\nimport {assert} from '../../util';\nimport {complex} from '../complex';\nimport {concat} from '../concat';\nimport {imag} from '../imag';\nimport {op} from '../operation';\nimport {real} from '../real';\nimport {reshape} from '../reshape';\nimport {slice} from '../slice';\nimport {split} from '../split';\nimport {zeros} from '../zeros';\nimport {zerosLike} from '../zeros_like';\n\nimport {fft} from './fft';\n\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction rfft_(input: Tensor, fftLength?: number): Tensor {\n  assert(\n      input.dtype === 'float32',\n      () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n\n  let innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n\n  let adjustedInput: Tensor;\n  if (fftLength != null && fftLength < innerDimensionSize) {\n    // Need to crop\n    const begin = input.shape.map(v => 0);\n    const size = input.shape.map(v => v);\n    size[input.shape.length - 1] = fftLength;\n    adjustedInput = slice(input, begin, size);\n    innerDimensionSize = fftLength;\n  } else if (fftLength != null && fftLength > innerDimensionSize) {\n    // Need to pad with zeros\n    const zerosShape = input.shape.map(v => v);\n    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n    adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n    innerDimensionSize = fftLength;\n  } else {\n    adjustedInput = input;\n  }\n\n  // Complement the input with zero imaginary numbers.\n  const zerosInput = zerosLike(adjustedInput);\n  const complexInput =\n      reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n\n  const ret = fft(complexInput);\n\n  // Exclude complex conjugations. These conjugations are put symmetrically.\n  const half = Math.floor(innerDimensionSize / 2) + 1;\n  const realValues = real(ret);\n  const imagValues = imag(ret);\n  const realComplexConjugate = split(\n      realValues, [half, innerDimensionSize - half],\n      realValues.shape.length - 1);\n  const imagComplexConjugate = split(\n      imagValues, [half, innerDimensionSize - half],\n      imagValues.shape.length - 1);\n\n  const outputShape = adjustedInput.shape.slice();\n  outputShape[adjustedInput.shape.length - 1] = half;\n\n  return reshape(\n      complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\n\nexport const rfft = op({rfft_});\n"]},"metadata":{},"sourceType":"module"}