{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\n\nexport class MicrophoneIterator extends LazyIterator {\n  constructor(microphoneConfig) {\n    super();\n    this.microphoneConfig = microphoneConfig;\n    this.isClosed = false;\n    this.fftSize = microphoneConfig.fftSize || 1024;\n    const fftSizeLog2 = Math.log2(this.fftSize);\n\n    if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 || !Number.isInteger(fftSizeLog2)) {\n      throw new Error(`Invalid fftSize: it must be a power of 2 between ` + `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n    }\n\n    this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    this.sampleRateHz = microphoneConfig.sampleRateHz;\n    this.columnTruncateLength = microphoneConfig.columnTruncateLength || this.fftSize;\n    this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n    this.includeSpectrogram = microphoneConfig.includeSpectrogram === false ? false : true;\n    this.includeWaveform = microphoneConfig.includeWaveform === true ? true : false;\n\n    if (!this.includeSpectrogram && !this.includeWaveform) {\n      throw new Error('Both includeSpectrogram and includeWaveform are false. ' + 'At least one type of data should be returned.');\n    }\n  }\n\n  summary() {\n    return `microphone`;\n  } // Construct a MicrophoneIterator and start the audio stream.\n\n\n  static async create() {\n    let microphoneConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (env().get('IS_NODE')) {\n      throw new Error('microphone API is only supported in browser environment.');\n    }\n\n    const microphoneIterator = new MicrophoneIterator(microphoneConfig); // Call async function start() to initialize the audio stream.\n\n    await microphoneIterator.start();\n    return microphoneIterator;\n  } // Start the audio stream and FFT.\n\n\n  async start() {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioTrackConstraints == null ? true : this.audioTrackConstraints,\n        video: false\n      });\n    } catch (e) {\n      throw new Error(`Error thrown while initializing video stream: ${e.message}`);\n    }\n\n    if (!this.stream) {\n      throw new Error('Could not obtain audio from microphone.');\n    }\n\n    const ctxConstructor = // tslint:disable-next-line:no-any\n    window.AudioContext || window.webkitAudioContext;\n    this.audioContext = new ctxConstructor();\n\n    if (!this.sampleRateHz) {\n      // If sample rate is not provided, use the available sample rate on\n      // device.\n      this.sampleRateHz = this.audioContext.sampleRate;\n    } else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n      throw new Error(`Mismatch in sampling rate: ` + `Expected: ${this.sampleRateHz}; ` + `Actual: ${this.audioContext.sampleRate}`);\n    }\n\n    const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = this.fftSize * 2;\n    this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n    streamSource.connect(this.analyser);\n    this.freqData = new Float32Array(this.fftSize);\n    this.timeData = new Float32Array(this.fftSize);\n    return;\n  }\n\n  async next() {\n    if (this.isClosed) {\n      return {\n        value: null,\n        done: true\n      };\n    }\n\n    let spectrogramTensor;\n    let waveformTensor;\n    const audioDataQueue = await this.getAudioData();\n\n    if (this.includeSpectrogram) {\n      const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n      spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);\n    }\n\n    if (this.includeWaveform) {\n      const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n      waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);\n    }\n\n    return {\n      value: {\n        'spectrogram': spectrogramTensor,\n        'waveform': waveformTensor\n      },\n      done: false\n    };\n  } // Capture one result from the audio stream, and extract the value from\n  // iterator.next() result.\n\n\n  async capture() {\n    return (await this.next()).value;\n  }\n\n  async getAudioData() {\n    const freqDataQueue = [];\n    const timeDataQueue = [];\n    let currentFrames = 0;\n    return new Promise(resolve => {\n      const intervalID = setInterval(() => {\n        if (this.includeSpectrogram) {\n          this.analyser.getFloatFrequencyData(this.freqData); // If the audio stream is initializing, return empty queue.\n\n          if (this.freqData[0] === -Infinity) {\n            resolve({\n              freqDataQueue,\n              timeDataQueue\n            });\n          }\n\n          freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n        }\n\n        if (this.includeWaveform) {\n          this.analyser.getFloatTimeDomainData(this.timeData);\n          timeDataQueue.push(this.timeData.slice());\n        } // Clean interval and return when all frames have been collected\n\n\n        if (++currentFrames === this.numFrames) {\n          clearInterval(intervalID);\n          resolve({\n            freqDataQueue,\n            timeDataQueue\n          });\n        }\n      }, this.fftSize / this.sampleRateHz * 1e3);\n    });\n  } // Stop the audio stream and pause the iterator.\n\n\n  stop() {\n    if (!this.isClosed) {\n      this.isClosed = true;\n      this.analyser.disconnect();\n      this.audioContext.close();\n\n      if (this.stream != null && this.stream.getTracks().length > 0) {\n        this.stream.getTracks()[0].stop();\n      }\n    }\n  } // Override toArray() function to prevent collecting.\n\n\n  toArray() {\n    throw new Error('Can not convert infinite audio stream to array.');\n  } // Return audio sampling rate in Hz\n\n\n  getSampleRate() {\n    return this.sampleRateHz;\n  }\n\n  flattenQueue(queue) {\n    const frameSize = queue[0].length;\n    const freqData = new Float32Array(queue.length * frameSize);\n    queue.forEach((data, i) => freqData.set(data, i * frameSize));\n    return freqData;\n  }\n\n  getTensorFromAudioDataArray(freqData, shape) {\n    const vals = new Float32Array(util.sizeFromShape(shape)); // If the data is less than the output shape, the rest is padded with zeros.\n\n    vals.set(freqData, vals.length - freqData.length);\n    return tensor(vals, shape);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["env","tensor","util","LazyIterator","MicrophoneIterator","constructor","microphoneConfig","fftSize","fftSizeLog2","Math","log2","Number","isInteger","Error","numFrames","numFramesPerSpectrogram","sampleRateHz","columnTruncateLength","audioTrackConstraints","smoothingTimeConstant","includeSpectrogram","includeWaveform","summary","create","get","microphoneIterator","start","stream","navigator","mediaDevices","getUserMedia","audio","video","e","message","ctxConstructor","window","AudioContext","webkitAudioContext","audioContext","sampleRate","streamSource","createMediaStreamSource","analyser","createAnalyser","connect","freqData","Float32Array","timeData","next","isClosed","value","done","spectrogramTensor","waveformTensor","audioDataQueue","getAudioData","flattenQueue","freqDataQueue","getTensorFromAudioDataArray","timeDataQueue","capture","currentFrames","Promise","resolve","intervalID","setInterval","getFloatFrequencyData","Infinity","push","slice","getFloatTimeDomainData","clearInterval","stop","disconnect","close","getTracks","length","toArray","getSampleRate","queue","frameSize","forEach","data","i","set","shape","vals","sizeFromShape"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-data/src/iterators/microphone_iterator.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {env, Tensor, tensor, Tensor2D, Tensor3D, TensorContainer, util} from '@tensorflow/tfjs-core';\nimport {MicrophoneConfig} from '../types';\nimport {LazyIterator} from './lazy_iterator';\n\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport class MicrophoneIterator extends LazyIterator<TensorContainer> {\n  private isClosed = false;\n  private stream: MediaStream;\n  private readonly fftSize: number;\n  private readonly columnTruncateLength: number;\n  private freqData: Float32Array;\n  private timeData: Float32Array;\n  private readonly numFrames: number;\n  private analyser: AnalyserNode;\n  private audioContext: AudioContext;\n  private sampleRateHz: number;\n  private readonly audioTrackConstraints: MediaTrackConstraints;\n  private readonly smoothingTimeConstant: number;\n  private readonly includeSpectrogram: boolean;\n  private readonly includeWaveform: boolean;\n\n  private constructor(protected readonly microphoneConfig: MicrophoneConfig) {\n    super();\n    this.fftSize = microphoneConfig.fftSize || 1024;\n    const fftSizeLog2 = Math.log2(this.fftSize);\n    if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 ||\n        !Number.isInteger(fftSizeLog2)) {\n      throw new Error(\n          `Invalid fftSize: it must be a power of 2 between ` +\n          `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n    }\n\n    this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    this.sampleRateHz = microphoneConfig.sampleRateHz;\n    this.columnTruncateLength =\n        microphoneConfig.columnTruncateLength || this.fftSize;\n    this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n\n    this.includeSpectrogram =\n        microphoneConfig.includeSpectrogram === false ? false : true;\n    this.includeWaveform =\n        microphoneConfig.includeWaveform === true ? true : false;\n    if (!this.includeSpectrogram && !this.includeWaveform) {\n      throw new Error(\n          'Both includeSpectrogram and includeWaveform are false. ' +\n          'At least one type of data should be returned.');\n    }\n  }\n\n  summary() {\n    return `microphone`;\n  }\n\n  // Construct a MicrophoneIterator and start the audio stream.\n  static async create(microphoneConfig: MicrophoneConfig = {}) {\n    if (env().get('IS_NODE')) {\n      throw new Error(\n          'microphone API is only supported in browser environment.');\n    }\n\n    const microphoneIterator = new MicrophoneIterator(microphoneConfig);\n\n    // Call async function start() to initialize the audio stream.\n    await microphoneIterator.start();\n\n    return microphoneIterator;\n  }\n\n  // Start the audio stream and FFT.\n  async start(): Promise<void> {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioTrackConstraints == null ? true :\n                                                    this.audioTrackConstraints,\n        video: false\n      });\n    } catch (e) {\n      throw new Error(\n          `Error thrown while initializing video stream: ${e.message}`);\n    }\n\n    if (!this.stream) {\n      throw new Error('Could not obtain audio from microphone.');\n    }\n\n    const ctxConstructor =\n        // tslint:disable-next-line:no-any\n        (window as any).AudioContext || (window as any).webkitAudioContext;\n    this.audioContext = new ctxConstructor();\n\n    if (!this.sampleRateHz) {\n      // If sample rate is not provided, use the available sample rate on\n      // device.\n      this.sampleRateHz = this.audioContext.sampleRate;\n    } else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n      throw new Error(\n          `Mismatch in sampling rate: ` +\n          `Expected: ${this.sampleRateHz}; ` +\n          `Actual: ${this.audioContext.sampleRate}`);\n    }\n\n    const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = this.fftSize * 2;\n    this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n    streamSource.connect(this.analyser);\n    this.freqData = new Float32Array(this.fftSize);\n    this.timeData = new Float32Array(this.fftSize);\n    return;\n  }\n\n  async next(): Promise<IteratorResult<TensorContainer>> {\n    if (this.isClosed) {\n      return {value: null, done: true};\n    }\n\n    let spectrogramTensor: Tensor;\n    let waveformTensor: Tensor;\n\n    const audioDataQueue = await this.getAudioData();\n    if (this.includeSpectrogram) {\n      const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n      spectrogramTensor = this.getTensorFromAudioDataArray(\n          freqData, [this.numFrames, this.columnTruncateLength, 1]);\n    }\n    if (this.includeWaveform) {\n      const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n      waveformTensor = this.getTensorFromAudioDataArray(\n          timeData, [this.numFrames * this.fftSize, 1]);\n    }\n\n    return {\n      value: {'spectrogram': spectrogramTensor, 'waveform': waveformTensor},\n      done: false\n    };\n  }\n\n  // Capture one result from the audio stream, and extract the value from\n  // iterator.next() result.\n  async capture(): Promise<{spectrogram: Tensor3D, waveform: Tensor2D}> {\n    return (await this.next()).value as\n        {spectrogram: Tensor3D, waveform: Tensor2D};\n  }\n\n  private async getAudioData():\n      Promise<{freqDataQueue: Float32Array[], timeDataQueue: Float32Array[]}> {\n    const freqDataQueue: Float32Array[] = [];\n    const timeDataQueue: Float32Array[] = [];\n    let currentFrames = 0;\n    return new Promise(resolve => {\n      const intervalID = setInterval(() => {\n        if (this.includeSpectrogram) {\n          this.analyser.getFloatFrequencyData(this.freqData);\n          // If the audio stream is initializing, return empty queue.\n          if (this.freqData[0] === -Infinity) {\n            resolve({freqDataQueue, timeDataQueue});\n          }\n          freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n        }\n        if (this.includeWaveform) {\n          this.analyser.getFloatTimeDomainData(this.timeData);\n          timeDataQueue.push(this.timeData.slice());\n        }\n\n        // Clean interval and return when all frames have been collected\n        if (++currentFrames === this.numFrames) {\n          clearInterval(intervalID);\n          resolve({freqDataQueue, timeDataQueue});\n        }\n      }, this.fftSize / this.sampleRateHz * 1e3);\n    });\n  }\n\n  // Stop the audio stream and pause the iterator.\n  stop(): void {\n    if (!this.isClosed) {\n      this.isClosed = true;\n      this.analyser.disconnect();\n      this.audioContext.close();\n      if (this.stream != null && this.stream.getTracks().length > 0) {\n        this.stream.getTracks()[0].stop();\n      }\n    }\n  }\n\n  // Override toArray() function to prevent collecting.\n  toArray(): Promise<Tensor[]> {\n    throw new Error('Can not convert infinite audio stream to array.');\n  }\n\n  // Return audio sampling rate in Hz\n  getSampleRate(): number {\n    return this.sampleRateHz;\n  }\n\n  private flattenQueue(queue: Float32Array[]): Float32Array {\n    const frameSize = queue[0].length;\n    const freqData = new Float32Array(queue.length * frameSize);\n    queue.forEach((data, i) => freqData.set(data, i * frameSize));\n    return freqData;\n  }\n\n  private getTensorFromAudioDataArray(freqData: Float32Array, shape: number[]):\n      Tensor {\n    const vals = new Float32Array(util.sizeFromShape(shape));\n    // If the data is less than the output shape, the rest is padded with zeros.\n    vals.set(freqData, vals.length - freqData.length);\n    return tensor(vals, shape);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}