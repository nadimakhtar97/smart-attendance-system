{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Concat, util } from '@tensorflow/tfjs-core';\nimport { complex } from './Complex';\nimport { concatImpl } from './Concat_impl';\nimport { identity } from './Identity';\nimport { imag } from './Imag';\nimport { real } from './Real';\nimport { reshape } from './Reshape';\nexport function concat(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    axis\n  } = attrs;\n  const $axis = util.parseAxisParam(axis, inputs[0].shape)[0];\n  let outShape = backend_util.computeOutShape(inputs.map(t => t.shape), $axis);\n\n  if (util.sizeFromShape(outShape) === 0) {\n    return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n  } // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n\n\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n\n  if ($inputs.length === 1) {\n    return identity({\n      inputs: {\n        x: $inputs[0]\n      },\n      backend\n    });\n  }\n\n  const shapes = $inputs.map(t => t.shape);\n  backend_util.assertParamsConsistent(shapes, $axis);\n\n  if ($inputs[0].dtype === 'complex64') {\n    const reals = $inputs.map(t => real({\n      inputs: {\n        input: t\n      },\n      backend\n    }));\n    const imags = $inputs.map(t => imag({\n      inputs: {\n        input: t\n      },\n      backend\n    }));\n    const realConcated = concat({\n      inputs: reals,\n      backend,\n      attrs: {\n        axis: $axis\n      }\n    });\n    const imagConcated = concat({\n      inputs: imags,\n      backend,\n      attrs: {\n        axis: $axis\n      }\n    });\n    const result = complex({\n      inputs: {\n        real: realConcated,\n        imag: imagConcated\n      },\n      backend\n    });\n    reals.forEach(r => backend.disposeIntermediateTensorInfo(r));\n    imags.forEach(i => backend.disposeIntermediateTensorInfo(i));\n    backend.disposeIntermediateTensorInfo(realConcated);\n    backend.disposeIntermediateTensorInfo(imagConcated);\n    return result;\n  } // Any concat of n-dimensional tensors across any axis can be reduced to\n  // a concatenation of two-dimensional tensors across the axis 1 by first\n  // partitioning the axes of the original tensors into those less than the\n  // axis to be concatenated and the rest. Then reshape the tensors\n  // into a two-dimensional tensor by collapsing these two sets of axes and\n  // concatenate the resulting matrices across the axis 1, finally reshaping\n  // the result to have the proper shape.\n\n\n  const inputs2D = $inputs.map(t => {\n    const innerSize = util.sizeFromShape(t.shape.slice($axis));\n    const shape = [-1, innerSize];\n    return reshape({\n      inputs: {\n        x: t\n      },\n      backend,\n      attrs: {\n        shape\n      }\n    });\n  });\n  const inputsValShapes = inputs2D.map(t => {\n    return {\n      vals: backend.data.get(t.dataId).values,\n      shape: t.shape\n    };\n  }); // Concats 2d tensors along axis=1.\n\n  outShape = backend_util.computeOutShape(inputs2D.map(t => t.shape), 1\n  /* axis */\n  );\n  const simplyConcat = inputs2D[0].shape[0] === 1;\n  const outVals = concatImpl(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);\n  const finalOutShape = backend_util.computeOutShape($inputs.map(t => t.shape), $axis);\n  const outInfo = backend.makeTensorInfo(finalOutShape, inputs[0].dtype, outVals);\n  inputs2D.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return outInfo;\n}\nexport const concatConfig = {\n  kernelName: Concat,\n  backendName: 'cpu',\n  kernelFunc: concat\n};","map":{"version":3,"mappings":"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","names":["backend_util","Concat","util","complex","concatImpl","identity","imag","real","reshape","concat","args","inputs","backend","attrs","axis","$axis","parseAxisParam","shape","outShape","computeOutShape","map","t","sizeFromShape","makeTensorInfo","dtype","$inputs","filter","length","x","shapes","assertParamsConsistent","reals","input","imags","realConcated","imagConcated","result","forEach","r","disposeIntermediateTensorInfo","i","inputs2D","innerSize","slice","inputsValShapes","vals","data","get","dataId","values","simplyConcat","outVals","finalOutShape","outInfo","concatConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/Concat.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Concat, ConcatAttrs, ConcatInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nimport {complex} from './Complex';\nimport {concatImpl} from './Concat_impl';\nimport {identity} from './Identity';\nimport {imag} from './Imag';\nimport {real} from './Real';\nimport {reshape} from './Reshape';\n\nexport function concat(\n    args: {inputs: ConcatInputs, backend: MathBackendCPU, attrs: ConcatAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {axis} = attrs;\n\n  const $axis = util.parseAxisParam(axis, inputs[0].shape)[0];\n  let outShape = backend_util.computeOutShape(inputs.map(t => t.shape), $axis);\n\n  if (util.sizeFromShape(outShape) === 0) {\n    return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n  }\n\n  // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n  if ($inputs.length === 1) {\n    return identity({inputs: {x: $inputs[0]}, backend});\n  }\n\n  const shapes = $inputs.map(t => t.shape);\n  backend_util.assertParamsConsistent(shapes, $axis);\n\n  if ($inputs[0].dtype === 'complex64') {\n    const reals = $inputs.map((t) => real({inputs: {input: t}, backend}));\n    const imags = $inputs.map((t) => imag({inputs: {input: t}, backend}));\n\n    const realConcated = concat({inputs: reals, backend, attrs: {axis: $axis}});\n    const imagConcated = concat({inputs: imags, backend, attrs: {axis: $axis}});\n\n    const result =\n        complex({inputs: {real: realConcated, imag: imagConcated}, backend});\n\n    reals.forEach(r => backend.disposeIntermediateTensorInfo(r));\n    imags.forEach(i => backend.disposeIntermediateTensorInfo(i));\n    backend.disposeIntermediateTensorInfo(realConcated);\n    backend.disposeIntermediateTensorInfo(imagConcated);\n\n    return result;\n  }\n\n  // Any concat of n-dimensional tensors across any axis can be reduced to\n  // a concatenation of two-dimensional tensors across the axis 1 by first\n  // partitioning the axes of the original tensors into those less than the\n  // axis to be concatenated and the rest. Then reshape the tensors\n  // into a two-dimensional tensor by collapsing these two sets of axes and\n  // concatenate the resulting matrices across the axis 1, finally reshaping\n  // the result to have the proper shape.\n  const inputs2D = $inputs.map(t => {\n    const innerSize = util.sizeFromShape(t.shape.slice($axis));\n    const shape = [-1, innerSize];\n    return reshape({inputs: {x: t}, backend, attrs: {shape}});\n  });\n\n  const inputsValShapes = inputs2D.map(t => {\n    return {vals: backend.data.get(t.dataId).values, shape: t.shape};\n  });\n\n  // Concats 2d tensors along axis=1.\n  outShape =\n      backend_util.computeOutShape(inputs2D.map(t => t.shape), 1 /* axis */);\n  const simplyConcat = inputs2D[0].shape[0] === 1;\n  const outVals =\n      concatImpl(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);\n\n  const finalOutShape =\n      backend_util.computeOutShape($inputs.map(t => t.shape), $axis);\n\n  const outInfo =\n      backend.makeTensorInfo(finalOutShape, inputs[0].dtype, outVals);\n\n  inputs2D.forEach(t => backend.disposeIntermediateTensorInfo(t));\n\n  return outInfo;\n}\n\nexport const concatConfig: KernelConfig = {\n  kernelName: Concat,\n  backendName: 'cpu',\n  kernelFunc: concat as {} as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module"}