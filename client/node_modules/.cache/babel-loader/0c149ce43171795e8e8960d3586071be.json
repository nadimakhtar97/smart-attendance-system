{"ast":null,"code":"import { convertToTensor } from '../../tensor_util_env';\nimport { cast } from '../cast';\nimport { div } from '../div';\nimport { Reduction } from '../loss_ops_utils';\nimport { mean } from '../mean';\nimport { mul } from '../mul';\nimport { notEqual } from '../not_equal';\nimport { ones } from '../ones';\nimport { op } from '../operation';\nimport { scalar } from '../scalar';\nimport { sum } from '../sum';\n/**\n * Computes the weighted loss between two tensors.\n *\n * @param losses Tensor of shape `[batch_size, d1, ... dN]`.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `losses`, and must be broadcastable to `losses` (i.e., all\n *    dimensions must be either `1`, or the same as the corresponding\n *    `losses` dimension).\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\n\nfunction computeWeightedLoss_(losses, weights) {\n  let reduction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Reduction.SUM_BY_NONZERO_WEIGHTS;\n  const $losses = convertToTensor(losses, 'losses', 'computeWeightedLoss');\n  let $weights = null;\n\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'computeWeightedLoss');\n  }\n\n  const weightedLoss = $weights == null ? $losses : mul($losses, $weights);\n\n  if (reduction === Reduction.NONE) {\n    return weightedLoss;\n  }\n\n  if (reduction === Reduction.SUM) {\n    return sum(weightedLoss);\n  }\n\n  if (reduction === Reduction.MEAN) {\n    if ($weights == null) {\n      return mean(weightedLoss);\n    } else {\n      const broadcastFactor = $losses.size / $weights.size;\n      const result = div(sum(weightedLoss), sum($weights));\n      return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) : result;\n    }\n  }\n\n  if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    if ($weights == null) {\n      return div(sum(weightedLoss), scalar($losses.size));\n    } else {\n      const broadcastedWeights = mul($weights, ones($losses.shape));\n      const numNonZeros = cast(sum(notEqual(broadcastedWeights, scalar(0))), 'float32');\n      return div(sum(weightedLoss), numNonZeros);\n    }\n  }\n\n  throw Error(`Unknown reduction: ${reduction}`);\n}\n\nexport const computeWeightedLoss = op({\n  computeWeightedLoss_\n});","map":{"version":3,"mappings":"AAiBA,SAAQA,eAAR,QAA8B,uBAA9B;AAGA,SAAQC,IAAR,QAAmB,SAAnB;AACA,SAAQC,GAAR,QAAkB,QAAlB;AACA,SAAQC,SAAR,QAAwB,mBAAxB;AACA,SAAQC,IAAR,QAAmB,SAAnB;AACA,SAAQC,GAAR,QAAkB,QAAlB;AACA,SAAQC,QAAR,QAAuB,cAAvB;AACA,SAAQC,IAAR,QAAmB,SAAnB;AACA,SAAQC,EAAR,QAAiB,cAAjB;AACA,SAAQC,MAAR,QAAqB,WAArB;AACA,SAAQC,GAAR,QAAkB,QAAlB;AAEA;;;;;;;;;;;;AAWA,SAASC,oBAAT,CACIC,MADJ,EAC0BC,OAD1B,EAEgD;AAAA,MAA5CC,SAA4C,uEAAhCX,SAAS,CAACY,sBAAsB;AAC9C,QAAMC,OAAO,GAAGhB,eAAe,CAACY,MAAD,EAAS,QAAT,EAAmB,qBAAnB,CAA/B;AACA,MAAIK,QAAQ,GAAW,IAAvB;;AACA,MAAIJ,OAAO,IAAI,IAAf,EAAqB;AACnBI,YAAQ,GAAGjB,eAAe,CAACa,OAAD,EAAU,SAAV,EAAqB,qBAArB,CAA1B;AACD;;AAED,QAAMK,YAAY,GAAID,QAAQ,IAAI,IAAb,GAAqBD,OAArB,GAA+BX,GAAG,CAACW,OAAD,EAAUC,QAAV,CAAvD;;AAEA,MAAIH,SAAS,KAAKX,SAAS,CAACgB,IAA5B,EAAkC;AAChC,WAAOD,YAAP;AACD;;AACD,MAAIJ,SAAS,KAAKX,SAAS,CAACiB,GAA5B,EAAiC;AAC/B,WAAOV,GAAG,CAACQ,YAAD,CAAV;AACD;;AACD,MAAIJ,SAAS,KAAKX,SAAS,CAACkB,IAA5B,EAAkC;AAChC,QAAIJ,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAOb,IAAI,CAACc,YAAD,CAAX;AACD,KAFD,MAEO;AACL,YAAMI,eAAe,GAAGN,OAAO,CAACO,IAAR,GAAeN,QAAQ,CAACM,IAAhD;AACA,YAAMC,MAAM,GAAGtB,GAAG,CAACQ,GAAG,CAACQ,YAAD,CAAJ,EAAoBR,GAAG,CAACO,QAAD,CAAvB,CAAlB;AACA,aAAOK,eAAe,GAAG,CAAlB,GAAsBpB,GAAG,CAACsB,MAAD,EAASf,MAAM,CAACa,eAAD,CAAf,CAAzB,GACsBE,MAD7B;AAED;AACF;;AACD,MAAIV,SAAS,KAAKX,SAAS,CAACY,sBAA5B,EAAoD;AAClD,QAAIE,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAOf,GAAG,CAACQ,GAAG,CAACQ,YAAD,CAAJ,EAAoBT,MAAM,CAACO,OAAO,CAACO,IAAT,CAA1B,CAAV;AACD,KAFD,MAEO;AACL,YAAME,kBAAkB,GAAGpB,GAAG,CAACY,QAAD,EAAWV,IAAI,CAACS,OAAO,CAACU,KAAT,CAAf,CAA9B;AAEA,YAAMC,WAAW,GACb1B,IAAI,CAACS,GAAG,CAACJ,QAAQ,CAACmB,kBAAD,EAAqBhB,MAAM,CAAC,CAAD,CAA3B,CAAT,CAAJ,EAA+C,SAA/C,CADR;AAEA,aAAOP,GAAG,CAACQ,GAAG,CAACQ,YAAD,CAAJ,EAAoBS,WAApB,CAAV;AACD;AACF;;AAED,QAAMC,KAAK,CAAC,sBAAsBd,SAAS,EAAhC,CAAX;AACD;;AACD,OAAO,MAAMe,mBAAmB,GAAGrB,EAAE,CAAC;AAACG;AAAD,CAAD,CAA9B","names":["convertToTensor","cast","div","Reduction","mean","mul","notEqual","ones","op","scalar","sum","computeWeightedLoss_","losses","weights","reduction","SUM_BY_NONZERO_WEIGHTS","$losses","$weights","weightedLoss","NONE","SUM","MEAN","broadcastFactor","size","result","broadcastedWeights","shape","numNonZeros","Error","computeWeightedLoss"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-core/src/ops/losses/compute_weighted_loss.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\n\nimport {cast} from '../cast';\nimport {div} from '../div';\nimport {Reduction} from '../loss_ops_utils';\nimport {mean} from '../mean';\nimport {mul} from '../mul';\nimport {notEqual} from '../not_equal';\nimport {ones} from '../ones';\nimport {op} from '../operation';\nimport {scalar} from '../scalar';\nimport {sum} from '../sum';\n\n/**\n * Computes the weighted loss between two tensors.\n *\n * @param losses Tensor of shape `[batch_size, d1, ... dN]`.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `losses`, and must be broadcastable to `losses` (i.e., all\n *    dimensions must be either `1`, or the same as the corresponding\n *    `losses` dimension).\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\nfunction computeWeightedLoss_<T extends Tensor, O extends Tensor>(\n    losses: T|TensorLike, weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $losses = convertToTensor(losses, 'losses', 'computeWeightedLoss');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'computeWeightedLoss');\n  }\n\n  const weightedLoss = ($weights == null) ? $losses : mul($losses, $weights);\n\n  if (reduction === Reduction.NONE) {\n    return weightedLoss as O;\n  }\n  if (reduction === Reduction.SUM) {\n    return sum(weightedLoss);\n  }\n  if (reduction === Reduction.MEAN) {\n    if ($weights == null) {\n      return mean(weightedLoss);\n    } else {\n      const broadcastFactor = $losses.size / $weights.size;\n      const result = div(sum(weightedLoss), sum($weights));\n      return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) :\n                                   result as O;\n    }\n  }\n  if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    if ($weights == null) {\n      return div(sum(weightedLoss), scalar($losses.size));\n    } else {\n      const broadcastedWeights = mul($weights, ones($losses.shape));\n\n      const numNonZeros =\n          cast(sum(notEqual(broadcastedWeights, scalar(0))), 'float32');\n      return div(sum(weightedLoss), numNonZeros);\n    }\n  }\n\n  throw Error(`Unknown reduction: ${reduction}`);\n}\nexport const computeWeightedLoss = op({computeWeightedLoss_});\n"]},"metadata":{},"sourceType":"module"}