{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n  constructor(gpgpu) {\n    this.gpgpu = gpgpu;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0; // How many bytes that have been allocated\n    // are available for reuse.\n\n    this.freeTextures = {};\n    this.logEnabled = false;\n    this.usedTextures = {};\n  }\n\n  acquireTexture(shapeRC, usage, isPacked) {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this._numBytesFree -= texBytes;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n\n    let newTexture;\n\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n\n    this.usedTextures[shapeKey].push(newTexture);\n    this.numUsedTextures++;\n    this._numBytesAllocated += texBytes;\n    this.log();\n    return newTexture;\n  }\n\n  releaseTexture(texture, shape, logicalTexType, isPacked) {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n\n    const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n    const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n\n    if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {\n      this.gpgpu.deleteMatrixTexture(texture.texture);\n      this._numBytesAllocated -= texBytes;\n    } else {\n      this.freeTextures[shapeKey].push(texture);\n      this.numFreeTextures++;\n      this._numBytesFree += texBytes;\n    }\n\n    this.numUsedTextures--;\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n\n    if (texIndex < 0) {\n      throw new Error('Cannot release a texture that was never provided by this ' + 'texture manager');\n    }\n\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n\n  log() {\n    if (!this.logEnabled) {\n      return;\n    }\n\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n    const freeRatio = this._numBytesFree / this._numBytesAllocated;\n    console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n    console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);\n  }\n\n  get numBytesAllocated() {\n    return this._numBytesAllocated;\n  }\n\n  get numBytesFree() {\n    return this._numBytesFree;\n  }\n\n  getNumUsedTextures() {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures() {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0;\n  }\n\n}\n\nfunction numBytesForInternalFormat(gl, internalFormat) {\n  // tslint:disable-next-line:no-any\n  const glany = gl;\n\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  } else if (internalFormat === glany.RGBA8) {\n    return 4;\n  }\n\n  throw new Error(`Unknown internal format ${internalFormat}`);\n}\n\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n  let numElements;\n\n  if (isPacked) {\n    const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = packedWidth * packedHeight;\n  } else {\n    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = width * height;\n  }\n\n  const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n\n    default:\n      throw new Error(`Unknown physical texture type ${physicalTexType}`);\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}","map":{"version":3,"mappings":"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","names":["env","getInternalFormatForFloat16MatrixTexture","getInternalFormatForFloat16PackedMatrixTexture","getInternalFormatForFloat32MatrixTexture","getInternalFormatForPackedMatrixTexture","getInternalFormatForUnsignedBytesMatrixTexture","getPackedMatrixTextureShapeWidthHeight","getUnpackedMatrixTextureShapeWidthHeight","PhysicalTextureType","TextureUsage","TextureManager","constructor","gpgpu","acquireTexture","shapeRC","usage","isPacked","physicalTexType","getPhysicalFromLogicalTextureType","shapeKey","getKeyFromTextureShape","freeTextures","usedTextures","texBytes","computeBytes","gl","textureConfig","length","numFreeTextures","numUsedTextures","_numBytesFree","log","newTexture","shift","push","PACKED_2X2_FLOAT32","createPackedMatrixTexture","PACKED_2X2_FLOAT16","createFloat16PackedMatrixTexture","UNPACKED_FLOAT32","createFloat32MatrixTexture","UNPACKED_FLOAT16","createFloat16MatrixTexture","PACKED_4X1_UNSIGNED_BYTE","createUnsignedBytesMatrixTexture","_numBytesAllocated","releaseTexture","texture","shape","logicalTexType","deleteTexThreshold","get","deleteMatrixTexture","texList","texIndex","indexOf","Error","splice","logEnabled","total","console","freeRatio","Math","round","numBytesAllocated","numBytesFree","getNumUsedTextures","getNumFreeTextures","dispose","texShape","forEach","tex","numBytesForInternalFormat","internalFormat","glany","R32F","R16F","RGBA32F","RGBA","RGBA16F","RGBA8","internalFormatForPhysicalTexType","numElements","packedWidth","packedHeight","width","height","bytesPerElement","getPhysicalTextureForRendering","getBool","UPLOAD","RENDER","DOWNLOAD","PIXELS","shapeRowsCol"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-webgl/src/texture_manager.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport {getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture} from './gpgpu_util';\nimport {getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, Texture, TextureConfig, TextureUsage} from './tex_util';\n\nexport class TextureManager {\n  private numUsedTextures = 0;\n  private numFreeTextures = 0;\n  private _numBytesAllocated = 0;\n  private _numBytesFree = 0;  // How many bytes that have been allocated\n                              // are available for reuse.\n  private freeTextures: {[shape: string]: Texture[]} = {};\n  private logEnabled = false;\n  private usedTextures: {[shape: string]: Texture[]} = {};\n\n  constructor(private gpgpu: GPGPUContext) {}\n\n  acquireTexture(\n      shapeRC: [number, number], usage: TextureUsage,\n      isPacked: boolean): Texture {\n    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n\n    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n    if (!(shapeKey in this.usedTextures)) {\n      this.usedTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n\n    if (this.freeTextures[shapeKey].length > 0) {\n      this.numFreeTextures--;\n      this.numUsedTextures++;\n      this._numBytesFree -= texBytes;\n      this.log();\n      const newTexture = this.freeTextures[shapeKey].shift();\n      this.usedTextures[shapeKey].push(newTexture);\n      return newTexture;\n    }\n\n    let newTexture: Texture;\n    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n      newTexture =\n          this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n      newTexture =\n          this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n    } else if (\n        physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n      newTexture =\n          this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n    }\n    this.usedTextures[shapeKey].push(newTexture);\n\n    this.numUsedTextures++;\n    this._numBytesAllocated += texBytes;\n    this.log();\n\n    return newTexture;\n  }\n\n  releaseTexture(\n      texture: Texture, shape: [number, number], logicalTexType: TextureUsage,\n      isPacked: boolean): void {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    const physicalTexType =\n        getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n    if (!(shapeKey in this.freeTextures)) {\n      this.freeTextures[shapeKey] = [];\n    }\n\n    const texBytes = computeBytes(\n        shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig,\n        isPacked);\n    const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n    if (deleteTexThreshold !== -1 &&\n        this._numBytesAllocated > deleteTexThreshold) {\n      this.gpgpu.deleteMatrixTexture(texture.texture);\n      this._numBytesAllocated -= texBytes;\n    } else {\n      this.freeTextures[shapeKey].push(texture);\n      this.numFreeTextures++;\n      this._numBytesFree += texBytes;\n    }\n\n    this.numUsedTextures--;\n\n    const texList = this.usedTextures[shapeKey];\n    const texIndex = texList.indexOf(texture);\n    if (texIndex < 0) {\n      throw new Error(\n          'Cannot release a texture that was never provided by this ' +\n          'texture manager');\n    }\n    texList.splice(texIndex, 1);\n    this.log();\n  }\n\n  private log() {\n    if (!this.logEnabled) {\n      return;\n    }\n    const total = this.numFreeTextures + this.numUsedTextures;\n    console.log(\n        'Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`,\n        `(${total})`);\n    const freeRatio = this._numBytesFree / this._numBytesAllocated;\n    console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n    console.log(`Bytes unused: ${this._numBytesFree} (${\n        Math.round(100 * freeRatio)}%)`);\n  }\n\n  get numBytesAllocated(): number {\n    return this._numBytesAllocated;\n  }\n\n  get numBytesFree(): number {\n    return this._numBytesFree;\n  }\n\n  getNumUsedTextures(): number {\n    return this.numUsedTextures;\n  }\n\n  getNumFreeTextures(): number {\n    return this.numFreeTextures;\n  }\n\n  dispose() {\n    if (this.freeTextures == null) {\n      // Already disposed.\n      return;\n    }\n    for (const texShape in this.freeTextures) {\n      this.freeTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n    for (const texShape in this.usedTextures) {\n      this.usedTextures[texShape].forEach(tex => {\n        this.gpgpu.deleteMatrixTexture(tex.texture);\n      });\n    }\n    this.freeTextures = null;\n    this.usedTextures = null;\n    this.numUsedTextures = 0;\n    this.numFreeTextures = 0;\n    this._numBytesAllocated = 0;\n    this._numBytesFree = 0;\n  }\n}\n\nfunction numBytesForInternalFormat(\n    gl: WebGLRenderingContext, internalFormat: number): number {\n  // tslint:disable-next-line:no-any\n  const glany = gl as any;\n  if (internalFormat === glany.R32F) {\n    return 4;\n  } else if (internalFormat === glany.R16F) {\n    return 2;\n  } else if (internalFormat === glany.RGBA32F) {\n    return 16;\n  } else if (internalFormat === gl.RGBA) {\n    return 16;\n  } else if (internalFormat === glany.RGBA16F) {\n    return 8;\n  } else if (internalFormat === glany.RGBA8) {\n    return 4;\n  }\n  throw new Error(`Unknown internal format ${internalFormat}`);\n}\n\nexport function computeBytes(\n    shape: [number, number], physicalTexType: PhysicalTextureType,\n    gl: WebGLRenderingContext, textureConfig: TextureConfig,\n    isPacked: boolean): number {\n  // It is not possible to infer packed status from the texture type because\n  // depending on the textureConfig, different  texture types may resolve to the\n  // same internal format (e.g. in WebGL1, the internal format for\n  // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n  // explicitly.\n  const internalFormat =\n      internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n\n  let numElements: number;\n  if (isPacked) {\n    const [packedWidth, packedHeight] =\n        getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = packedWidth * packedHeight;\n\n  } else {\n    const [width, height] =\n        getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n    numElements = width * height;\n  }\n\n  const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n  return numElements * bytesPerElement;\n}\n\nfunction internalFormatForPhysicalTexType(\n    physicalTexType: PhysicalTextureType,\n    textureConfig: TextureConfig): number {\n  switch (physicalTexType) {\n    case PhysicalTextureType.PACKED_2X2_FLOAT32:\n      return getInternalFormatForPackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_2X2_FLOAT16:\n      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT32:\n      return getInternalFormatForFloat32MatrixTexture(textureConfig);\n    case PhysicalTextureType.UNPACKED_FLOAT16:\n      return getInternalFormatForFloat16MatrixTexture(textureConfig);\n    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n    default:\n      throw new Error(`Unknown physical texture type ${physicalTexType}`);\n  }\n}\n\nfunction getPhysicalTextureForRendering(isPacked: boolean):\n    PhysicalTextureType {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n    if (isPacked) {\n      return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT32;\n  }\n\n  if (isPacked) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT16;\n  }\n  return PhysicalTextureType.UNPACKED_FLOAT16;\n}\n\nfunction getPhysicalFromLogicalTextureType(\n    logicalTexType: TextureUsage, isPacked: boolean): PhysicalTextureType {\n  if (logicalTexType === TextureUsage.UPLOAD) {\n    return PhysicalTextureType.PACKED_2X2_FLOAT32;\n  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n    return getPhysicalTextureForRendering(isPacked);\n  } else if (\n      logicalTexType === TextureUsage.DOWNLOAD ||\n      logicalTexType === TextureUsage.PIXELS) {\n    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  }\n  throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\n\nfunction getKeyFromTextureShape(\n    shapeRowsCol: [number, number], physicalTexType: PhysicalTextureType,\n    isPacked: boolean): string {\n  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n"]},"metadata":{},"sourceType":"module"}