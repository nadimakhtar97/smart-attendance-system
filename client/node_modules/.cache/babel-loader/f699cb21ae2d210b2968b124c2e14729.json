{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\n\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n\n    if (strides == null) {\n      strides = [1, 1];\n    }\n\n    if (padding == null) {\n      padding = 'valid';\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (poolMode == null) {\n      poolMode = 'max';\n    } // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n\n\n    x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool( // TODO(cais): Rank check?\n      x, poolSize, strides, paddingString);\n    }\n\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n    }\n\n    return y;\n  });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\n\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n\n    if (padding == null) {\n      padding = 'valid';\n    }\n\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n\n    if (poolMode == null) {\n      poolMode = 'max';\n    } // x is NDHWC after preprocessing.\n\n\n    x = preprocessConv3DInput(x, dataFormat);\n    let y;\n    const paddingString = padding === 'same' ? 'same' : 'valid';\n\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {\n      // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n    }\n\n    return y;\n  });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\n\nexport class Pooling1D extends Layer {\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n\n    super(args);\n\n    if (typeof args.poolSize === 'number') {\n      this.poolSize = [args.poolSize];\n    } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === 'number') {\n      this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.poolSize)}`);\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        this.strides = [args.strides];\n      } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === 'number') {\n        this.strides = args.strides;\n      } else {\n        throw new ValueError(`strides for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.strides)}`);\n      }\n    }\n\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n    return [inputShape[0], length, inputShape[2]];\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs); // Add dummy last dimension.\n\n      inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n      const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, 'channelsLast'); // Remove dummy last dimension.\n\n      return tfc.squeeze(output, [2]);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport class AveragePooling1D extends Pooling1D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\n\nexport class Pooling2D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` + `it is expected to have a length of 2, but received length ` + `${args.strides.length}.`);\n      }\n\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides];\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n    cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport class AveragePooling2D extends Pooling2D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\n\nexport class Pooling3D extends Layer {\n  constructor(args) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];\n\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` + `it is expected to have a length of 3, but received length ` + `${args.strides.length}.`);\n      }\n\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides, args.strides];\n    }\n\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({\n      ndim: 5\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    let depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    let cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n    depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n    rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n    cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], depths, rows, cols];\n    } else {\n      return [inputShape[0], depths, rows, cols, inputShape[4]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig() {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class MaxPooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n\n}\n/** @nocollapse */\n\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport class AveragePooling3D extends Pooling3D {\n  constructor(args) {\n    super(args);\n  }\n\n  poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n\n}\n/** @nocollapse */\n\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\n\nexport class GlobalPooling1D extends Layer {\n  constructor(args) {\n    super(args);\n    this.inputSpec = [new InputSpec({\n      ndim: 3\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    return [inputShape[0], inputShape[2]];\n  }\n\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n\n}\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.mean(input, 1);\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n  constructor(args) {\n    super(args || {});\n  }\n\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.max(input, 1);\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\n\nexport class GlobalPooling2D extends Layer {\n  constructor(args) {\n    super(args);\n    this.dataFormat = args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    this.inputSpec = [new InputSpec({\n      ndim: 4\n    })];\n  }\n\n  computeOutputShape(inputShape) {\n    inputShape = inputShape;\n\n    if (this.dataFormat === 'channelsLast') {\n      return [inputShape[0], inputShape[3]];\n    } else {\n      return [inputShape[0], inputShape[1]];\n    }\n  }\n\n  call(inputs, kwargs) {\n    throw new NotImplementedError();\n  }\n\n  getConfig() {\n    const config = {\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n\n}\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.mean(input, [1, 2]);\n      } else {\n        return tfc.mean(input, [2, 3]);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.max(input, [1, 2]);\n      } else {\n        return tfc.max(input, [2, 3]);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);","map":{"version":3,"mappings":"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","names":["tfc","serialization","tidy","imageDataFormat","K","checkDataFormat","checkPaddingMode","checkPoolMode","InputSpec","Layer","NotImplementedError","ValueError","convOutputLength","assertPositiveInteger","getExactlyOneShape","getExactlyOneTensor","preprocessConv2DInput","preprocessConv3DInput","pool2d","x","poolSize","strides","padding","dataFormat","poolMode","y","paddingString","maxPool","avgPool","transpose","pool3d","maxPool3d","avgPool3d","Pooling1D","constructor","args","Array","isArray","length","JSON","stringify","inputSpec","ndim","computeOutputShape","inputShape","call","inputs","kwargs","invokeCallHook","expandDims","output","poolingFunction","squeeze","getConfig","config","baseConfig","Object","assign","MaxPooling1D","registerClass","AveragePooling1D","Pooling2D","rows","cols","MaxPooling2D","AveragePooling2D","Pooling3D","depths","MaxPooling3D","AveragePooling3D","GlobalPooling1D","GlobalAveragePooling1D","input","mean","GlobalMaxPooling1D","max","GlobalPooling2D","GlobalAveragePooling2D","GlobalMaxPooling2D"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-layers/src/layers/pooling.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\n\nimport * as tfc from '@tensorflow/tfjs-core';\nimport {serialization, Tensor, Tensor3D, Tensor4D, Tensor5D, tidy} from '@tensorflow/tfjs-core';\n\nimport {imageDataFormat} from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport {checkDataFormat, checkPaddingMode, checkPoolMode} from '../common';\nimport {InputSpec} from '../engine/topology';\nimport {Layer, LayerArgs} from '../engine/topology';\nimport {NotImplementedError, ValueError} from '../errors';\nimport {DataFormat, PaddingMode, PoolMode, Shape} from '../keras_format/common';\nimport {Kwargs} from '../types';\nimport {convOutputLength} from '../utils/conv_utils';\nimport {assertPositiveInteger} from '../utils/generic_utils';\nimport {getExactlyOneShape, getExactlyOneTensor} from '../utils/types_utils';\n\nimport {preprocessConv2DInput, preprocessConv3DInput} from './convolutional';\n\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\nexport function pool2d(\n    x: Tensor, poolSize: [number, number], strides?: [number, number],\n    padding?: PaddingMode, dataFormat?: DataFormat,\n    poolMode?: PoolMode): Tensor {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n\n    // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n    // dataFormat as an input argument.\n    x = preprocessConv2DInput(x, dataFormat);  // x is NHWC after preprocessing.\n    let y: Tensor;\n    const paddingString = (padding === 'same') ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      // TODO(cais): Rank check?\n      y = tfc.maxPool(x as Tensor4D, poolSize, strides, paddingString);\n    } else {  // 'avg'\n      // TODO(cais): Check the dtype and rank of x and give clear error message\n      //   if those are incorrect.\n      y = tfc.avgPool(\n          // TODO(cais): Rank check?\n          x as Tensor3D | Tensor4D, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 3, 1, 2]);  // NHWC -> NCHW.\n    }\n    return y;\n  });\n}\n\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\nexport function pool3d(\n    x: Tensor5D, poolSize: [number, number, number],\n    strides?: [number, number, number], padding?: PaddingMode,\n    dataFormat?: DataFormat, poolMode?: PoolMode): Tensor {\n  return tidy(() => {\n    checkDataFormat(dataFormat);\n    checkPoolMode(poolMode);\n    checkPaddingMode(padding);\n    if (strides == null) {\n      strides = [1, 1, 1];\n    }\n    if (padding == null) {\n      padding = 'valid';\n    }\n    if (dataFormat == null) {\n      dataFormat = imageDataFormat();\n    }\n    if (poolMode == null) {\n      poolMode = 'max';\n    }\n\n    // x is NDHWC after preprocessing.\n    x = preprocessConv3DInput(x as Tensor, dataFormat) as Tensor5D;\n    let y: Tensor;\n    const paddingString = (padding === 'same') ? 'same' : 'valid';\n    if (poolMode === 'max') {\n      y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n    } else {  // 'avg'\n      y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n    }\n    if (dataFormat === 'channelsFirst') {\n      y = tfc.transpose(y, [0, 4, 1, 2, 3]);  // NDHWC -> NCDHW.\n    }\n    return y;\n  });\n}\n\nexport declare interface Pooling1DLayerArgs extends LayerArgs {\n  /**\n   * Size of the window to pool over, should be an integer.\n   */\n  poolSize?: number|[number];\n  /**\n   * Period at which to sample the pooled values.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number];\n  /** How to fill in data that's not an integer multiple of poolSize. */\n  padding?: PaddingMode;\n}\n\n/**\n * Abstract class for different pooling 1D layers.\n */\nexport abstract class Pooling1D extends Layer {\n  protected readonly poolSize: [number];\n  protected readonly strides: [number];\n  protected readonly padding: PaddingMode;\n\n  /**\n   *\n   * @param args Parameters for the Pooling layer.\n   *\n   * config.poolSize defaults to 2.\n   */\n  constructor(args: Pooling1DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = 2;\n    }\n    super(args);\n    if (typeof args.poolSize === 'number') {\n      this.poolSize = [args.poolSize];\n    } else if (\n        Array.isArray(args.poolSize) &&\n        (args.poolSize as number[]).length === 1 &&\n        typeof (args.poolSize as number[])[0] === 'number') {\n      this.poolSize = args.poolSize;\n    } else {\n      throw new ValueError(\n          `poolSize for 1D convolutional layer must be a number or an ` +\n          `Array of a single number, but received ` +\n          `${JSON.stringify(args.poolSize)}`);\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else {\n      if (typeof args.strides === 'number') {\n        this.strides = [args.strides];\n      } else if (\n          Array.isArray(args.strides) &&\n          (args.strides as number[]).length === 1 &&\n          typeof (args.strides as number[])[0] === 'number') {\n        this.strides = args.strides;\n      } else {\n        throw new ValueError(\n            `strides for 1D convolutional layer must be a number or an ` +\n            `Array of a single number, but received ` +\n            `${JSON.stringify(args.strides)}`);\n      }\n    }\n    assertPositiveInteger(this.strides, 'strides');\n\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    checkPaddingMode(this.padding);\n    this.inputSpec = [new InputSpec({ndim: 3})];\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    const length = convOutputLength(\n        inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n    return [inputShape[0], length, inputShape[2]];\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor;\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      // Add dummy last dimension.\n      inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n      const output = this.poolingFunction(\n          getExactlyOneTensor(inputs), [this.poolSize[0], 1],\n          [this.strides[0], 1], this.padding, 'channelsLast');\n      // Remove dummy last dimension.\n      return tfc.squeeze(output, [2]);\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling1D extends Pooling1D {\n  /** @nocollapse */\n  static className = 'MaxPooling1D';\n  constructor(args: Pooling1DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling1D);\n\nexport class AveragePooling1D extends Pooling1D {\n  /** @nocollapse */\n  static className = 'AveragePooling1D';\n  constructor(args: Pooling1DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling1D);\n\nexport declare interface Pooling2DLayerArgs extends LayerArgs {\n  /**\n   * Factors by which to downscale in each dimension [vertical, horizontal].\n   * Expects an integer or an array of 2 integers.\n   *\n   * For example, `[2, 2]` will halve the input in both spatial dimension.\n   * If only one integer is specified, the same window length\n   * will be used for both dimensions.\n   */\n  poolSize?: number|[number, number];\n\n  /**\n   * The size of the stride in each dimension of the pooling window. Expects\n   * an integer or an array of 2 integers. Integer, tuple of 2 integers, or\n   * None.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number, number];\n\n  /** The padding type to use for the pooling layer. */\n  padding?: PaddingMode;\n  /** The data format to use for the pooling layer. */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different pooling 2D layers.\n */\nexport abstract class Pooling2D extends Layer {\n  protected readonly poolSize: [number, number];\n  protected readonly strides: [number, number];\n  protected readonly padding: PaddingMode;\n  protected readonly dataFormat: DataFormat;\n\n  constructor(args: Pooling2DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ?\n        args.poolSize :\n        [args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 2) {\n        throw new ValueError(\n            `If the strides property of a 2D pooling layer is an Array, ` +\n            `it is expected to have a length of 2, but received length ` +\n            `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n\n    this.inputSpec = [new InputSpec({ndim: 4})];\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    let rows =\n        this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let cols =\n        this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    rows =\n        convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n    cols =\n        convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], rows, cols];\n    } else {\n      return [inputShape[0], rows, cols, inputShape[3]];\n    }\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor;\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(\n          getExactlyOneTensor(inputs), this.poolSize, this.strides,\n          this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling2D extends Pooling2D {\n  /** @nocollapse */\n  static className = 'MaxPooling2D';\n  constructor(args: Pooling2DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling2D);\n\nexport class AveragePooling2D extends Pooling2D {\n  /** @nocollapse */\n  static className = 'AveragePooling2D';\n  constructor(args: Pooling2DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number], strides: [number, number],\n      padding: PaddingMode, dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling2D);\n\nexport declare interface Pooling3DLayerArgs extends LayerArgs {\n  /**\n   * Factors by which to downscale in each dimension [depth, height, width].\n   * Expects an integer or an array of 3 integers.\n   *\n   * For example, `[2, 2, 2]` will halve the input in three dimensions.\n   * If only one integer is specified, the same window length\n   * will be used for all dimensions.\n   */\n  poolSize?: number|[number, number, number];\n\n  /**\n   * The size of the stride in each dimension of the pooling window. Expects\n   * an integer or an array of 3 integers. Integer, tuple of 3 integers, or\n   * None.\n   *\n   * If `null`, defaults to `poolSize`.\n   */\n  strides?: number|[number, number, number];\n\n  /** The padding type to use for the pooling layer. */\n  padding?: PaddingMode;\n  /** The data format to use for the pooling layer. */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different pooling 3D layers.\n */\nexport abstract class Pooling3D extends Layer {\n  protected readonly poolSize: [number, number, number];\n  protected readonly strides: [number, number, number];\n  protected readonly padding: PaddingMode;\n  protected readonly dataFormat: DataFormat;\n\n  constructor(args: Pooling3DLayerArgs) {\n    if (args.poolSize == null) {\n      args.poolSize = [2, 2, 2];\n    }\n    super(args);\n    this.poolSize = Array.isArray(args.poolSize) ?\n        args.poolSize :\n        [args.poolSize, args.poolSize, args.poolSize];\n    if (args.strides == null) {\n      this.strides = this.poolSize;\n    } else if (Array.isArray(args.strides)) {\n      if (args.strides.length !== 3) {\n        throw new ValueError(\n            `If the strides property of a 3D pooling layer is an Array, ` +\n            `it is expected to have a length of 3, but received length ` +\n            `${args.strides.length}.`);\n      }\n      this.strides = args.strides;\n    } else {\n      // `config.strides` is a number.\n      this.strides = [args.strides, args.strides, args.strides];\n    }\n    assertPositiveInteger(this.poolSize, 'poolSize');\n    assertPositiveInteger(this.strides, 'strides');\n    this.padding = args.padding == null ? 'valid' : args.padding;\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    checkPaddingMode(this.padding);\n\n    this.inputSpec = [new InputSpec({ndim: 5})];\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = getExactlyOneShape(inputShape);\n    let depths =\n        this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n    let rows =\n        this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n    let cols =\n        this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n    depths = convOutputLength(\n        depths, this.poolSize[0], this.padding, this.strides[0]);\n    rows =\n        convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n    cols =\n        convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n    if (this.dataFormat === 'channelsFirst') {\n      return [inputShape[0], inputShape[1], depths, rows, cols];\n    } else {\n      return [inputShape[0], depths, rows, cols, inputShape[4]];\n    }\n  }\n\n  protected abstract poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor;\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      this.invokeCallHook(inputs, kwargs);\n      return this.poolingFunction(\n          getExactlyOneTensor(inputs), this.poolSize, this.strides,\n          this.padding, this.dataFormat);\n    });\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config = {\n      poolSize: this.poolSize,\n      padding: this.padding,\n      strides: this.strides,\n      dataFormat: this.dataFormat\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class MaxPooling3D extends Pooling3D {\n  /** @nocollapse */\n  static className = 'MaxPooling3D';\n  constructor(args: Pooling3DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(\n        inputs as Tensor5D, poolSize, strides, padding, dataFormat, 'max');\n  }\n}\nserialization.registerClass(MaxPooling3D);\n\nexport class AveragePooling3D extends Pooling3D {\n  /** @nocollapse */\n  static className = 'AveragePooling3D';\n  constructor(args: Pooling3DLayerArgs) {\n    super(args);\n  }\n\n  protected poolingFunction(\n      inputs: Tensor, poolSize: [number, number, number],\n      strides: [number, number, number], padding: PaddingMode,\n      dataFormat: DataFormat): Tensor {\n    checkDataFormat(dataFormat);\n    checkPaddingMode(padding);\n    return pool3d(\n        inputs as Tensor5D, poolSize, strides, padding, dataFormat, 'avg');\n  }\n}\nserialization.registerClass(AveragePooling3D);\n\n/**\n * Abstract class for different global pooling 1D layers.\n */\nexport abstract class GlobalPooling1D extends Layer {\n  constructor(args: LayerArgs) {\n    super(args);\n    this.inputSpec = [new InputSpec({ndim: 3})];\n  }\n\n  computeOutputShape(inputShape: Shape): Shape {\n    return [inputShape[0], inputShape[2]];\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    throw new NotImplementedError();\n  }\n}\n\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n  /** @nocollapse */\n  static className = 'GlobalAveragePooling1D';\n  constructor(args?: LayerArgs) {\n    super(args || {});\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.mean(input, 1);\n    });\n  }\n}\nserialization.registerClass(GlobalAveragePooling1D);\n\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n  /** @nocollapse */\n  static className = 'GlobalMaxPooling1D';\n  constructor(args: LayerArgs) {\n    super(args || {});\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      return tfc.max(input, 1);\n    });\n  }\n}\nserialization.registerClass(GlobalMaxPooling1D);\n\nexport declare interface GlobalPooling2DLayerArgs extends LayerArgs {\n  /**\n   * One of `CHANNEL_LAST` (default) or `CHANNEL_FIRST`.\n   *\n   * The ordering of the dimensions in the inputs. `CHANNEL_LAST` corresponds\n   * to inputs with shape `[batch, height, width, channels[` while\n   * `CHANNEL_FIRST` corresponds to inputs with shape\n   * `[batch, channels, height, width]`.\n   */\n  dataFormat?: DataFormat;\n}\n\n/**\n * Abstract class for different global pooling 2D layers.\n */\nexport abstract class GlobalPooling2D extends Layer {\n  protected dataFormat: DataFormat;\n  constructor(args: GlobalPooling2DLayerArgs) {\n    super(args);\n    this.dataFormat =\n        args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n    checkDataFormat(this.dataFormat);\n    this.inputSpec = [new InputSpec({ndim: 4})];\n  }\n\n  computeOutputShape(inputShape: Shape|Shape[]): Shape|Shape[] {\n    inputShape = inputShape as Shape;\n    if (this.dataFormat === 'channelsLast') {\n      return [inputShape[0], inputShape[3]];\n    } else {\n      return [inputShape[0], inputShape[1]];\n    }\n  }\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    throw new NotImplementedError();\n  }\n\n  getConfig(): serialization.ConfigDict {\n    const config = {dataFormat: this.dataFormat};\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n}\n\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n  /** @nocollapse */\n  static className = 'GlobalAveragePooling2D';\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.mean(input, [1, 2]);\n      } else {\n        return tfc.mean(input, [2, 3]);\n      }\n    });\n  }\n}\nserialization.registerClass(GlobalAveragePooling2D);\n\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n  /** @nocollapse */\n  static className = 'GlobalMaxPooling2D';\n\n  call(inputs: Tensor|Tensor[], kwargs: Kwargs): Tensor|Tensor[] {\n    return tidy(() => {\n      const input = getExactlyOneTensor(inputs);\n      if (this.dataFormat === 'channelsLast') {\n        return tfc.max(input, [1, 2]);\n      } else {\n        return tfc.max(input, [2, 3]);\n      }\n    });\n  }\n}\nserialization.registerClass(GlobalMaxPooling2D);\n"]},"metadata":{},"sourceType":"module"}