{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport { VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES } from './keras_format/common';\nimport { checkStringTypeUnionValue } from './utils/generic_utils'; // A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\n\nconst nameMap = new Map();\nexport function checkDataFormat(value) {\n  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\nexport function checkInterpolationFormat(value) {\n  checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\nexport function checkPaddingMode(value) {\n  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\nexport function checkPoolMode(value) {\n  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\nconst _nameScopeStack = [];\nconst _nameScopeDivider = '/';\n/**\n * Enter namescope, which can be nested.\n */\n\nexport function nameScope(name, fn) {\n  _nameScopeStack.push(name);\n\n  try {\n    const val = fn();\n\n    _nameScopeStack.pop();\n\n    return val;\n  } catch (e) {\n    _nameScopeStack.pop();\n\n    throw e;\n  }\n}\n/**\n * Get the current namescope as a flat, concatenated string.\n */\n\nfunction currentNameScopePrefix() {\n  if (_nameScopeStack.length === 0) {\n    return '';\n  } else {\n    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n  }\n}\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\n\n\nexport function getScopedTensorName(tensorName) {\n  if (!isValidTensorName(tensorName)) {\n    throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n  }\n\n  return currentNameScopePrefix() + tensorName;\n}\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\n\nexport function getUniqueTensorName(scopedName) {\n  if (!isValidTensorName(scopedName)) {\n    throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n  }\n\n  if (!nameMap.has(scopedName)) {\n    nameMap.set(scopedName, 0);\n  }\n\n  const index = nameMap.get(scopedName);\n  nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n\n  if (index > 0) {\n    const result = `${scopedName}_${index}`; // Mark the composed name as used in case someone wants\n    // to call getUniqueTensorName(\"name_1\").\n\n    nameMap.set(result, 1);\n    return result;\n  } else {\n    return scopedName;\n  }\n}\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\n\nexport function isValidTensorName(name) {\n  return !!name.match(tensorNameRegex);\n}","map":{"version":3,"mappings":"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","names":["VALID_DATA_FORMAT_VALUES","VALID_INTERPOLATION_FORMAT_VALUES","VALID_PADDING_MODE_VALUES","VALID_POOL_MODE_VALUES","checkStringTypeUnionValue","nameMap","Map","checkDataFormat","value","checkInterpolationFormat","checkPaddingMode","checkPoolMode","_nameScopeStack","_nameScopeDivider","nameScope","name","fn","push","val","pop","e","currentNameScopePrefix","length","join","getScopedTensorName","tensorName","isValidTensorName","Error","getUniqueTensorName","scopedName","has","set","index","get","result","tensorNameRegex","RegExp","match"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-layers/src/common.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport {VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES} from './keras_format/common';\nimport {checkStringTypeUnionValue} from './utils/generic_utils';\n\n// A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\nconst nameMap: Map<string, number> = new Map<string, number>();\n\nexport function checkDataFormat(value?: string): void {\n  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\n\nexport function checkInterpolationFormat(value?: string): void {\n  checkStringTypeUnionValue(\n      VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\n\nexport function checkPaddingMode(value?: string): void {\n  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\n\nexport function checkPoolMode(value?: string): void {\n  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\n\nconst _nameScopeStack: string[] = [];\nconst _nameScopeDivider = '/';\n\n/**\n * Enter namescope, which can be nested.\n */\nexport function nameScope<T>(name: string, fn: () => T): T {\n  _nameScopeStack.push(name);\n  try {\n    const val: T = fn();\n    _nameScopeStack.pop();\n    return val;\n  } catch (e) {\n    _nameScopeStack.pop();\n    throw e;\n  }\n}\n\n/**\n * Get the current namescope as a flat, concatenated string.\n */\nfunction currentNameScopePrefix(): string {\n  if (_nameScopeStack.length === 0) {\n    return '';\n  } else {\n    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n  }\n}\n\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\nexport function getScopedTensorName(tensorName: string): string {\n  if (!isValidTensorName(tensorName)) {\n    throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n  }\n  return currentNameScopePrefix() + tensorName;\n}\n\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\nexport function getUniqueTensorName(scopedName: string): string {\n  if (!isValidTensorName(scopedName)) {\n    throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n  }\n  if (!nameMap.has(scopedName)) {\n    nameMap.set(scopedName, 0);\n  }\n  const index = nameMap.get(scopedName);\n  nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n\n  if (index > 0) {\n    const result = `${scopedName}_${index}`;\n    // Mark the composed name as used in case someone wants\n    // to call getUniqueTensorName(\"name_1\").\n    nameMap.set(result, 1);\n    return result;\n  } else {\n    return scopedName;\n  }\n}\n\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\nexport function isValidTensorName(name: string): boolean {\n  return !!name.match(tensorNameRegex);\n}\n"]},"metadata":{},"sourceType":"module"}