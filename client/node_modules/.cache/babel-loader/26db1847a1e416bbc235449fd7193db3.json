{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinearGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinearGrad(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    images,\n    dy\n  } = inputs;\n  const {\n    alignCorners\n  } = attrs;\n  assertNotComplex([dy, images], 'resizeBilinearGrad');\n  const imagesStrides = util.computeStrides(images.shape);\n  const [batch, xHeight, xWidth, depth] = images.shape;\n  const [, yHeight, yWidth] = dy.shape;\n  const output = new Float32Array(batch * xHeight * xWidth * depth); // In the backwards pass, we want to find the pixels that were generated\n  // for each pixel in the input image the forward pass and add the\n  // corresponding coefficient from dy to the gradient (with some\n  // interpolation).\n\n  const effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n  const effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n  const heightScale = effectiveXSize[0] / effectiveYSize[0];\n  const widthScale = effectiveXSize[1] / effectiveYSize[1]; // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n\n  const dyValues = backend.data.get(dy.dataId).values;\n  let offset = 0;\n\n  for (let b = 0; b < batch; b++) {\n    const bOffset = b * imagesStrides[0];\n\n    for (let r = 0; r < yHeight; r++) {\n      const dxR = r * heightScale;\n      const topDxRIndex = Math.floor(dxR);\n      const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n      const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n      const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n      const dxRLerp = dxR - topDxRIndex;\n      const inverseDxRLerp = 1.0 - dxRLerp;\n\n      for (let c = 0; c < yWidth; c++) {\n        const dxC = c * widthScale;\n        const leftDxCIndex = Math.floor(dxC);\n        const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n        const dxCLerp = dxC - leftDxCIndex;\n        const inverseDxCLerp = 1.0 - dxCLerp;\n        const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n        const topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];\n        const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];\n        const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];\n        const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n        const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n        const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n        const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n\n        for (let d = 0; d < depth; d++) {\n          const dyVal = dyValues[offset++];\n          output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;\n          output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n          output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n          output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo([batch, xWidth, xHeight, depth], 'float32', output);\n}\nexport const resizeBilinearGradConfig = {\n  kernelName: ResizeBilinearGrad,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinearGrad\n};","map":{"version":3,"mappings":"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","names":["ResizeBilinearGrad","util","assertNotComplex","resizeBilinearGrad","args","inputs","backend","attrs","images","dy","alignCorners","imagesStrides","computeStrides","shape","batch","xHeight","xWidth","depth","yHeight","yWidth","output","Float32Array","effectiveXSize","effectiveYSize","heightScale","widthScale","dyValues","data","get","dataId","values","offset","b","bOffset","r","dxR","topDxRIndex","Math","floor","bottomDxRIndex","min","ceil","topDxROffset","bottomDxROffset","dxRLerp","inverseDxRLerp","c","dxC","leftDxCIndex","rightDxCIndex","dxCLerp","inverseDxCLerp","topLeftRCOffset","topRightRCOffset","bottomLeftRCOffset","bottomRightRCOffset","inverseDxRLerpTimesInverseDxCLerp","inverseDxRLerpTimesDxCLerp","dxRLerpTimesInverseDxCLerp","dxRLerpTimesDxCLerp","d","dyVal","makeTensorInfo","resizeBilinearGradConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/ResizeBilinearGrad.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, ResizeBilinearGrad, ResizeBilinearGradAttrs, ResizeBilinearGradInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function resizeBilinearGrad(args: {\n  inputs: ResizeBilinearGradInputs,\n  backend: MathBackendCPU,\n  attrs: ResizeBilinearGradAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images, dy} = inputs;\n  const {alignCorners} = attrs;\n\n  assertNotComplex([dy, images], 'resizeBilinearGrad');\n\n  const imagesStrides = util.computeStrides(images.shape);\n\n  const [batch, xHeight, xWidth, depth] = images.shape;\n  const [, yHeight, yWidth] = dy.shape;\n\n  const output = new Float32Array(batch * xHeight * xWidth * depth);\n\n  // In the backwards pass, we want to find the pixels that were generated\n  // for each pixel in the input image the forward pass and add the\n  // corresponding coefficient from dy to the gradient (with some\n  // interpolation).\n\n  const effectiveXSize: [number, number] = [\n    (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n    (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n  ];\n\n  const effectiveYSize: [number, number] = [\n    (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n    (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n  ];\n\n  const heightScale = effectiveXSize[0] / effectiveYSize[0];\n  const widthScale = effectiveXSize[1] / effectiveYSize[1];\n\n  // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n  const dyValues = backend.data.get(dy.dataId).values as TypedArray;\n  let offset = 0;\n  for (let b = 0; b < batch; b++) {\n    const bOffset = b * imagesStrides[0];\n    for (let r = 0; r < yHeight; r++) {\n      const dxR = r * heightScale;\n      const topDxRIndex = Math.floor(dxR);\n      const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n\n      const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n      const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n\n      const dxRLerp = dxR - topDxRIndex;\n      const inverseDxRLerp = 1.0 - dxRLerp;\n      for (let c = 0; c < yWidth; c++) {\n        const dxC = c * widthScale;\n        const leftDxCIndex = Math.floor(dxC);\n        const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n        const dxCLerp = dxC - leftDxCIndex;\n        const inverseDxCLerp = 1.0 - dxCLerp;\n\n        const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n        const topRightRCOffset =\n            topDxROffset + rightDxCIndex * imagesStrides[2];\n        const bottomLeftRCOffset =\n            bottomDxROffset + leftDxCIndex * imagesStrides[2];\n        const bottomRightRCOffset =\n            bottomDxROffset + rightDxCIndex * imagesStrides[2];\n\n        const inverseDxRLerpTimesInverseDxCLerp =\n            inverseDxRLerp * inverseDxCLerp;\n        const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n        const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n        const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n        for (let d = 0; d < depth; d++) {\n          const dyVal = dyValues[offset++];\n          output[topLeftRCOffset + d] +=\n              dyVal * inverseDxRLerpTimesInverseDxCLerp;\n          output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n          output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n          output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(\n      [batch, xWidth, xHeight, depth], 'float32', output);\n}\n\nexport const resizeBilinearGradConfig: KernelConfig = {\n  kernelName: ResizeBilinearGrad,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinearGrad as {} as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module"}