{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeNearestNeighbor, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeNearestNeighbor(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    images\n  } = inputs;\n  const {\n    alignCorners,\n    halfPixelCenters,\n    size\n  } = attrs;\n  assertNotComplex(images, 'resizeNearestNeighbor');\n  const imagesStrides = util.computeStrides(images.shape);\n  const [newHeight, newWidth] = size;\n  const [batch, oldHeight, oldWidth, numChannels] = images.shape;\n  const xValues = backend.data.get(images.dataId).values;\n  const output = new Float32Array(batch * newHeight * newWidth * numChannels);\n  const effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];\n  const effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];\n  const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n  const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n  let outputOffset = 0;\n\n  for (let b = 0; b < batch; b++) {\n    const batchOffset = b * imagesStrides[0];\n\n    for (let r = 0; r < newHeight; r++) {\n      const sourceFracRow = halfPixelCenters ? effectiveRowSizeRatio * (r + 0.5) : effectiveRowSizeRatio * r;\n      let sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n\n      if (halfPixelCenters) {\n        sourceNearestRow = Math.max(0, sourceNearestRow);\n      }\n\n      const rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];\n\n      for (let c = 0; c < newWidth; c++) {\n        const sourceFracCol = halfPixelCenters ? effectiveColSizeRatio * (c + 0.5) : effectiveColSizeRatio * c;\n        let sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));\n\n        if (halfPixelCenters) {\n          sourceNearestCol = Math.max(0, sourceNearestCol);\n        }\n\n        const colOffset = rowOffset + sourceNearestCol * imagesStrides[2];\n\n        for (let d = 0; d < numChannels; d++) {\n          // Begin shader.\n          // Compute the fractional index of the source.\n          const newVal = xValues[colOffset + d];\n          output[outputOffset++] = newVal;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], images.dtype, output);\n}\nexport const resizeNearestNeighborConfig = {\n  kernelName: ResizeNearestNeighbor,\n  backendName: 'cpu',\n  kernelFunc: resizeNearestNeighbor\n};","map":{"version":3,"mappings":"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","names":["ResizeNearestNeighbor","util","assertNotComplex","resizeNearestNeighbor","args","inputs","backend","attrs","images","alignCorners","halfPixelCenters","size","imagesStrides","computeStrides","shape","newHeight","newWidth","batch","oldHeight","oldWidth","numChannels","xValues","data","get","dataId","values","output","Float32Array","effectiveInputSize","effectiveOutputSize","effectiveRowSizeRatio","effectiveColSizeRatio","outputOffset","b","batchOffset","r","sourceFracRow","sourceNearestRow","Math","min","round","floor","max","rowOffset","c","sourceFracCol","sourceNearestCol","colOffset","d","newVal","makeTensorInfo","dtype","resizeNearestNeighborConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/ResizeNearestNeighbor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, ResizeNearestNeighbor, ResizeNearestNeighborAttrs, ResizeNearestNeighborInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function resizeNearestNeighbor(args: {\n  inputs: ResizeNearestNeighborInputs,\n  backend: MathBackendCPU,\n  attrs: ResizeNearestNeighborAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images} = inputs;\n  const {alignCorners, halfPixelCenters, size} = attrs;\n\n  assertNotComplex(images, 'resizeNearestNeighbor');\n\n  const imagesStrides = util.computeStrides(images.shape);\n  const [newHeight, newWidth] = size;\n\n  const [batch, oldHeight, oldWidth, numChannels] = images.shape;\n  const xValues = backend.data.get(images.dataId).values as TypedArray;\n  const output = new Float32Array(batch * newHeight * newWidth * numChannels);\n\n  const effectiveInputSize: [number, number] = [\n    (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n    (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n  ];\n\n  const effectiveOutputSize: [number, number] = [\n    (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n    (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n  ];\n\n  const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n  const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n\n  let outputOffset = 0;\n  for (let b = 0; b < batch; b++) {\n    const batchOffset = b * imagesStrides[0];\n    for (let r = 0; r < newHeight; r++) {\n      const sourceFracRow = halfPixelCenters ?\n          effectiveRowSizeRatio * (r + 0.5) :\n          effectiveRowSizeRatio * r;\n      let sourceNearestRow = Math.min(\n          oldHeight - 1,\n          alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n      if (halfPixelCenters) {\n        sourceNearestRow = Math.max(0, sourceNearestRow);\n      }\n      const rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];\n      for (let c = 0; c < newWidth; c++) {\n        const sourceFracCol = halfPixelCenters ?\n            effectiveColSizeRatio * (c + 0.5) :\n            effectiveColSizeRatio * c;\n        let sourceNearestCol = Math.min(\n            oldWidth - 1,\n            alignCorners ? Math.round(sourceFracCol) :\n                           Math.floor(sourceFracCol));\n        if (halfPixelCenters) {\n          sourceNearestCol = Math.max(0, sourceNearestCol);\n        }\n        const colOffset = rowOffset + sourceNearestCol * imagesStrides[2];\n        for (let d = 0; d < numChannels; d++) {\n          // Begin shader.\n          // Compute the fractional index of the source.\n          const newVal = xValues[colOffset + d];\n          output[outputOffset++] = newVal;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(\n      [batch, newHeight, newWidth, numChannels], images.dtype, output);\n}\n\nexport const resizeNearestNeighborConfig: KernelConfig = {\n  kernelName: ResizeNearestNeighbor,\n  backendName: 'cpu',\n  kernelFunc: resizeNearestNeighbor as {} as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module"}