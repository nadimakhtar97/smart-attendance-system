{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { BatchMatMul, broadcast_util, buffer, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { reshape } from './Reshape';\nexport function batchMatMul(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    a,\n    b\n  } = inputs;\n  const {\n    transposeA,\n    transposeB\n  } = attrs;\n  assertNotComplex([a, b], 'matMul');\n  const aRank = a.shape.length;\n  const bRank = b.shape.length;\n  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n  const outerDimsA = a.shape.slice(0, -2);\n  const outerDimsB = b.shape.slice(0, -2);\n  const batchDimA = util.sizeFromShape(outerDimsA);\n  const batchDimB = util.sizeFromShape(outerDimsB);\n  const outShapeOuterDims = broadcast_util.assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));\n  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n  util.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (` + `${innerShapeB}) of Tensors with shapes ${a.shape} and ` + `${b.shape} and transposeA=${transposeA}` + ` and transposeB=${transposeB} must match.`);\n  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];\n  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB]; // The rest of the implementation is designed to operate on rank-3 tensors\n\n  const a3d = reshape({\n    inputs: {\n      x: a\n    },\n    backend,\n    attrs: {\n      shape: a3dShape\n    }\n  });\n  const b3d = reshape({\n    inputs: {\n      x: b\n    },\n    backend,\n    attrs: {\n      shape: b3dShape\n    }\n  });\n  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n  const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];\n  const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];\n  const batchDim = Math.max(batchDimA, batchDimB);\n  const a3dValues = backend.data.get(a3d.dataId).values;\n  const b3dValues = backend.data.get(b3d.dataId).values;\n  const a3dStrides = util.computeStrides(a3d.shape);\n  const b3dStrides = util.computeStrides(b3d.shape);\n  const [aBatch, aOuterStep, aInnerStep] = transposeA ? [a3dStrides[0], 1, a3dStrides[1]] : [a3dStrides[0], a3dStrides[1], 1];\n  const [bInnerStep, bOuterStep, bBatch] = transposeB ? [1, b3dStrides[1], b3dStrides[0]] : [b3dStrides[1], 1, b3dStrides[0]];\n  const size = leftDim * rightDim;\n  const result = buffer([batchDim, leftDim, rightDim], a3d.dtype);\n  const resVals = result.values;\n  const blockSize = backend.blockSize;\n\n  for (let bi = 0; bi < batchDim; bi++) {\n    for (let i0 = 0; i0 < leftDim; i0 += blockSize) {\n      for (let j0 = 0; j0 < rightDim; j0 += blockSize) {\n        for (let k0 = 0; k0 < sharedDim; k0 += blockSize) {\n          // for when blockSize doesn't evenly divide the input\n          const iBlock = Math.min(i0 + blockSize, leftDim);\n          const jBlock = Math.min(j0 + blockSize, rightDim);\n          const kBlock = Math.min(k0 + blockSize, sharedDim);\n\n          for (let i = i0; i < iBlock; i++) {\n            for (let j = j0; j < jBlock; j++) {\n              let sum = 0.0;\n\n              for (let k = k0; k < kBlock; k++) {\n                const batchOffsetA = Math.min(bi, batchDimA - 1) * aBatch;\n                const batchOffsetB = Math.min(bi, batchDimB - 1) * bBatch;\n                const aVal = a3dValues[batchOffsetA + i * aOuterStep + k * aInnerStep];\n                const bVal = b3dValues[k * bInnerStep + j * bOuterStep + batchOffsetB];\n                sum += aVal * bVal;\n              }\n\n              resVals[bi * size + (i * rightDim + j)] += sum;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  backend.disposeIntermediateTensorInfo(a3d);\n  backend.disposeIntermediateTensorInfo(b3d); // set correct shape on output.\n\n  return backend.makeTensorInfo(outShape, result.dtype, result.values);\n}\nexport const batchMatMulConfig = {\n  kernelName: BatchMatMul,\n  backendName: 'cpu',\n  kernelFunc: batchMatMul\n};","map":{"version":3,"mappings":"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","names":["BatchMatMul","broadcast_util","buffer","util","assertNotComplex","reshape","batchMatMul","args","inputs","backend","attrs","a","b","transposeA","transposeB","aRank","shape","length","bRank","innerShapeA","innerShapeB","outerShapeA","outerShapeB","outerDimsA","slice","outerDimsB","batchDimA","sizeFromShape","batchDimB","outShapeOuterDims","assertAndGetBroadcastShape","outShape","concat","assert","a3dShape","b3dShape","a3d","x","b3d","sharedDim","leftDim","rightDim","batchDim","Math","max","a3dValues","data","get","dataId","values","b3dValues","a3dStrides","computeStrides","b3dStrides","aBatch","aOuterStep","aInnerStep","bInnerStep","bOuterStep","bBatch","size","result","dtype","resVals","blockSize","bi","i0","j0","k0","iBlock","min","jBlock","kBlock","i","j","sum","k","batchOffsetA","batchOffsetB","aVal","bVal","disposeIntermediateTensorInfo","makeTensorInfo","batchMatMulConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/BatchMatMul.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BatchMatMul, BatchMatMulAttrs, BatchMatMulInputs, broadcast_util, buffer, KernelConfig, KernelFunc, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nimport {reshape} from './Reshape';\n\nexport function batchMatMul(args: {\n  inputs: BatchMatMulInputs,\n  attrs: BatchMatMulAttrs,\n  backend: MathBackendCPU\n}) {\n  const {inputs, backend, attrs} = args;\n  const {a, b} = inputs;\n  const {transposeA, transposeB} = attrs;\n\n  assertNotComplex([a, b], 'matMul');\n\n  const aRank = a.shape.length;\n  const bRank = b.shape.length;\n\n  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n\n  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n\n  const outerDimsA = a.shape.slice(0, -2);\n  const outerDimsB = b.shape.slice(0, -2);\n\n  const batchDimA = util.sizeFromShape(outerDimsA);\n  const batchDimB = util.sizeFromShape(outerDimsB);\n\n  const outShapeOuterDims = broadcast_util.assertAndGetBroadcastShape(\n      a.shape.slice(0, -2), b.shape.slice(0, -2));\n  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n\n  util.assert(\n      innerShapeA === innerShapeB,\n      () => `Error in matMul: inner shapes (${innerShapeA}) and (` +\n          `${innerShapeB}) of Tensors with shapes ${a.shape} and ` +\n          `${b.shape} and transposeA=${transposeA}` +\n          ` and transposeB=${transposeB} must match.`);\n\n  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] :\n                                [batchDimA, outerShapeA, innerShapeA];\n  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] :\n                                [batchDimB, innerShapeB, outerShapeB];\n\n  // The rest of the implementation is designed to operate on rank-3 tensors\n  const a3d = reshape({inputs: {x: a}, backend, attrs: {shape: a3dShape}});\n  const b3d = reshape({inputs: {x: b}, backend, attrs: {shape: b3dShape}});\n\n  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];\n  const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];\n  const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];\n  const batchDim = Math.max(batchDimA, batchDimB);\n\n  const a3dValues = backend.data.get(a3d.dataId).values as TypedArray;\n  const b3dValues = backend.data.get(b3d.dataId).values as TypedArray;\n\n  const a3dStrides = util.computeStrides(a3d.shape);\n  const b3dStrides = util.computeStrides(b3d.shape);\n\n  const [aBatch, aOuterStep, aInnerStep] = transposeA ?\n      [a3dStrides[0], 1, a3dStrides[1]] :\n      [a3dStrides[0], a3dStrides[1], 1];\n  const [bInnerStep, bOuterStep, bBatch] = transposeB ?\n      [1, b3dStrides[1], b3dStrides[0]] :\n      [b3dStrides[1], 1, b3dStrides[0]];\n\n  const size = leftDim * rightDim;\n  const result = buffer([batchDim, leftDim, rightDim], a3d.dtype);\n\n  const resVals = result.values as TypedArray;\n  const blockSize = backend.blockSize;\n\n  for (let bi = 0; bi < batchDim; bi++) {\n    for (let i0 = 0; i0 < leftDim; i0 += blockSize) {\n      for (let j0 = 0; j0 < rightDim; j0 += blockSize) {\n        for (let k0 = 0; k0 < sharedDim; k0 += blockSize) {\n          // for when blockSize doesn't evenly divide the input\n          const iBlock = Math.min(i0 + blockSize, leftDim);\n          const jBlock = Math.min(j0 + blockSize, rightDim);\n          const kBlock = Math.min(k0 + blockSize, sharedDim);\n\n          for (let i = i0; i < iBlock; i++) {\n            for (let j = j0; j < jBlock; j++) {\n              let sum = 0.0;\n\n              for (let k = k0; k < kBlock; k++) {\n                const batchOffsetA = Math.min(bi, batchDimA - 1) * aBatch;\n                const batchOffsetB = Math.min(bi, batchDimB - 1) * bBatch;\n                const aVal =\n                    a3dValues[batchOffsetA + i * aOuterStep + k * aInnerStep];\n                const bVal =\n                    b3dValues[k * bInnerStep + j * bOuterStep + batchOffsetB];\n                sum += aVal * bVal;\n              }\n              resVals[bi * size + (i * rightDim + j)] += sum;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  backend.disposeIntermediateTensorInfo(a3d);\n  backend.disposeIntermediateTensorInfo(b3d);\n\n  // set correct shape on output.\n  return backend.makeTensorInfo(\n      outShape, result.dtype, result.values as TypedArray);\n}\n\nexport const batchMatMulConfig: KernelConfig = {\n  kernelName: BatchMatMul,\n  backendName: 'cpu',\n  kernelFunc: batchMatMul as {} as KernelFunc,\n};\n"]},"metadata":{},"sourceType":"module"}