{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { SparseFillEmptyRows } from '@tensorflow/tfjs-core';\nimport { sparseFillEmptyRowsImpl } from './SparseFillEmptyRows_impl';\nexport function sparseFillEmptyRows(args) {\n  const {\n    inputs,\n    backend\n  } = args;\n  const {\n    indices,\n    values,\n    denseShape,\n    defaultValue\n  } = inputs;\n\n  if (denseShape.shape.length !== 1) {\n    throw new Error(`Dense shape must be a vector, saw:\n        ${denseShape.shape}`);\n  }\n\n  if (indices.shape.length !== 2) {\n    throw new Error(`Indices must be a matrix, saw:\n        ${indices.shape}`);\n  }\n\n  if (values.shape.length !== 1) {\n    throw new Error(`Values must be a vector, saw:\n        ${values.shape}`);\n  }\n\n  if (defaultValue.shape.length !== 0) {\n    throw new Error(`Default value must be a scalar, saw:\n        ${defaultValue.shape}`);\n  }\n\n  const $indices = backend.data.get(indices.dataId).values;\n  const $values = backend.data.get(values.dataId).values;\n  const $denseShape = backend.data.get(denseShape.dataId).values;\n  const $defaultValue = backend.data.get(defaultValue.dataId).values[0];\n  const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImpl($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);\n  return [backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices), backend.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues), backend.makeTensorInfo([emptyRowIndicator.length], 'bool', new Uint8Array(emptyRowIndicator.map(value => Number(value)))), backend.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))];\n}\nexport const sparseFillEmptyRowsConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'cpu',\n  kernelFunc: sparseFillEmptyRows\n};","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAkCA,mBAAlC,QAA+G,uBAA/G;AAIA,SAAQC,uBAAR,QAAsC,4BAAtC;AAEA,OAAM,SAAUC,mBAAV,CAA8BC,IAA9B,EAGL;AACC,QAAM;AAACC,UAAD;AAASC;AAAT,MAAoBF,IAA1B;AACA,QAAM;AAACG,WAAD;AAAUC,UAAV;AAAkBC,cAAlB;AAA8BC;AAA9B,MAA8CL,MAApD;;AACA,MAAII,UAAU,CAACE,KAAX,CAAiBC,MAAjB,KAA4B,CAAhC,EAAmC;AACjC,UAAM,IAAIC,KAAJ,CAAU;UACVJ,UAAU,CAACE,KAAK,EADhB,CAAN;AAED;;AACD,MAAIJ,OAAO,CAACI,KAAR,CAAcC,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,UAAM,IAAIC,KAAJ,CAAU;UACVN,OAAO,CAACI,KAAK,EADb,CAAN;AAED;;AACD,MAAIH,MAAM,CAACG,KAAP,CAAaC,MAAb,KAAwB,CAA5B,EAA+B;AAC7B,UAAM,IAAIC,KAAJ,CAAU;UACVL,MAAM,CAACG,KAAK,EADZ,CAAN;AAED;;AACD,MAAID,YAAY,CAACC,KAAb,CAAmBC,MAAnB,KAA8B,CAAlC,EAAqC;AACnC,UAAM,IAAIC,KAAJ,CAAU;UACVH,YAAY,CAACC,KAAK,EADlB,CAAN;AAED;;AAED,QAAMG,QAAQ,GAAGR,OAAO,CAACS,IAAR,CAAaC,GAAb,CAAiBT,OAAO,CAACU,MAAzB,EAAiCT,MAAlD;AACA,QAAMU,OAAO,GAAGZ,OAAO,CAACS,IAAR,CAAaC,GAAb,CAAiBR,MAAM,CAACS,MAAxB,EAAgCT,MAAhD;AACA,QAAMW,WAAW,GAAGb,OAAO,CAACS,IAAR,CAAaC,GAAb,CAAiBP,UAAU,CAACQ,MAA5B,EAAoCT,MAAxD;AACA,QAAMY,aAAa,GACfd,OAAO,CAACS,IAAR,CAAaC,GAAb,CAAiBN,YAAY,CAACO,MAA9B,EAAsCT,MAAtC,CAA6C,CAA7C,CADJ;AAGA,QAAM,CAACa,aAAD,EAAgBC,kBAAhB,EAAoCC,YAApC,EACCC,iBADD,EACoBC,eADpB,IAEFvB,uBAAuB,CACnBY,QADmB,EACTP,OAAO,CAACI,KADC,EACMJ,OAAO,CAACmB,KADd,EACqBR,OADrB,EAC8BV,MAAM,CAACkB,KADrC,EAEnBP,WAFmB,EAENC,aAFM,CAF3B;AAKA,SAAO,CACLd,OAAO,CAACqB,cAAR,CAAuBL,kBAAvB,EAA2Cf,OAAO,CAACmB,KAAnD,EAA0DL,aAA1D,CADK,EAELf,OAAO,CAACqB,cAAR,CACI,CAACL,kBAAkB,CAAC,CAAD,CAAnB,CADJ,EAC6Bd,MAAM,CAACkB,KADpC,EAC2CH,YAD3C,CAFK,EAILjB,OAAO,CAACqB,cAAR,CACI,CAACH,iBAAiB,CAACZ,MAAnB,CADJ,EACgC,MADhC,EAEI,IAAIgB,UAAJ,CACIJ,iBAAiB,CAACK,GAAlB,CAAuBC,KAAD,IAAoBC,MAAM,CAACD,KAAD,CAAhD,CADJ,CAFJ,CAJK,EAQLxB,OAAO,CAACqB,cAAR,CACI,CAACF,eAAe,CAACb,MAAjB,CADJ,EAC8BL,OAAO,CAACmB,KADtC,EAEI,IAAIM,UAAJ,CAAeP,eAAf,CAFJ,CARK,CAAP;AAYD;AAED,OAAO,MAAMQ,yBAAyB,GAAiB;AACrDC,YAAU,EAAEjC,mBADyC;AAErDkC,aAAW,EAAE,KAFwC;AAGrDC,YAAU,EAAEjC;AAHyC,CAAhD","names":["SparseFillEmptyRows","sparseFillEmptyRowsImpl","sparseFillEmptyRows","args","inputs","backend","indices","values","denseShape","defaultValue","shape","length","Error","$indices","data","get","dataId","$values","$denseShape","$defaultValue","outputIndices","outputIndicesShape","outputValues","emptyRowIndicator","reverseIndexMap","dtype","makeTensorInfo","Uint8Array","map","value","Number","Int32Array","sparseFillEmptyRowsConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/SparseFillEmptyRows.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, SparseFillEmptyRows, SparseFillEmptyRowsInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nimport {sparseFillEmptyRowsImpl} from './SparseFillEmptyRows_impl';\n\nexport function sparseFillEmptyRows(args: {\n  inputs: SparseFillEmptyRowsInputs,\n  backend: MathBackendCPU\n}): [TensorInfo, TensorInfo, TensorInfo, TensorInfo] {\n  const {inputs, backend} = args;\n  const {indices, values, denseShape, defaultValue} = inputs;\n  if (denseShape.shape.length !== 1) {\n    throw new Error(`Dense shape must be a vector, saw:\n        ${denseShape.shape}`);\n  }\n  if (indices.shape.length !== 2) {\n    throw new Error(`Indices must be a matrix, saw:\n        ${indices.shape}`);\n  }\n  if (values.shape.length !== 1) {\n    throw new Error(`Values must be a vector, saw:\n        ${values.shape}`);\n  }\n  if (defaultValue.shape.length !== 0) {\n    throw new Error(`Default value must be a scalar, saw:\n        ${defaultValue.shape}`);\n  }\n\n  const $indices = backend.data.get(indices.dataId).values as TypedArray;\n  const $values = backend.data.get(values.dataId).values as TypedArray;\n  const $denseShape = backend.data.get(denseShape.dataId).values as TypedArray;\n  const $defaultValue =\n      backend.data.get(defaultValue.dataId).values[0] as number;\n\n  const [outputIndices, outputIndicesShape, outputValues,\n         emptyRowIndicator, reverseIndexMap] =\n      sparseFillEmptyRowsImpl(\n          $indices, indices.shape, indices.dtype, $values, values.dtype,\n          $denseShape, $defaultValue);\n  return [\n    backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),\n    backend.makeTensorInfo(\n        [outputIndicesShape[0]], values.dtype, outputValues),\n    backend.makeTensorInfo(\n        [emptyRowIndicator.length], 'bool',\n        new Uint8Array(\n            emptyRowIndicator.map((value: boolean) => Number(value)))),\n    backend.makeTensorInfo(\n        [reverseIndexMap.length], indices.dtype,\n        new Int32Array(reverseIndexMap)),\n  ];\n}\n\nexport const sparseFillEmptyRowsConfig: KernelConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'cpu',\n  kernelFunc: sparseFillEmptyRows as {} as KernelFunc,\n};\n"]},"metadata":{},"sourceType":"module"}