{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { Dataset } from '../dataset';\nimport { TextLineDataset } from './text_line_dataset';\nconst CODE_QUOTE = '\"';\nconst STATE_OUT = Symbol('out');\nconst STATE_FIELD = Symbol('field');\nconst STATE_QUOTE = Symbol('quote');\nconst STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nconst STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\n/**\n * Represents a potentially large collection of delimited text records.\n *\n * The produced `TensorContainer`s each contain one key-value pair for\n * every column of the table.  When a field is empty in the incoming data, the\n * resulting value is `undefined`, or throw error if it is required.  Values\n * that can be parsed as numbers are emitted as type `number`, other values\n * are parsed as `string`.\n *\n * The results are not batched.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\n\nexport class CSVDataset extends Dataset {\n  /**\n   * Create a `CSVDataset`.\n   *\n   * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n   * @param csvConfig (Optional) A CSVConfig object that contains configurations\n   *     of reading and decoding from CSV file(s).\n   *\n   *     hasHeader: (Optional) A boolean value that indicates whether the first\n   *     row of provided CSV file is a header line with column names, and should\n   *     not be included in the data. Defaults to `true`.\n   *\n   *     columnNames: (Optional) A list of strings that corresponds to\n   *     the CSV column names, in order. If provided, it ignores the column\n   *     names inferred from the header row. If not provided, infers the column\n   *     names from the first row of the records. If hasHeader is false and\n   *     columnNames is not provided, this method throws an error.\n   *\n   *     columnConfigs: (Optional) A dictionary whose key is column names, value\n   *     is an object stating if this column is required, column's data type,\n   *     default value, and if this column is label. If provided, keys must\n   *     correspond to names provided in columnNames or inferred from the file\n   *     header lines. If isLabel is true any column, returns an array of two\n   *     items: the first item is a dict of features key/value pairs, the second\n   *     item is a dict of labels key/value pairs. If no feature is marked as\n   *     label, returns a dict of features only.\n   *\n   *     configuredColumnsOnly (Optional) If true, only columns provided in\n   *     columnConfigs will be parsed and provided during iteration.\n   *\n   *     delimiter (Optional) The string used to parse each line of the input\n   *     file. Defaults to `,`.\n   */\n  constructor(input, csvConfig) {\n    super();\n    this.input = input;\n    this.hasHeader = true;\n    this.fullColumnNames = null;\n    this.columnNamesValidated = false;\n    this.columnConfigs = null;\n    this.configuredColumnsOnly = false;\n    this.delimiter = ',';\n    this.delimWhitespace = false;\n    this.base = new TextLineDataset(input);\n\n    if (!csvConfig) {\n      csvConfig = {};\n    }\n\n    this.hasHeader = csvConfig.hasHeader === false ? false : true;\n    this.fullColumnNames = csvConfig.columnNames;\n    this.columnConfigs = csvConfig.columnConfigs;\n    this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n\n    if (csvConfig.delimWhitespace) {\n      util.assert(csvConfig.delimiter == null, () => 'Delimiter should not be provided when delimWhitespace is true.');\n      this.delimWhitespace = true;\n      this.delimiter = ' ';\n    } else {\n      this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n    }\n  }\n  /**\n   * Returns column names of the csv dataset. If `configuredColumnsOnly` is\n   * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is\n   * false and `columnNames` is provided, `columnNames`. If\n   * `configuredColumnsOnly` is false and `columnNames` is not provided, return\n   * all column names parsed from the csv file. For example usage please go to\n   * `tf.data.csv`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n\n\n  async columnNames() {\n    if (!this.columnNamesValidated) {\n      await this.setColumnNames();\n    }\n\n    return this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames;\n  }\n  /* 1) If `columnNames` is provided as string[], use this string[] as output\n   * keys in corresponding order. The length must match the number of inferred\n   * columns if `hasHeader` is true .\n   * 2) If `columnNames` is not provided, parse header line as `columnNames` if\n   * hasHeader is true. If `hasHeader` is false, throw an error.\n   * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must\n   * exist in parsed `columnNames`.\n   */\n\n\n  async setColumnNames() {\n    const columnNamesFromFile = await this.maybeReadHeaderLine();\n\n    if (!this.fullColumnNames && !columnNamesFromFile) {\n      // Throw an error if columnNames is not provided and no header line.\n      throw new Error('Column names must be provided if there is no header line.');\n    } else if (this.fullColumnNames && columnNamesFromFile) {\n      // Check provided columnNames match header line.\n      util.assert(columnNamesFromFile.length === this.fullColumnNames.length, () => 'The length of provided columnNames (' + this.fullColumnNames.length.toString() + ') does not match the length of the header line read from ' + 'file (' + columnNamesFromFile.length.toString() + ').');\n    }\n\n    if (!this.fullColumnNames) {\n      this.fullColumnNames = columnNamesFromFile;\n    } // Check if there are duplicate column names.\n\n\n    const counts = this.fullColumnNames.reduce((countAcc, name) => {\n      countAcc[name] = countAcc[name] + 1 || 1;\n      return countAcc;\n    }, {});\n    const duplicateNames = Object.keys(counts).filter(name => counts[name] > 1);\n    util.assert(duplicateNames.length === 0, () => 'Duplicate column names found: ' + duplicateNames.toString()); // Check if keys in columnConfigs match columnNames.\n\n    if (this.columnConfigs) {\n      for (const key of Object.keys(this.columnConfigs)) {\n        const index = this.fullColumnNames.indexOf(key);\n\n        if (index === -1) {\n          throw new Error('The key \"' + key + '\" provided in columnConfigs does not match any of the column ' + 'names (' + this.fullColumnNames.toString() + ').');\n        }\n      }\n    }\n\n    this.columnNamesValidated = true;\n  }\n\n  async maybeReadHeaderLine() {\n    if (this.hasHeader) {\n      const iter = await this.base.iterator();\n      const firstElement = await iter.next();\n\n      if (firstElement.done) {\n        throw new Error('No data was found for CSV parsing.');\n      }\n\n      const firstLine = firstElement.value;\n      const headers = this.parseRow(firstLine, false);\n      return headers;\n    } else {\n      return null;\n    }\n  }\n\n  async iterator() {\n    if (!this.columnNamesValidated) {\n      await this.setColumnNames();\n    }\n\n    let lines = await this.base.iterator();\n\n    if (this.hasHeader) {\n      // We previously read the first line to get the columnNames.\n      // Now that we're providing data, skip it.\n      lines = lines.skip(1);\n    }\n\n    return lines.map(x => this.makeDataElement(x));\n  }\n\n  makeDataElement(line) {\n    const values = this.parseRow(line);\n    const features = {};\n    const labels = {};\n\n    for (let i = 0; i < this.fullColumnNames.length; i++) {\n      const key = this.fullColumnNames[i];\n      const config = this.columnConfigs ? this.columnConfigs[key] : null;\n\n      if (this.configuredColumnsOnly && !config) {\n        // This column is not selected.\n        continue;\n      } else {\n        const value = values[i];\n        let parsedValue = null;\n\n        if (value === '') {\n          // If default value is provided, use it. If default value is not\n          // provided, set as undefined.\n          if (config && config.default !== undefined) {\n            parsedValue = config.default;\n          } else if (config && (config.required || config.isLabel)) {\n            throw new Error(`Required column ${key} is empty in this line: ${line}`);\n          } else {\n            parsedValue = undefined;\n          }\n        } else {\n          // A value is present, so parse it based on type\n          const valueAsNum = Number(value);\n\n          if (isNaN(valueAsNum)) {\n            // The value is a string and this column is declared as boolean\n            // in config, parse it as boolean.\n            if (config && config.dtype === 'bool') {\n              parsedValue = this.getBoolean(value);\n            } else {\n              // Set value as string\n              parsedValue = value;\n            }\n          } else if (!config || !config.dtype) {\n            // If this value is a number and no type config is provided, return\n            // it as number.\n            parsedValue = valueAsNum;\n          } else {\n            // If this value is a number and data type is provided, parse it\n            // according to provided data type.\n            switch (config.dtype) {\n              case 'float32':\n                parsedValue = valueAsNum;\n                break;\n\n              case 'int32':\n                parsedValue = Math.floor(valueAsNum);\n                break;\n\n              case 'bool':\n                parsedValue = this.getBoolean(value);\n                break;\n\n              default:\n                parsedValue = valueAsNum;\n            }\n          }\n        } // Check if this column is label.\n\n\n        config && config.isLabel ? labels[key] = parsedValue : features[key] = parsedValue;\n      }\n    } // If label exists, return an object of features and labels as {xs:features,\n    // ys:labels}, otherwise return features only.\n\n\n    if (Object.keys(labels).length === 0) {\n      return features;\n    } else {\n      return {\n        xs: features,\n        ys: labels\n      };\n    }\n  }\n\n  getBoolean(value) {\n    if (value === '1' || value.toLowerCase() === 'true') {\n      return 1;\n    } else {\n      return 0;\n    }\n  } // adapted from https://beta.observablehq.com/@mbostock/streaming-csv\n\n\n  parseRow(line) {\n    let validateElementCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const result = [];\n    let readOffset = 0;\n    const readLength = line.length;\n    let currentState = STATE_OUT; // Goes through the line to parse quote.\n\n    for (let i = 0; i < readLength; i++) {\n      switch (currentState) {\n        // Before enter a new field\n        case STATE_OUT:\n          switch (line.charAt(i)) {\n            // Enter a quoted field\n            case CODE_QUOTE:\n              readOffset = i + 1;\n              currentState = STATE_QUOTE;\n              break;\n            // Read an empty field\n\n            case this.delimiter:\n              readOffset = i + 1; // If delimiter is white space and configured to collapse\n              // multiple white spaces, ignore this white space.\n\n              if (this.delimiter === ' ' && this.delimWhitespace) {\n                break;\n              }\n\n              result.push('');\n              currentState = STATE_OUT;\n              break;\n            // Enter an unquoted field\n\n            default:\n              currentState = STATE_FIELD;\n              readOffset = i;\n              break;\n          }\n\n          break;\n        // In an unquoted field\n\n        case STATE_FIELD:\n          switch (line.charAt(i)) {\n            // Exit an unquoted field, add it to result\n            case this.delimiter:\n              result.push(line.substring(readOffset, i));\n              currentState = STATE_OUT;\n              readOffset = i + 1;\n              break;\n\n            default:\n          }\n\n          break;\n        // In a quoted field\n\n        case STATE_QUOTE:\n          switch (line.charAt(i)) {\n            // Read a quote after a quote\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE_AFTER_QUOTE;\n              break;\n\n            default:\n          }\n\n          break;\n        // This state means it's right after a second quote in a field\n\n        case STATE_QUOTE_AFTER_QUOTE:\n          switch (line.charAt(i)) {\n            // Finished a quoted field\n            case this.delimiter:\n              result.push(line.substring(readOffset, i - 1));\n              currentState = STATE_OUT;\n              readOffset = i + 1;\n              break;\n            // Finished a quoted part in a quoted field\n\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE;\n              break;\n            // In a quoted part in a quoted field\n\n            default:\n              currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n              break;\n          }\n\n          break;\n\n        case STATE_WITHIN_QUOTE_IN_QUOTE:\n          switch (line.charAt(i)) {\n            // Exit a quoted part in a quoted field\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE;\n              break;\n\n            default:\n          }\n\n          break;\n\n        default:\n      }\n    } // Adds last item based on if it is quoted.\n\n\n    if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n      result.push(line.substring(readOffset, readLength - 1));\n    } else {\n      result.push(line.substring(readOffset));\n    } // Check if each row has the same number of elements as column names.\n\n\n    if (validateElementCount && result.length !== this.fullColumnNames.length) {\n      throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${result}`);\n    }\n\n    return result;\n  }\n\n} // TODO(soergel): add more basic datasets for parity with tf.data\n// tf.data.FixedLengthRecordDataset()\n// tf.data.TFRecordDataset()","map":{"version":3,"mappings":"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","names":["util","Dataset","TextLineDataset","CODE_QUOTE","STATE_OUT","Symbol","STATE_FIELD","STATE_QUOTE","STATE_QUOTE_AFTER_QUOTE","STATE_WITHIN_QUOTE_IN_QUOTE","CSVDataset","constructor","input","csvConfig","base","hasHeader","fullColumnNames","columnNames","columnConfigs","configuredColumnsOnly","delimWhitespace","assert","delimiter","columnNamesValidated","setColumnNames","Object","keys","columnNamesFromFile","maybeReadHeaderLine","Error","length","toString","counts","reduce","countAcc","name","duplicateNames","filter","key","index","indexOf","iter","iterator","firstElement","next","done","firstLine","value","headers","parseRow","lines","skip","map","x","makeDataElement","line","values","features","labels","i","config","parsedValue","default","undefined","required","isLabel","valueAsNum","Number","isNaN","dtype","getBoolean","Math","floor","xs","ys","toLowerCase","validateElementCount","result","readOffset","readLength","currentState","charAt","push","substring"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-data/src/datasets/csv_dataset.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {TensorContainer, util} from '@tensorflow/tfjs-core';\nimport {Dataset} from '../dataset';\nimport {DataSource} from '../datasource';\nimport {LazyIterator} from '../iterators/lazy_iterator';\nimport {ColumnConfig, CSVConfig} from '../types';\nimport {TextLineDataset} from './text_line_dataset';\n\nconst CODE_QUOTE = '\"';\nconst STATE_OUT = Symbol('out');\nconst STATE_FIELD = Symbol('field');\nconst STATE_QUOTE = Symbol('quote');\nconst STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nconst STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\n\n/**\n * Represents a potentially large collection of delimited text records.\n *\n * The produced `TensorContainer`s each contain one key-value pair for\n * every column of the table.  When a field is empty in the incoming data, the\n * resulting value is `undefined`, or throw error if it is required.  Values\n * that can be parsed as numbers are emitted as type `number`, other values\n * are parsed as `string`.\n *\n * The results are not batched.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\nexport class CSVDataset extends Dataset<TensorContainer> {\n  base: TextLineDataset;\n  private hasHeader = true;\n  private fullColumnNames: string[] = null;\n  private columnNamesValidated = false;\n  private columnConfigs: {[key: string]: ColumnConfig} = null;\n  private configuredColumnsOnly = false;\n  private delimiter = ',';\n  private delimWhitespace = false;\n\n  /**\n   * Returns column names of the csv dataset. If `configuredColumnsOnly` is\n   * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is\n   * false and `columnNames` is provided, `columnNames`. If\n   * `configuredColumnsOnly` is false and `columnNames` is not provided, return\n   * all column names parsed from the csv file. For example usage please go to\n   * `tf.data.csv`.\n   *\n   * @doc {heading: 'Data', subheading: 'Classes'}\n   */\n  async columnNames() {\n    if (!this.columnNamesValidated) {\n      await this.setColumnNames();\n    }\n    return this.configuredColumnsOnly ? Object.keys(this.columnConfigs) :\n                                        this.fullColumnNames;\n  }\n\n  /* 1) If `columnNames` is provided as string[], use this string[] as output\n   * keys in corresponding order. The length must match the number of inferred\n   * columns if `hasHeader` is true .\n   * 2) If `columnNames` is not provided, parse header line as `columnNames` if\n   * hasHeader is true. If `hasHeader` is false, throw an error.\n   * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must\n   * exist in parsed `columnNames`.\n   */\n  private async setColumnNames() {\n    const columnNamesFromFile = await this.maybeReadHeaderLine();\n    if (!this.fullColumnNames && !columnNamesFromFile) {\n      // Throw an error if columnNames is not provided and no header line.\n      throw new Error(\n          'Column names must be provided if there is no header line.');\n    } else if (this.fullColumnNames && columnNamesFromFile) {\n      // Check provided columnNames match header line.\n      util.assert(\n          columnNamesFromFile.length === this.fullColumnNames.length,\n          () => 'The length of provided columnNames (' +\n              this.fullColumnNames.length.toString() +\n              ') does not match the length of the header line read from ' +\n              'file (' + columnNamesFromFile.length.toString() + ').');\n    }\n    if (!this.fullColumnNames) {\n      this.fullColumnNames = columnNamesFromFile;\n    }\n    // Check if there are duplicate column names.\n    const counts: {[key: string]: number} = this.fullColumnNames.reduce(\n        (countAcc: {[key: string]: number}, name) => {\n          countAcc[name] = (countAcc[name] + 1) || 1;\n          return countAcc;\n        },\n        {});\n    const duplicateNames =\n        Object.keys(counts).filter((name) => (counts[name] > 1));\n    util.assert(\n        duplicateNames.length === 0,\n        () => 'Duplicate column names found: ' + duplicateNames.toString());\n    // Check if keys in columnConfigs match columnNames.\n    if (this.columnConfigs) {\n      for (const key of Object.keys(this.columnConfigs)) {\n        const index = this.fullColumnNames.indexOf(key);\n        if (index === -1) {\n          throw new Error(\n              'The key \"' + key +\n              '\" provided in columnConfigs does not match any of the column ' +\n              'names (' + this.fullColumnNames.toString() + ').');\n        }\n      }\n    }\n    this.columnNamesValidated = true;\n  }\n\n  private async maybeReadHeaderLine() {\n    if (this.hasHeader) {\n      const iter = await this.base.iterator();\n      const firstElement = await iter.next();\n      if (firstElement.done) {\n        throw new Error('No data was found for CSV parsing.');\n      }\n      const firstLine: string = firstElement.value;\n      const headers = this.parseRow(firstLine, false);\n      return headers;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Create a `CSVDataset`.\n   *\n   * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n   * @param csvConfig (Optional) A CSVConfig object that contains configurations\n   *     of reading and decoding from CSV file(s).\n   *\n   *     hasHeader: (Optional) A boolean value that indicates whether the first\n   *     row of provided CSV file is a header line with column names, and should\n   *     not be included in the data. Defaults to `true`.\n   *\n   *     columnNames: (Optional) A list of strings that corresponds to\n   *     the CSV column names, in order. If provided, it ignores the column\n   *     names inferred from the header row. If not provided, infers the column\n   *     names from the first row of the records. If hasHeader is false and\n   *     columnNames is not provided, this method throws an error.\n   *\n   *     columnConfigs: (Optional) A dictionary whose key is column names, value\n   *     is an object stating if this column is required, column's data type,\n   *     default value, and if this column is label. If provided, keys must\n   *     correspond to names provided in columnNames or inferred from the file\n   *     header lines. If isLabel is true any column, returns an array of two\n   *     items: the first item is a dict of features key/value pairs, the second\n   *     item is a dict of labels key/value pairs. If no feature is marked as\n   *     label, returns a dict of features only.\n   *\n   *     configuredColumnsOnly (Optional) If true, only columns provided in\n   *     columnConfigs will be parsed and provided during iteration.\n   *\n   *     delimiter (Optional) The string used to parse each line of the input\n   *     file. Defaults to `,`.\n   */\n  constructor(protected readonly input: DataSource, csvConfig?: CSVConfig) {\n    super();\n    this.base = new TextLineDataset(input);\n    if (!csvConfig) {\n      csvConfig = {};\n    }\n    this.hasHeader = csvConfig.hasHeader === false ? false : true;\n    this.fullColumnNames = csvConfig.columnNames;\n    this.columnConfigs = csvConfig.columnConfigs;\n    this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n    if (csvConfig.delimWhitespace) {\n      util.assert(\n          csvConfig.delimiter == null,\n          () =>\n              'Delimiter should not be provided when delimWhitespace is true.');\n      this.delimWhitespace = true;\n      this.delimiter = ' ';\n    } else {\n      this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n    }\n  }\n\n  async iterator(): Promise<LazyIterator<TensorContainer>> {\n    if (!this.columnNamesValidated) {\n      await this.setColumnNames();\n    }\n    let lines = await this.base.iterator();\n    if (this.hasHeader) {\n      // We previously read the first line to get the columnNames.\n      // Now that we're providing data, skip it.\n      lines = lines.skip(1);\n    }\n    return lines.map(x => this.makeDataElement(x));\n  }\n\n  makeDataElement(line: string): TensorContainer {\n    const values = this.parseRow(line);\n    const features: {[key: string]: TensorContainer} = {};\n    const labels: {[key: string]: TensorContainer} = {};\n\n    for (let i = 0; i < this.fullColumnNames.length; i++) {\n      const key = this.fullColumnNames[i];\n      const config = this.columnConfigs ? this.columnConfigs[key] : null;\n      if (this.configuredColumnsOnly && !config) {\n        // This column is not selected.\n        continue;\n      } else {\n        const value = values[i];\n        let parsedValue = null;\n        if (value === '') {\n          // If default value is provided, use it. If default value is not\n          // provided, set as undefined.\n          if (config && config.default !== undefined) {\n            parsedValue = config.default;\n          } else if (config && (config.required || config.isLabel)) {\n            throw new Error(\n                `Required column ${key} is empty in this line: ${line}`);\n          } else {\n            parsedValue = undefined;\n          }\n        } else {\n          // A value is present, so parse it based on type\n          const valueAsNum = Number(value);\n          if (isNaN(valueAsNum)) {\n            // The value is a string and this column is declared as boolean\n            // in config, parse it as boolean.\n            if (config && config.dtype === 'bool') {\n              parsedValue = this.getBoolean(value);\n            } else {\n              // Set value as string\n              parsedValue = value;\n            }\n          } else if (!config || !config.dtype) {\n            // If this value is a number and no type config is provided, return\n            // it as number.\n            parsedValue = valueAsNum;\n          } else {\n            // If this value is a number and data type is provided, parse it\n            // according to provided data type.\n            switch (config.dtype) {\n              case 'float32':\n                parsedValue = valueAsNum;\n                break;\n              case 'int32':\n                parsedValue = Math.floor(valueAsNum);\n                break;\n              case 'bool':\n                parsedValue = this.getBoolean(value);\n                break;\n              default:\n                parsedValue = valueAsNum;\n            }\n          }\n        }\n        // Check if this column is label.\n        (config && config.isLabel) ? labels[key] = parsedValue :\n                                     features[key] = parsedValue;\n      }\n    }\n    // If label exists, return an object of features and labels as {xs:features,\n    // ys:labels}, otherwise return features only.\n    if (Object.keys(labels).length === 0) {\n      return features;\n\n    } else {\n      return {xs: features, ys: labels};\n    }\n  }\n\n  private getBoolean(value: string): number {\n    if (value === '1' || value.toLowerCase() === 'true') {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  // adapted from https://beta.observablehq.com/@mbostock/streaming-csv\n  private parseRow(line: string, validateElementCount = true): string[] {\n    const result: string[] = [];\n    let readOffset = 0;\n    const readLength = line.length;\n    let currentState = STATE_OUT;\n    // Goes through the line to parse quote.\n    for (let i = 0; i < readLength; i++) {\n      switch (currentState) {\n        // Before enter a new field\n        case STATE_OUT:\n          switch (line.charAt(i)) {\n            // Enter a quoted field\n            case CODE_QUOTE:\n              readOffset = i + 1;\n              currentState = STATE_QUOTE;\n              break;\n            // Read an empty field\n            case this.delimiter:\n              readOffset = i + 1;\n              // If delimiter is white space and configured to collapse\n              // multiple white spaces, ignore this white space.\n              if (this.delimiter === ' ' && this.delimWhitespace) {\n                break;\n              }\n              result.push('');\n              currentState = STATE_OUT;\n              break;\n            // Enter an unquoted field\n            default:\n              currentState = STATE_FIELD;\n              readOffset = i;\n              break;\n          }\n          break;\n        // In an unquoted field\n        case STATE_FIELD:\n          switch (line.charAt(i)) {\n            // Exit an unquoted field, add it to result\n            case this.delimiter:\n              result.push(line.substring(readOffset, i));\n              currentState = STATE_OUT;\n              readOffset = i + 1;\n              break;\n            default:\n          }\n          break;\n        // In a quoted field\n        case STATE_QUOTE:\n          switch (line.charAt(i)) {\n            // Read a quote after a quote\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE_AFTER_QUOTE;\n              break;\n            default:\n          }\n          break;\n        // This state means it's right after a second quote in a field\n        case STATE_QUOTE_AFTER_QUOTE:\n          switch (line.charAt(i)) {\n            // Finished a quoted field\n            case this.delimiter:\n              result.push(line.substring(readOffset, i - 1));\n              currentState = STATE_OUT;\n              readOffset = i + 1;\n              break;\n            // Finished a quoted part in a quoted field\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE;\n              break;\n            // In a quoted part in a quoted field\n            default:\n              currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n              break;\n          }\n          break;\n        case STATE_WITHIN_QUOTE_IN_QUOTE:\n          switch (line.charAt(i)) {\n            // Exit a quoted part in a quoted field\n            case CODE_QUOTE:\n              currentState = STATE_QUOTE;\n              break;\n            default:\n          }\n          break;\n        default:\n      }\n    }\n    // Adds last item based on if it is quoted.\n    if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n      result.push(line.substring(readOffset, readLength - 1));\n    } else {\n      result.push(line.substring(readOffset));\n    }\n    // Check if each row has the same number of elements as column names.\n    if (validateElementCount && result.length !== this.fullColumnNames.length) {\n      throw new Error(`Invalid row in csv file. Should have ${\n          this.fullColumnNames.length} elements in a row, but got ${result}`);\n    }\n    return result;\n  }\n}\n\n// TODO(soergel): add more basic datasets for parity with tf.data\n// tf.data.FixedLengthRecordDataset()\n// tf.data.TFRecordDataset()\n"]},"metadata":{},"sourceType":"module"}