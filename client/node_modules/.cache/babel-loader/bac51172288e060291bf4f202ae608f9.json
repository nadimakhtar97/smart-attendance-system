{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Cumsum, upcastType, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { transpose } from './Transpose';\nexport function cumsum(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    axis,\n    exclusive,\n    reverse\n  } = attrs;\n  assertNotComplex(x, 'cumsum');\n  const permutation = backend_util.getAxesPermutation([axis], x.shape.length);\n  let $x = x;\n\n  if (permutation != null) {\n    $x = transpose({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n  }\n\n  const permutedAxis = backend_util.getInnerMostAxes(1, x.shape.length)[0];\n\n  if (permutedAxis !== $x.shape.length - 1) {\n    throw new Error(`backend.cumsum in CPU expects an inner-most ` + `axis=${$x.shape.length - 1} but got axis=${permutedAxis}`);\n  }\n\n  const resultDtype = upcastType($x.dtype, 'int32');\n  const vals = util.makeZerosTypedArray(util.sizeFromShape($x.shape), resultDtype);\n  const aVals = backend.data.get($x.dataId).values;\n  const finalDim = $x.shape[$x.shape.length - 1];\n  const indexAdjuster = reverse ? (i, j) => i + finalDim - j - 1 : (i, j) => i + j;\n\n  for (let i = 0; i < aVals.length; i += finalDim) {\n    for (let j = 0; j < finalDim; j++) {\n      const idx = indexAdjuster(i, j);\n\n      if (j === 0) {\n        vals[idx] = exclusive ? 0 : aVals[idx];\n      } else {\n        const prevIdx = indexAdjuster(i, j - 1);\n        vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] : aVals[idx] + vals[prevIdx];\n      }\n    }\n  }\n\n  const result = backend.makeTensorInfo($x.shape, resultDtype, vals);\n\n  if (permutation != null) {\n    const reversePermutation = backend_util.getUndoAxesPermutation(permutation);\n    const reverseTransposedResult = transpose({\n      inputs: {\n        x: result\n      },\n      backend,\n      attrs: {\n        perm: reversePermutation\n      }\n    });\n    backend.disposeIntermediateTensorInfo(result);\n    backend.disposeIntermediateTensorInfo($x);\n    return reverseTransposedResult;\n  }\n\n  return result;\n}\nexport const cumsumConfig = {\n  kernelName: Cumsum,\n  backendName: 'cpu',\n  kernelFunc: cumsum\n};","map":{"version":3,"mappings":"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","names":["backend_util","Cumsum","upcastType","util","assertNotComplex","transpose","cumsum","args","inputs","backend","attrs","x","axis","exclusive","reverse","permutation","getAxesPermutation","shape","length","$x","perm","permutedAxis","getInnerMostAxes","Error","resultDtype","dtype","vals","makeZerosTypedArray","sizeFromShape","aVals","data","get","dataId","values","finalDim","indexAdjuster","i","j","idx","prevIdx","result","makeTensorInfo","reversePermutation","getUndoAxesPermutation","reverseTransposedResult","disposeIntermediateTensorInfo","cumsumConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/Cumsum.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Cumsum, CumsumAttrs, CumsumInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray, upcastType, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {transpose} from './Transpose';\n\nexport function cumsum(\n    args: {inputs: CumsumInputs, backend: MathBackendCPU, attrs: CumsumAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, exclusive, reverse} = attrs;\n\n  assertNotComplex(x, 'cumsum');\n\n  const permutation = backend_util.getAxesPermutation([axis], x.shape.length);\n  let $x = x;\n  if (permutation != null) {\n    $x = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n  }\n  const permutedAxis = backend_util.getInnerMostAxes(1, x.shape.length)[0];\n\n  if (permutedAxis !== $x.shape.length - 1) {\n    throw new Error(\n        `backend.cumsum in CPU expects an inner-most ` +\n        `axis=${$x.shape.length - 1} but got axis=${permutedAxis}`);\n  }\n\n  const resultDtype = upcastType($x.dtype, 'int32');\n  const vals = util.makeZerosTypedArray(\n                   util.sizeFromShape($x.shape), resultDtype) as TypedArray;\n\n  const aVals = backend.data.get($x.dataId).values as TypedArray;\n  const finalDim = $x.shape[$x.shape.length - 1];\n  const indexAdjuster = reverse ?\n      (i: number, j: number) => i + finalDim - j - 1 :\n      (i: number, j: number) => i + j;\n  for (let i = 0; i < aVals.length; i += finalDim) {\n    for (let j = 0; j < finalDim; j++) {\n      const idx = indexAdjuster(i, j);\n      if (j === 0) {\n        vals[idx] = exclusive ? 0 : aVals[idx];\n      } else {\n        const prevIdx = indexAdjuster(i, j - 1);\n        vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] :\n                                aVals[idx] + vals[prevIdx];\n      }\n    }\n  }\n\n  const result = backend.makeTensorInfo($x.shape, resultDtype, vals);\n\n  if (permutation != null) {\n    const reversePermutation = backend_util.getUndoAxesPermutation(permutation);\n    const reverseTransposedResult = transpose(\n        {inputs: {x: result}, backend, attrs: {perm: reversePermutation}});\n\n    backend.disposeIntermediateTensorInfo(result);\n    backend.disposeIntermediateTensorInfo($x);\n\n    return reverseTransposedResult;\n  }\n\n  return result;\n}\n\nexport const cumsumConfig: KernelConfig = {\n  kernelName: Cumsum,\n  backendName: 'cpu',\n  kernelFunc: cumsum as {} as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module"}