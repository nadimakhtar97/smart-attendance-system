{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function lRNGrad(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    y,\n    dy\n  } = inputs;\n  const {\n    depthRadius,\n    bias,\n    alpha,\n    beta\n  } = attrs;\n  assertNotComplex(dy, 'LRNGrad');\n  const dySize = util.sizeFromShape(dy.shape);\n  const channels = dy.shape[3];\n  const dyValues = backend.data.get(dy.dataId).values;\n  const xValues = backend.data.get(x.dataId).values;\n  const yValues = backend.data.get(y.dataId).values;\n  const result = new Float32Array(dySize);\n  const size = dySize;\n\n  for (let offset = 0; offset < size; offset++) {\n    const currentChannel = offset % channels;\n    const depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n    const depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);\n    let norm = 0;\n\n    for (let k = depthBegin; k < depthEnd; k++) {\n      norm += Math.pow(xValues[k], 2);\n    }\n\n    norm = alpha * norm + bias;\n\n    for (let k = depthBegin; k < depthEnd; k++) {\n      let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm;\n\n      if (offset === k) {\n        dyi += Math.pow(norm, -beta);\n      }\n\n      dyi *= dyValues[offset];\n      result[k] += dyi;\n    }\n  }\n\n  return backend.makeTensorInfo(dy.shape, x.dtype, result);\n} // tslint:disable-next-line: variable-name\n\nexport const LRNGradConfig = {\n  kernelName: LRNGrad,\n  backendName: 'cpu',\n  kernelFunc: lRNGrad\n};","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAkCA,OAAlC,EAAgGC,IAAhG,QAA2G,uBAA3G;AAGA,SAAQC,gBAAR,QAA+B,aAA/B;AAEA,OAAM,SAAUC,OAAV,CACFC,IADE,EAEuE;AAE3E,QAAM;AAACC,UAAD;AAASC,WAAT;AAAkBC;AAAlB,MAA2BH,IAAjC;AACA,QAAM;AAACI,KAAD;AAAIC,KAAJ;AAAOC;AAAP,MAAaL,MAAnB;AACA,QAAM;AAACM,eAAD;AAAcC,QAAd;AAAoBC,SAApB;AAA2BC;AAA3B,MAAmCP,KAAzC;AAEAL,kBAAgB,CAACQ,EAAD,EAAK,SAAL,CAAhB;AAEA,QAAMK,MAAM,GAAGd,IAAI,CAACe,aAAL,CAAmBN,EAAE,CAACO,KAAtB,CAAf;AAEA,QAAMC,QAAQ,GAAGR,EAAE,CAACO,KAAH,CAAS,CAAT,CAAjB;AACA,QAAME,QAAQ,GAAGb,OAAO,CAACc,IAAR,CAAaC,GAAb,CAAiBX,EAAE,CAACY,MAApB,EAA4BC,MAA7C;AACA,QAAMC,OAAO,GAAGlB,OAAO,CAACc,IAAR,CAAaC,GAAb,CAAiBb,CAAC,CAACc,MAAnB,EAA2BC,MAA3C;AACA,QAAME,OAAO,GAAGnB,OAAO,CAACc,IAAR,CAAaC,GAAb,CAAiBZ,CAAC,CAACa,MAAnB,EAA2BC,MAA3C;AACA,QAAMG,MAAM,GAAG,IAAIC,YAAJ,CAAiBZ,MAAjB,CAAf;AACA,QAAMa,IAAI,GAAGb,MAAb;;AAEA,OAAK,IAAIc,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGD,IAA9B,EAAoCC,MAAM,EAA1C,EAA8C;AAC5C,UAAMC,cAAc,GAAGD,MAAM,GAAGX,QAAhC;AACA,UAAMa,UAAU,GACXF,MAAM,GAAGC,cAAV,GAA4BE,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,cAAc,GAAGnB,WAA7B,CADhC;AAEA,UAAMuB,QAAQ,GAAIL,MAAM,GAAGC,cAAV,GACbE,IAAI,CAACG,GAAL,CAASjB,QAAT,EAAmBY,cAAc,GAAGnB,WAAjB,GAA+B,CAAlD,CADJ;AAGA,QAAIyB,IAAI,GAAG,CAAX;;AACA,SAAK,IAAIC,CAAC,GAAGN,UAAb,EAAyBM,CAAC,GAAGH,QAA7B,EAAuCG,CAAC,EAAxC,EAA4C;AAC1CD,UAAI,IAAIJ,IAAI,CAACM,GAAL,CAASd,OAAO,CAACa,CAAD,CAAhB,EAAqB,CAArB,CAAR;AACD;;AACDD,QAAI,GAAGvB,KAAK,GAAGuB,IAAR,GAAexB,IAAtB;;AAEA,SAAK,IAAIyB,CAAC,GAAGN,UAAb,EAAyBM,CAAC,GAAGH,QAA7B,EAAuCG,CAAC,EAAxC,EAA4C;AAC1C,UAAIE,GAAG,GAAG,CAAC,CAAD,GAAK1B,KAAL,GAAaC,IAAb,GAAoBU,OAAO,CAACa,CAAD,CAA3B,GAAiCZ,OAAO,CAACI,MAAD,CAAxC,GAAmDO,IAA7D;;AACA,UAAIP,MAAM,KAAKQ,CAAf,EAAkB;AAChBE,WAAG,IAAIP,IAAI,CAACM,GAAL,CAASF,IAAT,EAAe,CAACtB,IAAhB,CAAP;AACD;;AACDyB,SAAG,IAAIpB,QAAQ,CAACU,MAAD,CAAf;AACAH,YAAM,CAACW,CAAD,CAAN,IAAaE,GAAb;AACD;AACF;;AAED,SAAOjC,OAAO,CAACkC,cAAR,CAAuB9B,EAAE,CAACO,KAA1B,EAAiCT,CAAC,CAACiC,KAAnC,EAA0Cf,MAA1C,CAAP;AACD,C,CAED;;AACA,OAAO,MAAMgB,aAAa,GAAiB;AACzCC,YAAU,EAAE3C,OAD6B;AAEzC4C,aAAW,EAAE,KAF4B;AAGzCC,YAAU,EAAE1C;AAH6B,CAApC","names":["LRNGrad","util","assertNotComplex","lRNGrad","args","inputs","backend","attrs","x","y","dy","depthRadius","bias","alpha","beta","dySize","sizeFromShape","shape","channels","dyValues","data","get","dataId","values","xValues","yValues","result","Float32Array","size","offset","currentChannel","depthBegin","Math","max","depthEnd","min","norm","k","pow","dyi","makeTensorInfo","dtype","LRNGradConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/LRNGrad.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, LRNGrad, LRNGradAttrs, LRNGradInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function lRNGrad(\n    args:\n        {inputs: LRNGradInputs, backend: MathBackendCPU, attrs: LRNGradAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, y, dy} = inputs;\n  const {depthRadius, bias, alpha, beta} = attrs;\n\n  assertNotComplex(dy, 'LRNGrad');\n\n  const dySize = util.sizeFromShape(dy.shape);\n\n  const channels = dy.shape[3];\n  const dyValues = backend.data.get(dy.dataId).values as TypedArray;\n  const xValues = backend.data.get(x.dataId).values as TypedArray;\n  const yValues = backend.data.get(y.dataId).values as TypedArray;\n  const result = new Float32Array(dySize);\n  const size = dySize;\n\n  for (let offset = 0; offset < size; offset++) {\n    const currentChannel = offset % channels;\n    const depthBegin =\n        (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);\n    const depthEnd = (offset - currentChannel) +\n        Math.min(channels, currentChannel + depthRadius + 1);\n\n    let norm = 0;\n    for (let k = depthBegin; k < depthEnd; k++) {\n      norm += Math.pow(xValues[k], 2);\n    }\n    norm = alpha * norm + bias;\n\n    for (let k = depthBegin; k < depthEnd; k++) {\n      let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm;\n      if (offset === k) {\n        dyi += Math.pow(norm, -beta);\n      }\n      dyi *= dyValues[offset];\n      result[k] += dyi;\n    }\n  }\n\n  return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\n\n// tslint:disable-next-line: variable-name\nexport const LRNGradConfig: KernelConfig = {\n  kernelName: LRNGrad,\n  backendName: 'cpu',\n  kernelFunc: lRNGrad as {} as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module"}