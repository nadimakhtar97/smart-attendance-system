{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { MirrorPad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function mirrorPad(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    paddings,\n    mode\n  } = attrs;\n  assertNotComplex(x, 'mirrorPad');\n  const outShape = paddings.map((p, i) => p[0]\n  /* beforePad */\n  + x.shape[i] + p[1]\n  /* afterPad */\n  );\n  const start = paddings.map(p => p[0]);\n  const end = paddings.map((p, i) => p[0] + x.shape[i]);\n  const offset = mode === 'reflect' ? 0 : 1;\n  const xVals = backend.data.get(x.dataId).values;\n  const xRank = x.shape.length;\n  const xStrides = util.computeStrides(x.shape);\n  const resultSize = util.sizeFromShape(outShape);\n  const resultRank = outShape.length;\n  const resultStrides = util.computeStrides(outShape);\n  const resVals = util.getTypedArrayFromDType(x.dtype, resultSize);\n\n  for (let i = 0; i < resultSize; i++) {\n    let coords = util.indexToLoc(i, resultRank, resultStrides);\n\n    for (let i = 0; i < resultRank; i++) {\n      if (coords[i] < start[i]) {\n        coords[i] = start[i] * 2 - coords[i] - offset;\n      } else if (coords[i] >= end[i]) {\n        coords[i] = (end[i] - 1) * 2 - coords[i] + offset;\n      }\n    }\n\n    coords = coords.map((c, i) => c - start[i]);\n    const inIndex = util.locToIndex(coords, xRank, xStrides);\n    resVals[i] = xVals[inIndex];\n  }\n\n  const outId = backend.write(resVals, outShape, x.dtype);\n  return {\n    dataId: outId,\n    shape: outShape,\n    dtype: x.dtype\n  };\n}\nexport const mirrorPadConfig = {\n  kernelName: MirrorPad,\n  backendName: 'cpu',\n  kernelFunc: mirrorPad\n};","map":{"version":3,"mappings":"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","names":["MirrorPad","util","assertNotComplex","mirrorPad","args","inputs","backend","attrs","x","paddings","mode","outShape","map","p","i","shape","start","end","offset","xVals","data","get","dataId","values","xRank","length","xStrides","computeStrides","resultSize","sizeFromShape","resultRank","resultStrides","resVals","getTypedArrayFromDType","dtype","coords","indexToLoc","c","inIndex","locToIndex","outId","write","mirrorPadConfig","kernelName","backendName","kernelFunc"],"sources":["/home/nadimakhtar97/smart-attendance-system/tfjs-backend-cpu/src/kernels/MirrorPad.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, MirrorPad, MirrorPadAttrs, MirrorPadInputs, NumericDataType, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function mirrorPad(args: {\n  inputs: MirrorPadInputs,\n  backend: MathBackendCPU,\n  attrs: MirrorPadAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {paddings, mode} = attrs;\n\n  assertNotComplex(x, 'mirrorPad');\n\n  const outShape = paddings.map(\n      (p, i) => p[0] /* beforePad */ + x.shape[i] + p[1] /* afterPad */);\n\n  const start = paddings.map(p => p[0]);\n  const end = paddings.map((p, i) => p[0] + x.shape[i]);\n  const offset = mode === 'reflect' ? 0 : 1;\n\n  const xVals = backend.data.get(x.dataId).values as TypedArray;\n  const xRank = x.shape.length;\n  const xStrides = util.computeStrides(x.shape);\n\n  const resultSize = util.sizeFromShape(outShape);\n  const resultRank = outShape.length;\n  const resultStrides = util.computeStrides(outShape);\n  const resVals =\n      util.getTypedArrayFromDType(x.dtype as NumericDataType, resultSize);\n\n  for (let i = 0; i < resultSize; i++) {\n    let coords = util.indexToLoc(i, resultRank, resultStrides);\n    for (let i = 0; i < resultRank; i++) {\n      if (coords[i] < start[i]) {\n        coords[i] = start[i] * 2 - coords[i] - offset;\n      } else if (coords[i] >= end[i]) {\n        coords[i] = (end[i] - 1) * 2 - coords[i] + offset;\n      }\n    }\n    coords = coords.map((c, i) => c - start[i]);\n\n    const inIndex = util.locToIndex(coords, xRank, xStrides);\n\n    resVals[i] = xVals[inIndex];\n  }\n\n  const outId = backend.write(resVals, outShape, x.dtype);\n\n  return {dataId: outId, shape: outShape, dtype: x.dtype};\n}\n\nexport const mirrorPadConfig: KernelConfig = {\n  kernelName: MirrorPad,\n  backendName: 'cpu',\n  kernelFunc: mirrorPad as {} as KernelFunc\n};\n"]},"metadata":{},"sourceType":"module"}